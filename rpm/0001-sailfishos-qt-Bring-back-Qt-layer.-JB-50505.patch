From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Raine Makelainen <raine.makelainen@jolla.com>
Date: Fri, 28 Feb 2020 11:38:58 +0200
Subject: [PATCH] [sailfishos][qt] Bring back Qt layer. JB#50505

Revert "Bug 1282866 - remove widget/qt and other supporting QT code, r=dougt.  This patch does not remove
all of the checks for MOZ_WIDGET_QT (which are dead code), but that will be a followup mentored bug."

This reverts commit bf05496a833cfc1b4fb168b94e75fc93086111f2.

Revert "Bug 1285554 - Remove remnants of widget/qt. r=dougt,mshal."

This reverts commit a913f991077467a246072b3a8ecb45838a1363ba.

Revert "Bug 1286317 - part 2 - remove Qt widget usage from plugins. r=jrmuizel"

This reverts commit 0e1e833b40484fe21b93d4f1b53b9420637e2ed3.

This does not revert back pango configuration as it seems to be already removed.

Revert "Bug 1286317 - part 1 - remove Qt widget usage from gfx. r=jrmuizel"

This reverts commit 16ca3223d9d6f1bd8c4dba5ce1d9fbb986895b41.

[sailfishos][gecko] Add define to the iconconverter for preprocessor
[sailfishos][qt] Fix platform font list configuration. JB#50967

Signed-off-by: Raine Makelainen <raine.makelainen@jolla.com>

[sailfishos][qt] Enable print-to-PDF support. Contributes to JB#50680

Fix build of nsPrintSettingsQt and nsDeviceContextSpecQt with printing enabled

- Fixed build errors
- QPrinter and QPrinterInfo are removed since QtPrintSupport module
requires QtWidgets;
- GetPrinterNameList now returns an empty list, since getting the list of
available printers is implemented through QPrinterInfo.

[sailfishos][qt] Add nsIPrintSettingsService for Qt toolkit. Fixes JB#51349

Signed-off-by: Pavel Tumakaev <p.tumakaev@omprussia.ru>
Signed-off-by: Raine Makelainen <raine.makelainen@jolla.com>
---
 browser/base/content/browser-menubar.inc      |    2 +-
 browser/base/content/browser.xul              |    1 -
 browser/themes/moz.build                      |    2 +-
 build/moz.configure/old.configure             |    1 +
 dom/geolocation/moz.build                     |    6 +
 dom/geolocation/nsGeolocation.cpp             |    8 +
 dom/ipc/ContentChild.cpp                      |    9 +
 dom/ipc/moz.build                             |    2 +-
 dom/plugins/base/nsNPAPIPlugin.cpp            |    6 +-
 dom/plugins/ipc/NestedLoopTimer.cpp           |   48 +
 dom/plugins/ipc/NestedLoopTimer.h             |   41 +
 dom/plugins/ipc/PluginHelperQt.cpp            |   18 +
 dom/plugins/ipc/PluginHelperQt.h              |   16 +
 dom/plugins/ipc/PluginInstanceChild.cpp       |    5 +
 dom/plugins/ipc/PluginInstanceParent.cpp      |    3 +
 dom/plugins/ipc/PluginMessageUtils.h          |    2 +-
 dom/plugins/ipc/PluginModuleChild.cpp         |   60 +-
 dom/plugins/ipc/PluginModuleChild.h           |   11 +
 dom/plugins/ipc/PluginModuleParent.cpp        |   12 +-
 dom/plugins/ipc/moz.build                     |    7 +
 dom/system/moz.build                          |    4 +-
 dom/system/qt/QTMLocationProvider.cpp         |  101 +
 dom/system/qt/QTMLocationProvider.h           |   35 +
 dom/system/qt/QtHapticFeedback.cpp            |   20 +
 dom/system/qt/QtHapticFeedback.h              |   15 +
 dom/system/qt/moz.build                       |   26 +
 dom/xbl/builtin/moz.build                     |    2 +-
 .../embedlite/config/mozconfig.merqtxulrunner |    2 +-
 gfx/2d/2D.h                                   |    4 +-
 gfx/2d/Factory.cpp                            |    4 +-
 gfx/2d/UnscaledFontFreeType.h                 |    2 +-
 gfx/2d/moz.build                              |    8 +-
 gfx/cairo/cairo/src/moz.build                 |   12 +
 gfx/gl/moz.build                              |    2 +
 gfx/skia/generate_mozbuild.py                 |    6 +-
 gfx/skia/moz.build                            |    6 +-
 gfx/src/moz.build                             |    3 +
 gfx/thebes/gfxASurface.cpp                    |    2 +
 gfx/thebes/gfxFT2Fonts.cpp                    |    4 +
 gfx/thebes/gfxFcPlatformFontList.cpp          |    6 +
 gfx/thebes/gfxFont.h                          |    2 +-
 gfx/thebes/gfxPlatform.cpp                    |    5 +
 gfx/thebes/gfxQtNativeRenderer.cpp            |   48 +
 gfx/thebes/gfxQtNativeRenderer.h              |   68 +
 gfx/thebes/gfxQtPlatform.cpp                  |  185 ++
 gfx/thebes/gfxQtPlatform.h                    |   91 +
 gfx/thebes/moz.build                          |   30 +-
 gfx/webrender_bindings/Moz2DImageRenderer.cpp |    4 +-
 gfx/webrender_bindings/moz.build              |    2 +-
 image/decoders/icon/moz.build                 |    3 +
 image/decoders/icon/qt/gtkqticonsconverter.js |  145 ++
 .../icon/qt/gtkqticonsconverter.manifest      |    2 +
 image/decoders/icon/qt/moz.build              |   27 +
 .../icon/qt/nsGtkQtIconsConverter.idl         |   12 +
 image/decoders/icon/qt/nsIconChannel.cpp      |  134 ++
 image/decoders/icon/qt/nsIconChannel.h        |   40 +
 image/decoders/moz.build                      |    2 +
 intl/locale/moz.build                         |    5 +
 ipc/chromium/moz.build                        |    5 +
 layout/base/nsPresContext.cpp                 |    7 +-
 layout/generic/moz.build                      |    3 +
 netwerk/base/moz.build                        |    8 +
 netwerk/build/moz.build                       |    5 +
 netwerk/build/nsNetModule.cpp                 |    9 +
 netwerk/protocol/moz.build                    |    2 +-
 netwerk/system/moz.build                      |    3 +
 netwerk/system/qt/moz.build                   |   18 +
 netwerk/system/qt/nsQtNetworkLinkService.cpp  |   98 +
 netwerk/system/qt/nsQtNetworkLinkService.h    |   29 +
 netwerk/system/qt/nsQtNetworkManager.cpp      |  162 ++
 netwerk/system/qt/nsQtNetworkManager.h        |   56 +
 old-configure.in                              |  182 +-
 toolkit/library/moz.build                     |   12 +-
 toolkit/modules/AppConstants.jsm              |    2 +
 toolkit/moz.build                             |    2 +-
 toolkit/moz.configure                         |   14 +-
 toolkit/themes/moz.build                      |    2 +-
 toolkit/xre/moz.build                         |    7 +
 toolkit/xre/nsAppRunner.cpp                   |   40 +
 toolkit/xre/nsEmbedFunctions.cpp              |    8 +
 toolkit/xre/nsNativeAppSupportQt.cpp          |  118 ++
 toolkit/xre/nsNativeAppSupportQt.h            |   37 +
 toolkit/xre/nsQAppInstance.cpp                |   31 +
 toolkit/xre/nsQAppInstance.h                  |   28 +
 uriloader/exthandler/moz.build                |   10 +-
 uriloader/exthandler/unix/nsMIMEInfoQt.cpp    |   30 +
 uriloader/exthandler/unix/nsMIMEInfoQt.h      |   20 +
 uriloader/exthandler/unix/nsMIMEInfoUnix.cpp  |   20 +-
 widget/NativeKeyToDOMCodeName.h               |    2 +-
 widget/NativeKeyToDOMKeyName.h                |  206 ++
 widget/headless/HeadlessWidget.h              |    6 +
 widget/moz.build                              |    6 +-
 widget/qt/GfxInfo.cpp                         |  194 ++
 widget/qt/GfxInfo.h                           |   66 +
 widget/qt/moz.build                           |   66 +
 widget/qt/mozqwidget.cpp                      |  231 +++
 widget/qt/mozqwidget.h                        |   71 +
 widget/qt/nsAppShell.cpp                      |   80 +
 widget/qt/nsAppShell.h                        |   37 +
 widget/qt/nsBidiKeyboard.cpp                  |   47 +
 widget/qt/nsBidiKeyboard.h                    |   25 +
 widget/qt/nsClipboard.cpp                     |  563 ++++++
 widget/qt/nsClipboard.h                       |   41 +
 widget/qt/nsDeviceContextSpecQt.cpp           |  228 +++
 widget/qt/nsDeviceContextSpecQt.h             |   60 +
 widget/qt/nsIdleServiceQt.cpp                 |  123 ++
 widget/qt/nsIdleServiceQt.h                   |   56 +
 widget/qt/nsLookAndFeel.cpp                   |  459 +++++
 widget/qt/nsLookAndFeel.h                     |   42 +
 widget/qt/nsPrintDialogQt.cpp                 |   43 +
 widget/qt/nsPrintDialogQt.h                   |   32 +
 widget/qt/nsPrintOptionsQt.cpp                |   23 +
 widget/qt/nsPrintOptionsQt.h                  |   20 +
 widget/qt/nsPrintSettingsQt.cpp               |  411 ++++
 widget/qt/nsPrintSettingsQt.h                 |   93 +
 widget/qt/nsQtKeyUtils.cpp                    |  480 +++++
 widget/qt/nsQtKeyUtils.h                      |   19 +
 widget/qt/nsScreenManagerQt.cpp               |   86 +
 widget/qt/nsScreenManagerQt.h                 |   34 +
 widget/qt/nsScreenQt.cpp                      |   74 +
 widget/qt/nsScreenQt.h                        |   29 +
 widget/qt/nsWidgetFactory.cpp                 |  162 ++
 widget/qt/nsWindow.cpp                        | 1684 +++++++++++++++++
 widget/qt/nsWindow.h                          |  316 ++++
 124 files changed, 8356 insertions(+), 56 deletions(-)
 create mode 100644 dom/plugins/ipc/NestedLoopTimer.cpp
 create mode 100644 dom/plugins/ipc/NestedLoopTimer.h
 create mode 100644 dom/plugins/ipc/PluginHelperQt.cpp
 create mode 100644 dom/plugins/ipc/PluginHelperQt.h
 create mode 100644 dom/system/qt/QTMLocationProvider.cpp
 create mode 100644 dom/system/qt/QTMLocationProvider.h
 create mode 100644 dom/system/qt/QtHapticFeedback.cpp
 create mode 100644 dom/system/qt/QtHapticFeedback.h
 create mode 100644 dom/system/qt/moz.build
 create mode 100644 gfx/thebes/gfxQtNativeRenderer.cpp
 create mode 100644 gfx/thebes/gfxQtNativeRenderer.h
 create mode 100644 gfx/thebes/gfxQtPlatform.cpp
 create mode 100644 gfx/thebes/gfxQtPlatform.h
 create mode 100644 image/decoders/icon/qt/gtkqticonsconverter.js
 create mode 100644 image/decoders/icon/qt/gtkqticonsconverter.manifest
 create mode 100644 image/decoders/icon/qt/moz.build
 create mode 100644 image/decoders/icon/qt/nsGtkQtIconsConverter.idl
 create mode 100644 image/decoders/icon/qt/nsIconChannel.cpp
 create mode 100644 image/decoders/icon/qt/nsIconChannel.h
 create mode 100644 netwerk/system/qt/moz.build
 create mode 100644 netwerk/system/qt/nsQtNetworkLinkService.cpp
 create mode 100644 netwerk/system/qt/nsQtNetworkLinkService.h
 create mode 100644 netwerk/system/qt/nsQtNetworkManager.cpp
 create mode 100644 netwerk/system/qt/nsQtNetworkManager.h
 create mode 100644 toolkit/xre/nsNativeAppSupportQt.cpp
 create mode 100644 toolkit/xre/nsNativeAppSupportQt.h
 create mode 100644 toolkit/xre/nsQAppInstance.cpp
 create mode 100644 toolkit/xre/nsQAppInstance.h
 create mode 100644 uriloader/exthandler/unix/nsMIMEInfoQt.cpp
 create mode 100644 uriloader/exthandler/unix/nsMIMEInfoQt.h
 create mode 100644 widget/qt/GfxInfo.cpp
 create mode 100644 widget/qt/GfxInfo.h
 create mode 100644 widget/qt/moz.build
 create mode 100644 widget/qt/mozqwidget.cpp
 create mode 100644 widget/qt/mozqwidget.h
 create mode 100644 widget/qt/nsAppShell.cpp
 create mode 100644 widget/qt/nsAppShell.h
 create mode 100644 widget/qt/nsBidiKeyboard.cpp
 create mode 100644 widget/qt/nsBidiKeyboard.h
 create mode 100644 widget/qt/nsClipboard.cpp
 create mode 100644 widget/qt/nsClipboard.h
 create mode 100644 widget/qt/nsDeviceContextSpecQt.cpp
 create mode 100644 widget/qt/nsDeviceContextSpecQt.h
 create mode 100644 widget/qt/nsIdleServiceQt.cpp
 create mode 100644 widget/qt/nsIdleServiceQt.h
 create mode 100644 widget/qt/nsLookAndFeel.cpp
 create mode 100644 widget/qt/nsLookAndFeel.h
 create mode 100644 widget/qt/nsPrintDialogQt.cpp
 create mode 100644 widget/qt/nsPrintDialogQt.h
 create mode 100644 widget/qt/nsPrintOptionsQt.cpp
 create mode 100644 widget/qt/nsPrintOptionsQt.h
 create mode 100644 widget/qt/nsPrintSettingsQt.cpp
 create mode 100644 widget/qt/nsPrintSettingsQt.h
 create mode 100644 widget/qt/nsQtKeyUtils.cpp
 create mode 100644 widget/qt/nsQtKeyUtils.h
 create mode 100644 widget/qt/nsScreenManagerQt.cpp
 create mode 100644 widget/qt/nsScreenManagerQt.h
 create mode 100644 widget/qt/nsScreenQt.cpp
 create mode 100644 widget/qt/nsScreenQt.h
 create mode 100644 widget/qt/nsWidgetFactory.cpp
 create mode 100644 widget/qt/nsWindow.cpp
 create mode 100644 widget/qt/nsWindow.h

diff --git a/browser/base/content/browser-menubar.inc b/browser/base/content/browser-menubar.inc
index b4857a5fe238..43125bfb5ab4 100644
--- a/browser/base/content/browser-menubar.inc
+++ b/browser/base/content/browser-menubar.inc
@@ -69,7 +69,7 @@
                           accesskey="&emailPageCmd.accesskey;"
                           command="Browser:SendLink"/>
                 <menuseparator/>
-#if !defined(MOZ_WIDGET_GTK)
+#if !defined(MOZ_WIDGET_GTK) && !defined(MOZ_WIDGET_QT)
                 <menuitem id="menu_printSetup"
                           label="&printSetupCmd.label;"
                           accesskey="&printSetupCmd.accesskey;"
diff --git a/browser/base/content/browser.xul b/browser/base/content/browser.xul
index 4d8496bbcf24..eca807d7efae 100644
--- a/browser/base/content/browser.xul
+++ b/browser/base/content/browser.xul
@@ -691,7 +691,6 @@
       <hbox class="titlebar-placeholder" type="post-tabs"
             ordinal="1000"
             skipintoolbarset="true"/>
-#endif
 
       <button class="accessibility-indicator" tooltiptext="&accessibilityIndicator.tooltip;"
               ordinal="1000"
diff --git a/browser/themes/moz.build b/browser/themes/moz.build
index d0e54e5fd2dd..5f3ffc876c78 100644
--- a/browser/themes/moz.build
+++ b/browser/themes/moz.build
@@ -11,7 +11,7 @@ toolkit = CONFIG['MOZ_WIDGET_TOOLKIT']
 
 if toolkit == 'cocoa':
     DIRS += ['osx']
-elif toolkit == 'gtk3':
+elif toolkit in ('gtk3', 'qt'):
     DIRS += ['linux']
 else:
     DIRS += ['windows']
diff --git a/build/moz.configure/old.configure b/build/moz.configure/old.configure
index 17d0c5bf3420..403ebc479d18 100644
--- a/build/moz.configure/old.configure
+++ b/build/moz.configure/old.configure
@@ -264,6 +264,7 @@ def old_configure_options(*options):
     '--with-nss-prefix',
     '--with-pthreads',
     '--with-qemu-exe',
+    '--with-qtdir',
     '--with-sixgill',
     '--with-soft-float',
     '--with-system-bz2',
diff --git a/dom/geolocation/moz.build b/dom/geolocation/moz.build
index 86b9d2d4fb57..29d166a9b226 100644
--- a/dom/geolocation/moz.build
+++ b/dom/geolocation/moz.build
@@ -29,6 +29,12 @@ LOCAL_INCLUDES += [
     '/dom/ipc',
 ]
 
+if CONFIG['MOZ_ENABLE_QT5GEOPOSITION']:
+    LOCAL_INCLUDES += [
+        '/dom/system/qt',
+    ]
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     LOCAL_INCLUDES += [
         '/dom/system/android',
diff --git a/dom/geolocation/nsGeolocation.cpp b/dom/geolocation/nsGeolocation.cpp
index 6e5c0e4cb57f..55c41cd7ce71 100644
--- a/dom/geolocation/nsGeolocation.cpp
+++ b/dom/geolocation/nsGeolocation.cpp
@@ -32,6 +32,10 @@
 
 class nsIPrincipal;
 
+#ifdef MOZ_ENABLE_QT5GEOPOSITION
+#include "QTMLocationProvider.h"
+#endif
+
 #ifdef MOZ_WIDGET_ANDROID
 #include "AndroidLocationProvider.h"
 #endif
@@ -659,6 +663,10 @@ nsresult nsGeolocationService::Init() {
 
   obs->AddObserver(this, "xpcom-shutdown", false);
 
+#ifdef MOZ_ENABLE_QT5GEOPOSITION
+  mProvider = new QTMLocationProvider();
+#endif
+
 #ifdef MOZ_WIDGET_ANDROID
   mProvider = new AndroidLocationProvider();
 #endif
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index 51a3ab928b6e..fcbba1d3d873 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -8,6 +8,10 @@
 #include <gtk/gtk.h>
 #endif
 
+#ifdef MOZ_WIDGET_QT
+#include "nsQAppInstance.h"
+#endif
+
 #include "ContentChild.h"
 
 #include "GeckoProfiler.h"
@@ -595,6 +599,11 @@ bool ContentChild::Init(MessageLoop* aIOLoop, base::ProcessId aParentPid,
   }
 #endif
 
+#ifdef MOZ_WIDGET_QT
+  // sigh, seriously
+  nsQAppInstance::AddRef();
+#endif
+
 #ifdef MOZ_X11
   if (!gfxPlatform::IsHeadless()) {
     // Do this after initializing GDK, or GDK will install its own handler.
diff --git a/dom/ipc/moz.build b/dom/ipc/moz.build
index 6753681e7eea..f47f58b581f1 100644
--- a/dom/ipc/moz.build
+++ b/dom/ipc/moz.build
@@ -159,7 +159,7 @@ if CONFIG['OS_ARCH'] != 'WINNT':
 
 DEFINES['BIN_SUFFIX'] = '"%s"' % CONFIG['BIN_SUFFIX']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'qt'):
     DEFINES['MOZ_ENABLE_FREETYPE'] = True
 
 if CONFIG['MOZ_TOOLKIT_SEARCH']:
diff --git a/dom/plugins/base/nsNPAPIPlugin.cpp b/dom/plugins/base/nsNPAPIPlugin.cpp
index 66ed9162a947..9a2adf484dce 100644
--- a/dom/plugins/base/nsNPAPIPlugin.cpp
+++ b/dom/plugins/base/nsNPAPIPlugin.cpp
@@ -1261,7 +1261,7 @@ NPError _getvalue(NPP npp, NPNVariable variable, void *result) {
       return NPERR_GENERIC_ERROR;
 #endif
 
-#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
     case NPNVnetscapeWindow: {
       if (!npp || !npp->ndata) return NPERR_INVALID_INSTANCE_ERROR;
 
@@ -1303,7 +1303,7 @@ NPError _getvalue(NPP npp, NPNVariable variable, void *result) {
     }
 
     case NPNVToolkit: {
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
       *((NPNToolkitType *)result) = NPNVGtk2;
 #endif
 
@@ -1313,7 +1313,7 @@ NPError _getvalue(NPP npp, NPNVariable variable, void *result) {
     }
 
     case NPNVSupportsXEmbedBool: {
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
       *(NPBool *)result = true;
 #else
       *(NPBool *)result = false;
diff --git a/dom/plugins/ipc/NestedLoopTimer.cpp b/dom/plugins/ipc/NestedLoopTimer.cpp
new file mode 100644
index 000000000000..5b20c7278117
--- /dev/null
+++ b/dom/plugins/ipc/NestedLoopTimer.cpp
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: sw=4 ts=4 et :
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QtCore/QTimer>
+
+#include "NestedLoopTimer.h"
+#include "mozilla/plugins/PluginModuleChild.h"
+
+namespace mozilla {
+namespace plugins {
+
+NestedLoopTimer::NestedLoopTimer(PluginModuleChild *pmc):
+     QObject(), mModule(pmc), mQTimer(nullptr)
+{
+}
+
+NestedLoopTimer::~NestedLoopTimer()
+{
+    if (mQTimer) {
+        mQTimer->stop();
+        delete mQTimer;
+        mQTimer = nullptr;
+    }
+}
+
+void NestedLoopTimer::timeOut()
+{
+    // just detected a nested loop; start a timer that will
+    // periodically rpc-call back into the browser and process some
+    // events
+    mQTimer = new QTimer(this);
+    QObject::connect(mQTimer, SIGNAL(timeout()), this,
+                     SLOT(processSomeEvents()));
+    mQTimer->setInterval(kNestedLoopDetectorIntervalMs);
+    mQTimer->start();
+}
+
+void NestedLoopTimer::processSomeEvents()
+{
+    if (mModule)
+        mModule->CallProcessSomeEvents();
+}
+
+} /* namespace plugins */
+} /* namespace mozilla */
diff --git a/dom/plugins/ipc/NestedLoopTimer.h b/dom/plugins/ipc/NestedLoopTimer.h
new file mode 100644
index 000000000000..06136badb556
--- /dev/null
+++ b/dom/plugins/ipc/NestedLoopTimer.h
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: sw=4 ts=4 et :
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef NESTEDLOOPTIMER_H
+#define NESTEDLOOPTIMER_H
+
+#include <QtCore/QObject>
+
+class QTimer;
+
+namespace mozilla {
+namespace plugins {
+
+class PluginModuleChild;
+
+class NestedLoopTimer: public QObject
+{
+    Q_OBJECT
+public:
+    NestedLoopTimer(PluginModuleChild *pmc);
+
+    virtual ~NestedLoopTimer();
+
+public Q_SLOTS:
+    virtual void timeOut();
+    virtual void processSomeEvents();
+   
+private:
+    PluginModuleChild *mModule;
+    QTimer *mQTimer;
+};
+
+} /* namespace plugins */
+} /* namespace mozilla */
+
+#undef slots
+
+#endif
diff --git a/dom/plugins/ipc/PluginHelperQt.cpp b/dom/plugins/ipc/PluginHelperQt.cpp
new file mode 100644
index 000000000000..19128edb517b
--- /dev/null
+++ b/dom/plugins/ipc/PluginHelperQt.cpp
@@ -0,0 +1,18 @@
+/* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "PluginHelperQt.h"
+#include <QtCore/QCoreApplication>
+#include <QtCore/QEventLoop>
+
+static const int kMaxtimeToProcessEvents = 30;
+
+bool
+PluginHelperQt::AnswerProcessSomeEvents()
+{
+    QCoreApplication::processEvents(QEventLoop::AllEvents, kMaxtimeToProcessEvents);
+    return true;
+}
diff --git a/dom/plugins/ipc/PluginHelperQt.h b/dom/plugins/ipc/PluginHelperQt.h
new file mode 100644
index 000000000000..b940431b7b54
--- /dev/null
+++ b/dom/plugins/ipc/PluginHelperQt.h
@@ -0,0 +1,16 @@
+/* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef PluginHelperQt_h_
+#define PluginHelperQt_h_
+
+class PluginHelperQt
+{
+public:
+  static bool AnswerProcessSomeEvents();
+};
+
+#endif // PluginHelperQt_h_
diff --git a/dom/plugins/ipc/PluginInstanceChild.cpp b/dom/plugins/ipc/PluginInstanceChild.cpp
index 7d190dbe363a..444ec277ec5f 100644
--- a/dom/plugins/ipc/PluginInstanceChild.cpp
+++ b/dom/plugins/ipc/PluginInstanceChild.cpp
@@ -53,6 +53,9 @@ using namespace std;
 #include <gdk/gdk.h>
 #include "gtk2xtbin.h"
 
+#elif defined(MOZ_WIDGET_QT)
+#undef KeyPress
+#undef KeyRelease
 #elif defined(OS_WIN)
 
 #include <windows.h>
@@ -1194,6 +1197,8 @@ mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_SetWindow(
 
 #elif defined(ANDROID)
   // TODO: Need Android impl
+#elif defined(MOZ_WIDGET_QT)
+  // Don't care
 #elif defined(MOZ_WIDGET_UIKIT)
   // Don't care
 #else
diff --git a/dom/plugins/ipc/PluginInstanceParent.cpp b/dom/plugins/ipc/PluginInstanceParent.cpp
index 0f086f95848e..3d252a6a00b0 100644
--- a/dom/plugins/ipc/PluginInstanceParent.cpp
+++ b/dom/plugins/ipc/PluginInstanceParent.cpp
@@ -234,6 +234,9 @@ PluginInstanceParent::AnswerNPN_GetValue_NPNVnetscapeWindow(
 #elif defined(ANDROID)
   // TODO: Need Android impl
   int id;
+#elif defined(MOZ_WIDGET_QT)
+  // TODO: Need Qt non X impl
+  int id;
 #else
 #warning Implement me
 #endif
diff --git a/dom/plugins/ipc/PluginMessageUtils.h b/dom/plugins/ipc/PluginMessageUtils.h
index ecee4a106192..360a5dea44c9 100644
--- a/dom/plugins/ipc/PluginMessageUtils.h
+++ b/dom/plugins/ipc/PluginMessageUtils.h
@@ -111,7 +111,7 @@ struct NPAudioDeviceChangeDetailsIPC {
 typedef HWND NativeWindowHandle;
 #elif defined(MOZ_X11)
 typedef XID NativeWindowHandle;
-#elif defined(XP_DARWIN) || defined(ANDROID)
+#elif defined(XP_DARWIN) || defined(ANDROID) || defined(MOZ_WIDGET_QT)
 typedef intptr_t NativeWindowHandle;  // never actually used, will always be 0
 #else
 #error Need NativeWindowHandle for this platform
diff --git a/dom/plugins/ipc/PluginModuleChild.cpp b/dom/plugins/ipc/PluginModuleChild.cpp
index f260b39dc133..308bdd5dacc2 100644
--- a/dom/plugins/ipc/PluginModuleChild.cpp
+++ b/dom/plugins/ipc/PluginModuleChild.cpp
@@ -4,6 +4,12 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#ifdef MOZ_WIDGET_QT
+#include <QtCore/QTimer>
+#include "nsQAppInstance.h"
+#include "NestedLoopTimer.h"
+#endif
+
 #include "mozilla/plugins/PluginModuleChild.h"
 
 /* This must occur *after* plugins/PluginModuleChild.h to avoid typedefs
@@ -73,6 +79,12 @@ namespace {
 PluginModuleChild* gChromeInstance = nullptr;
 }  // namespace
 
+#ifdef MOZ_WIDGET_QT
+typedef void (*_gtk_init_fn)(int argc, char **argv);
+static _gtk_init_fn s_gtk_init = nullptr;
+static PRLibrary *sGtkLib = nullptr;
+#endif
+
 #ifdef XP_WIN
 // Used with fix for flash fullscreen window loosing focus.
 static bool gDelayFlashFocusReplyUntilEval = false;
@@ -99,6 +111,9 @@ PluginModuleChild::PluginModuleChild(bool aIsChrome)
 #elif defined(MOZ_WIDGET_GTK)
       ,
       mNestedLoopTimerId(0)
+#elif defined(MOZ_WIDGET_QT)
+      ,
+      mNestedLoopTimerObject(0)
 #endif
 #ifdef OS_WIN
       ,
@@ -309,7 +324,6 @@ bool PluginModuleChild::InitForChrome(const std::string& aPluginFilename,
 }
 
 #if defined(MOZ_WIDGET_GTK)
-
 typedef void (*GObjectDisposeFn)(GObject*);
 typedef gboolean (*GtkWidgetScrollEventFn)(GtkWidget*, GdkEventScroll*);
 typedef void (*GtkPlugEmbeddedFn)(GtkPlug*);
@@ -509,6 +523,26 @@ void PluginModuleChild::ExitedCxxStack() {
   g_source_remove(mNestedLoopTimerId);
   mNestedLoopTimerId = 0;
 }
+#elif defined (MOZ_WIDGET_QT)
+
+void
+PluginModuleChild::EnteredCxxStack()
+{
+    MOZ_ASSERT(mNestedLoopTimerObject == nullptr,
+               "previous timer not descheduled");
+    mNestedLoopTimerObject = new NestedLoopTimer(this);
+    QTimer::singleShot(kNestedLoopDetectorIntervalMs,
+                       mNestedLoopTimerObject, SLOT(timeOut()));
+}
+
+void
+PluginModuleChild::ExitedCxxStack()
+{
+    MOZ_ASSERT(mNestedLoopTimerObject != nullptr,
+               "nested loop timeout not scheduled");
+    delete mNestedLoopTimerObject;
+    mNestedLoopTimerObject = nullptr;
+}
 
 #endif
 
@@ -563,6 +597,19 @@ bool PluginModuleChild::InitGraphics() {
   real_gtk_plug_embedded = *embedded;
   *embedded = wrap_gtk_plug_embedded;
 
+#elif defined(MOZ_WIDGET_QT)
+    nsQAppInstance::AddRef();
+    // Work around plugins that don't interact well without gtk initialized
+    // see bug 566845
+#if defined(MOZ_X11)
+    if (!sGtkLib)
+         sGtkLib = PR_LoadLibrary("libgtk-x11-2.0.so.0");
+#endif
+    if (sGtkLib) {
+         s_gtk_init = (_gtk_init_fn)PR_FindFunctionSymbol(sGtkLib, "gtk_init");
+         if (s_gtk_init)
+             s_gtk_init(0, 0);
+    }
 #else
 // may not be necessary on all platforms
 #endif
@@ -574,6 +621,15 @@ bool PluginModuleChild::InitGraphics() {
 }
 
 void PluginModuleChild::DeinitGraphics() {
+#ifdef MOZ_WIDGET_QT
+    nsQAppInstance::Release();
+    if (sGtkLib) {
+        PR_UnloadLibrary(sGtkLib);
+        sGtkLib = nullptr;
+        s_gtk_init = nullptr;
+    }
+#endif
+
 #if defined(MOZ_X11) && defined(NS_FREE_PERMANENT_DATA)
   // We free some data off of XDisplay close hooks, ensure they're
   // run.  Closing the display is pretty scary, so we only do it to
@@ -976,7 +1032,7 @@ NPError _getvalue(NPP aNPP, NPNVariable aVariable, void* aValue) {
   switch (aVariable) {
     // Copied from nsNPAPIPlugin.cpp
     case NPNVToolkit:
-#if defined(MOZ_WIDGET_GTK)
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
       *static_cast<NPNToolkitType*>(aValue) = NPNVGtk2;
       return NPERR_NO_ERROR;
 #endif
diff --git a/dom/plugins/ipc/PluginModuleChild.h b/dom/plugins/ipc/PluginModuleChild.h
index 3d71bd678219..2d8228bae25a 100644
--- a/dom/plugins/ipc/PluginModuleChild.h
+++ b/dom/plugins/ipc/PluginModuleChild.h
@@ -38,6 +38,11 @@ class ChildProfilerController;
 
 namespace plugins {
 
+#ifdef MOZ_WIDGET_QT
+class NestedLoopTimer;
+static const int kNestedLoopDetectorIntervalMs = 90;
+#endif
+
 class PluginInstanceChild;
 
 class PluginModuleChild : public PPluginModuleChild {
@@ -206,6 +211,10 @@ class PluginModuleChild : public PPluginModuleChild {
   static gboolean DetectNestedEventLoop(gpointer data);
   static gboolean ProcessBrowserEvents(gpointer data);
 
+  virtual void EnteredCxxStack() override;
+  virtual void ExitedCxxStack() override;
+#elif defined(MOZ_WIDGET_QT)
+
   virtual void EnteredCxxStack() override;
   virtual void ExitedCxxStack() override;
 #endif
@@ -272,6 +281,8 @@ class PluginModuleChild : public PPluginModuleChild {
   // MessagePumpForUI.
   int mTopLoopDepth;
 #endif
+#elif defined (MOZ_WIDGET_QT)
+  NestedLoopTimer *mNestedLoopTimerObject;
 #endif
 
 #if defined(XP_WIN)
diff --git a/dom/plugins/ipc/PluginModuleParent.cpp b/dom/plugins/ipc/PluginModuleParent.cpp
index 02b90d25ffa5..8bb31de66de9 100644
--- a/dom/plugins/ipc/PluginModuleParent.cpp
+++ b/dom/plugins/ipc/PluginModuleParent.cpp
@@ -4,6 +4,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#ifdef MOZ_WIDGET_QT
+#include "PluginHelperQt.h"
+#endif
+
 #include "mozilla/plugins/PluginModuleParent.h"
 
 #include "base/process_util.h"
@@ -2321,7 +2325,13 @@ mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
   mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop();
   return IPC_OK();
 }
-
+#elif defined(MOZ_WIDGET_QT)
+mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
+    PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
+    PluginHelperQt::AnswerProcessSomeEvents();
+    PLUGIN_LOG_DEBUG(("... quitting mini nested loop"));
+    return IPC_OK();
+}
 #elif !defined(MOZ_WIDGET_GTK)
 mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
   MOZ_CRASH("unreached");
diff --git a/dom/plugins/ipc/moz.build b/dom/plugins/ipc/moz.build
index 52b2e00e65da..521d82809648 100644
--- a/dom/plugins/ipc/moz.build
+++ b/dom/plugins/ipc/moz.build
@@ -62,6 +62,13 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
         'PluginInterposeOSX.h',
     ]
 
+if CONFIG['MOZ_ENABLE_QT']:
+    SOURCES += [
+        '!moc_NestedLoopTimer.cpp',
+        'NestedLoopTimer.cpp',
+        'PluginHelperQt.cpp',
+    ]
+
 UNIFIED_SOURCES += [
     'BrowserStreamChild.cpp',
     'BrowserStreamParent.cpp',
diff --git a/dom/system/moz.build b/dom/system/moz.build
index a950df1572a0..a19d30377398 100644
--- a/dom/system/moz.build
+++ b/dom/system/moz.build
@@ -40,7 +40,9 @@ with Files("tests/*1197901*"):
 
 toolkit = CONFIG['MOZ_WIDGET_TOOLKIT']
 
-if toolkit == 'windows':
+if toolkit == 'qt':
+    DIRS += ['qt']
+elif toolkit == 'windows':
     DIRS += ['windows']
 elif toolkit == 'cocoa':
     DIRS += ['mac']
diff --git a/dom/system/qt/QTMLocationProvider.cpp b/dom/system/qt/QTMLocationProvider.cpp
new file mode 100644
index 000000000000..58fcc2e50743
--- /dev/null
+++ b/dom/system/qt/QTMLocationProvider.cpp
@@ -0,0 +1,101 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "QTMLocationProvider.h"
+#include "nsGeoPosition.h"
+
+using namespace mozilla;
+
+NS_IMPL_ISUPPORTS(QTMLocationProvider, nsIGeolocationProvider)
+
+QTMLocationProvider::QTMLocationProvider()
+{
+    if (QMetaType::type("QGeoPositionInfo") == QMetaType::UnknownType) {
+        qRegisterMetaType<QGeoPositionInfo>("QGeoPositionInfo");
+    }
+    mLocation = QGeoPositionInfoSource::createDefaultSource(this);
+    if (mLocation)
+        connect(mLocation, SIGNAL(positionUpdated(QGeoPositionInfo)), this, SLOT(positionUpdated(QGeoPositionInfo)));
+}
+
+QTMLocationProvider::~QTMLocationProvider()
+{
+    delete mLocation;
+}
+
+void
+QTMLocationProvider::positionUpdated(const QGeoPositionInfo &geoPosition)
+{
+    if (!geoPosition.isValid()) {
+        NS_WARNING("Invalida geoposition received");
+        return;
+    }
+
+    QGeoCoordinate coord = geoPosition.coordinate();
+    double latitude = coord.latitude();
+    double longitude = coord.longitude();
+    double altitude = coord.altitude();
+    double accuracy = geoPosition.attribute(QGeoPositionInfo::HorizontalAccuracy);
+    double altitudeAccuracy = geoPosition.attribute(QGeoPositionInfo::VerticalAccuracy);
+    double heading = geoPosition.attribute(QGeoPositionInfo::Direction);
+
+    bool providesSpeed = geoPosition.hasAttribute(QGeoPositionInfo::GroundSpeed);
+    double speed = geoPosition.attribute(QGeoPositionInfo::GroundSpeed);
+
+    RefPtr<nsGeoPosition> p =
+        new nsGeoPosition(latitude, longitude,
+                          altitude, accuracy,
+                          altitudeAccuracy, heading,
+                          speed, geoPosition.timestamp().toTime_t());
+    if (mCallback) {
+        mCallback->Update(p);
+    }
+}
+
+NS_IMETHODIMP
+QTMLocationProvider::Startup()
+{
+    if (!mLocation)
+        return NS_ERROR_NOT_IMPLEMENTED;
+
+    // Not all versions of qt5positioning set default prefered method
+    // thus this workaround initializing QGeoPositionSource explicitly
+    SetHighAccuracy(false);
+    mLocation->startUpdates();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+QTMLocationProvider::Watch(nsIGeolocationUpdate* aCallback)
+{
+    mCallback = aCallback;
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+QTMLocationProvider::Shutdown()
+{
+    if (!mLocation)
+        return NS_ERROR_NOT_IMPLEMENTED;
+
+    mLocation->stopUpdates();
+    mCallback = nullptr;
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+QTMLocationProvider::SetHighAccuracy(bool aHigh)
+{
+    if (!mLocation)
+        return NS_ERROR_NOT_IMPLEMENTED;
+
+    mLocation->setPreferredPositioningMethods(aHigh ?
+                                              QGeoPositionInfoSource::SatellitePositioningMethods :
+                                              QGeoPositionInfoSource::AllPositioningMethods);
+    return NS_OK;
+}
diff --git a/dom/system/qt/QTMLocationProvider.h b/dom/system/qt/QTMLocationProvider.h
new file mode 100644
index 000000000000..07b34c846119
--- /dev/null
+++ b/dom/system/qt/QTMLocationProvider.h
@@ -0,0 +1,35 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef QTMLocationProvider_h
+#define QTMLocationProvider_h
+
+#include <QGeoPositionInfoSource>
+#include "nsGeolocation.h"
+#include "nsIGeolocationProvider.h"
+#include "nsCOMPtr.h"
+
+class QTMLocationProvider : public QObject,
+                            public nsIGeolocationProvider
+{
+    Q_OBJECT
+
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIGEOLOCATIONPROVIDER
+
+    QTMLocationProvider();
+
+public Q_SLOTS:
+    // QGeoPositionInfoSource
+    void positionUpdated(const QGeoPositionInfo&);
+
+private:
+    ~QTMLocationProvider();
+
+    QGeoPositionInfoSource* mLocation;
+    nsCOMPtr<nsIGeolocationUpdate> mCallback;
+};
+
+#endif /* QTMLocationProvider_h */
diff --git a/dom/system/qt/QtHapticFeedback.cpp b/dom/system/qt/QtHapticFeedback.cpp
new file mode 100644
index 000000000000..91aa1592d317
--- /dev/null
+++ b/dom/system/qt/QtHapticFeedback.cpp
@@ -0,0 +1,20 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QFeedbackEffect>
+#include "QtHapticFeedback.h"
+
+NS_IMPL_ISUPPORTS(QtHapticFeedback, nsIHapticFeedback)
+
+NS_IMETHODIMP
+QtHapticFeedback::PerformSimpleAction(int32_t aType)
+{
+    if (aType == ShortPress)
+        QFeedbackEffect::playThemeEffect(QFeedbackEffect::PressWeak);
+    if (aType == LongPress)
+        QFeedbackEffect::playThemeEffect(QFeedbackEffect::PressStrong);
+
+    return NS_OK;
+}
diff --git a/dom/system/qt/QtHapticFeedback.h b/dom/system/qt/QtHapticFeedback.h
new file mode 100644
index 000000000000..64fff752695b
--- /dev/null
+++ b/dom/system/qt/QtHapticFeedback.h
@@ -0,0 +1,15 @@
+/* -*- Mode: c++; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsIHapticFeedback.h"
+
+class QtHapticFeedback : public nsIHapticFeedback
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIHAPTICFEEDBACK
+protected:
+  virtual ~QtHapticFeedback() {}
+};
diff --git a/dom/system/qt/moz.build b/dom/system/qt/moz.build
new file mode 100644
index 000000000000..6e418008b29a
--- /dev/null
+++ b/dom/system/qt/moz.build
@@ -0,0 +1,26 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+if CONFIG['MOZ_ENABLE_QT5GEOPOSITION']:
+    SOURCES += [
+        '!moc_QTMLocationProvider.cpp',
+        'QTMLocationProvider.cpp',
+    ]
+
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
+
+    LOCAL_INCLUDES += [
+        '/dom/geolocation',
+    ]
+
+if CONFIG['MOZ_ENABLE_QT5FEEDBACK']:
+    SOURCES += [
+        'QtHapticFeedback.cpp',
+    ]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+FINAL_LIBRARY = 'xul'
diff --git a/dom/xbl/builtin/moz.build b/dom/xbl/builtin/moz.build
index deafd7ca0e1a..9dec5826cda1 100644
--- a/dom/xbl/builtin/moz.build
+++ b/dom/xbl/builtin/moz.build
@@ -10,7 +10,7 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
     DIRS += ['mac']
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     DIRS += ['android']
-elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] in ('qt', 'gtk3'):
     DIRS += ['unix']
 else:
     DIRS += ['emacs']
diff --git a/embedding/embedlite/config/mozconfig.merqtxulrunner b/embedding/embedlite/config/mozconfig.merqtxulrunner
index 6044ac780a7a..06a016570bbc 100644
--- a/embedding/embedlite/config/mozconfig.merqtxulrunner
+++ b/embedding/embedlite/config/mozconfig.merqtxulrunner
@@ -42,7 +42,7 @@ ac_add_options --disable-stylo
 # ac_add_options --enable-warnings-as-errors
 
 # disabling for now, since the build fails...
-ac_add_options --enable-webrtc
+ac_add_options --disable-webrtc
 ac_add_options --enable-profiling
 ac_add_options --disable-dbus
 ac_add_options --disable-necko-wifi
diff --git a/gfx/2d/2D.h b/gfx/2d/2D.h
index c2730cf7af28..cbb22c94b779 100644
--- a/gfx/2d/2D.h
+++ b/gfx/2d/2D.h
@@ -34,7 +34,7 @@
 
 #include "mozilla/DebugOnly.h"
 
-#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GTK)
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 #ifndef MOZ_ENABLE_FREETYPE
 #define MOZ_ENABLE_FREETYPE
 #endif
@@ -1523,7 +1523,7 @@ class GFX2D_API Factory {
       const NativeFont &aNativeFont, const RefPtr<UnscaledFont> &aUnscaledFont,
       Float aSize);
 
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
   static already_AddRefed<ScaledFont> CreateScaledFontForFontconfigFont(
       cairo_scaled_font_t *aScaledFont, FcPattern *aPattern,
       const RefPtr<UnscaledFont> &aUnscaledFont, Float aSize);
diff --git a/gfx/2d/Factory.cpp b/gfx/2d/Factory.cpp
index 2ad3e765cf0f..b25662d0ea02 100644
--- a/gfx/2d/Factory.cpp
+++ b/gfx/2d/Factory.cpp
@@ -33,7 +33,7 @@
 #include "NativeFontResourceMac.h"
 #endif
 
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 #include "ScaledFontFontconfig.h"
 #include "NativeFontResourceFontconfig.h"
 #include "UnscaledFontFreeType.h"
@@ -600,7 +600,7 @@ already_AddRefed<ScaledFont> Factory::CreateScaledFontWithCairo(
 #endif
 }
 
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 already_AddRefed<ScaledFont> Factory::CreateScaledFontForFontconfigFont(
     cairo_scaled_font_t* aScaledFont, FcPattern* aPattern,
     const RefPtr<UnscaledFont>& aUnscaledFont, Float aSize) {
diff --git a/gfx/2d/UnscaledFontFreeType.h b/gfx/2d/UnscaledFontFreeType.h
index a74e246acc53..d294fee67d9e 100644
--- a/gfx/2d/UnscaledFontFreeType.h
+++ b/gfx/2d/UnscaledFontFreeType.h
@@ -44,7 +44,7 @@ class UnscaledFontFreeType : public UnscaledFont {
   uint32_t mIndex;
 };
 
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 class UnscaledFontFontconfig : public UnscaledFontFreeType {
  public:
   MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME(UnscaledFontFontconfig, override)
diff --git a/gfx/2d/moz.build b/gfx/2d/moz.build
index 388d242bb6c1..5105ae194f7d 100644
--- a/gfx/2d/moz.build
+++ b/gfx/2d/moz.build
@@ -101,7 +101,7 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] != 'windows':
         'JobScheduler_posix.cpp',
     ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3', 'qt'):
     EXPORTS.mozilla.gfx += [
         'UnscaledFontFreeType.h',
     ]
@@ -109,7 +109,7 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
         'UnscaledFontFreeType.cpp',
     ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     SOURCES += [
         'NativeFontResourceFontconfig.cpp',
         'ScaledFontFontconfig.cpp',
@@ -230,12 +230,12 @@ FINAL_LIBRARY = 'xul'
 for var in ('USE_CAIRO', 'MOZ2D_HAS_MOZ_CAIRO'):
     DEFINES[var] = True
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3', 'qt'):
     DEFINES['MOZ_ENABLE_FREETYPE'] = True
 
 CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3', 'qt'):
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
 
 LOCAL_INCLUDES += CONFIG['SKIA_INCLUDES']
diff --git a/gfx/cairo/cairo/src/moz.build b/gfx/cairo/cairo/src/moz.build
index 48c4a7bfa917..b6e54d263b2d 100755
--- a/gfx/cairo/cairo/src/moz.build
+++ b/gfx/cairo/cairo/src/moz.build
@@ -80,6 +80,14 @@ elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     SOURCES += [
         'cairo-ps-surface.c',
     ]
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    EXPORTS.cairo += [
+        'cairo-ps.h',
+        'cairo-qt.h',
+    ]
+    SOURCES += [
+        'cairo-qt-surface.cpp',
+    ]
 
 if CONFIG['MOZ_X11']:
     EXPORTS.cairo += [
@@ -268,6 +276,10 @@ if CONFIG['CC_TYPE'] in ('clang', 'gcc') and CONFIG['OS_TARGET'] == 'Android' an
     CFLAGS += ['-O2']
     CXXFLAGS += ['-O2']
 
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    CFLAGS += CONFIG['MOZ_QT_CFLAGS']
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
+
 if CONFIG['MOZ_X11']:
     CFLAGS += CONFIG['XCFLAGS']
 
diff --git a/gfx/gl/moz.build b/gfx/gl/moz.build
index 9ba59f96597c..2c372bec7891 100644
--- a/gfx/gl/moz.build
+++ b/gfx/gl/moz.build
@@ -17,6 +17,8 @@ elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
         gl_provider = 'EGL'
     else:
         gl_provider = 'GLX'
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    gl_provider = 'GLX'
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     gl_provider = 'EGL'
 
diff --git a/gfx/skia/generate_mozbuild.py b/gfx/skia/generate_mozbuild.py
index 2e716febfb4f..e072388c6414 100755
--- a/gfx/skia/generate_mozbuild.py
+++ b/gfx/skia/generate_mozbuild.py
@@ -148,11 +148,11 @@ if CONFIG['CC_TYPE'] in ('clang', 'clang-cl'):
         '-Wno-unused-private-field',
     ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'android'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'android', 'qt'):
     CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     CXXFLAGS += CONFIG['MOZ_PANGO_CFLAGS']
 
 if CONFIG['MOZ_ENABLE_SKIA_PDF_SFNTLY']:
@@ -452,7 +452,7 @@ def write_mozbuild(sources):
   f.write("if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('cocoa', 'uikit'):\n")
   write_sources(f, sources['mac'], 4)
 
-  f.write("if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':\n")
+  f.write("if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):\n")
   write_sources(f, sources['linux'], 4)
 
   f.write("if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':\n")
diff --git a/gfx/skia/moz.build b/gfx/skia/moz.build
index abad4e84c325..95fa53bbcc21 100755
--- a/gfx/skia/moz.build
+++ b/gfx/skia/moz.build
@@ -613,7 +613,7 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('cocoa', 'uikit'):
         'skia/src/jumper/SkJumper_generated.S',
         'skia/src/ports/SkFontHost_mac.cpp',
     ]
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     UNIFIED_SOURCES += [
         'skia/src/ports/SkDebug_stdio.cpp',
         'skia/src/ports/SkOSFile_posix.cpp',
@@ -822,11 +822,11 @@ if CONFIG['CC_TYPE'] in ('clang', 'clang-cl'):
         '-Wno-unused-private-field',
     ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'android'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'android', 'qt'):
     CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     CXXFLAGS += CONFIG['MOZ_PANGO_CFLAGS']
 
 if CONFIG['MOZ_ENABLE_SKIA_PDF_SFNTLY']:
diff --git a/gfx/src/moz.build b/gfx/src/moz.build
index 893b185529fe..bb90bcc575cd 100644
--- a/gfx/src/moz.build
+++ b/gfx/src/moz.build
@@ -93,3 +93,6 @@ CXXFLAGS += CONFIG['TK_CFLAGS']
 
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     CXXFLAGS += CONFIG['MOZ_PANGO_CFLAGS']
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/gfx/thebes/gfxASurface.cpp b/gfx/thebes/gfxASurface.cpp
index 99a88a164ec9..7ee1f808e997 100644
--- a/gfx/thebes/gfxASurface.cpp
+++ b/gfx/thebes/gfxASurface.cpp
@@ -142,6 +142,8 @@ already_AddRefed<gfxASurface> gfxASurface::Wrap(cairo_surface_t *csurf,
   /* No wrapper; figure out the surface type and create it */
   cairo_surface_type_t stype = cairo_surface_get_type(csurf);
 
+  MOZ_ASSERT(stype != CAIRO_SURFACE_TYPE_QT);
+
   if (stype == CAIRO_SURFACE_TYPE_IMAGE) {
     result = new gfxImageSurface(csurf);
   }
diff --git a/gfx/thebes/gfxFT2Fonts.cpp b/gfx/thebes/gfxFT2Fonts.cpp
index 94f360d6b682..0485d0b94c1b 100644
--- a/gfx/thebes/gfxFT2Fonts.cpp
+++ b/gfx/thebes/gfxFT2Fonts.cpp
@@ -6,6 +6,10 @@
 #if defined(MOZ_WIDGET_GTK)
 #include "gfxPlatformGtk.h"
 #define gfxToolkitPlatform gfxPlatformGtk
+#elif defined(MOZ_WIDGET_QT)
+#include <qfontinfo.h>
+#include "gfxQtPlatform.h"
+#define gfxToolkitPlatform gfxQtPlatform
 #elif defined(XP_WIN)
 #include "gfxWindowsPlatform.h"
 #define gfxToolkitPlatform gfxWindowsPlatform
diff --git a/gfx/thebes/gfxFcPlatformFontList.cpp b/gfx/thebes/gfxFcPlatformFontList.cpp
index 0e64319656c2..ca10285033c8 100644
--- a/gfx/thebes/gfxFcPlatformFontList.cpp
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp
@@ -35,6 +35,8 @@
 #ifdef MOZ_WIDGET_GTK
 #include <gdk/gdk.h>
 #include "gfxPlatformGtk.h"
+#elif MOZ_WIDGET_QT
+#include "gfxQtPlatform.h"
 #endif
 
 #ifdef MOZ_X11
@@ -2110,7 +2112,11 @@ gfxPlatformFontList::PrefFontList* gfxFcPlatformFontList::FindGenericFamilies(
 
   // -- select the fonts to be used for the generic
   prefFonts = new PrefFontList;  // can be empty but in practice won't happen
+#if defined(MOZ_WIDGET_GTK)
   uint32_t limit = gfxPlatformGtk::GetPlatform()->MaxGenericSubstitions();
+#else
+  uint32_t limit = gfxQtPlatform::GetPlatform()->MaxGenericSubstitions();
+#endif
   bool foundFontWithLang = false;
   for (int i = 0; i < faces->nfont; i++) {
     FcPattern* font = faces->fonts[i];
diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
index 8894daf58342..6d6742b60986 100644
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -62,7 +62,7 @@ class gfxMathTable;
 // we use a platform-dependent value to harmonize with the platform's own APIs.
 #ifdef XP_WIN
 #define OBLIQUE_SKEW_FACTOR 0.3f
-#elif defined(MOZ_WIDGET_GTK)
+#elif defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 #define OBLIQUE_SKEW_FACTOR 0.2f
 #else
 #define OBLIQUE_SKEW_FACTOR 0.25f
diff --git a/gfx/thebes/gfxPlatform.cpp b/gfx/thebes/gfxPlatform.cpp
index e4982686063a..bdd887be5fd4 100644
--- a/gfx/thebes/gfxPlatform.cpp
+++ b/gfx/thebes/gfxPlatform.cpp
@@ -51,6 +51,8 @@
 #include "gfxQuartzSurface.h"
 #elif defined(MOZ_WIDGET_GTK)
 #include "gfxPlatformGtk.h"
+#elif defined(MOZ_WIDGET_QT)
+#include "gfxQtPlatform.h"
 #elif defined(ANDROID)
 #include "gfxAndroidPlatform.h"
 #endif
@@ -706,6 +708,8 @@ void gfxPlatform::Init() {
   gPlatform = new gfxPlatformMac;
 #elif defined(MOZ_WIDGET_GTK)
   gPlatform = new gfxPlatformGtk;
+#elif defined(MOZ_WIDGET_QT)
+  gPlatform = new gfxQtPlatform;
 #elif defined(ANDROID)
   gPlatform = new gfxAndroidPlatform;
 #else
@@ -742,6 +746,7 @@ void gfxPlatform::Init() {
   gPlatform->ComputeTileSize();
 
   nsresult rv;
+
   rv = gfxPlatformFontList::Init();
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Could not initialize gfxPlatformFontList");
diff --git a/gfx/thebes/gfxQtNativeRenderer.cpp b/gfx/thebes/gfxQtNativeRenderer.cpp
new file mode 100644
index 000000000000..f9ee28ead37d
--- /dev/null
+++ b/gfx/thebes/gfxQtNativeRenderer.cpp
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "gfxQtNativeRenderer.h"
+#include "gfxContext.h"
+#include "gfxUtils.h"
+#include "gfxXlibSurface.h"
+
+nsresult
+gfxQtNativeRenderer::Draw(gfxContext* ctx, mozilla::gfx::IntSize size,
+                          uint32_t flags, Screen* screen, Visual* visual)
+{
+    Display *dpy = DisplayOfScreen(screen);
+    bool isOpaque = (flags & DRAW_IS_OPAQUE) ? true : false;
+    int screenNumber = screen - ScreenOfDisplay(dpy, 0);
+
+    if (!isOpaque) {
+        int depth = 32;
+        XVisualInfo vinfo;
+        int foundVisual = XMatchVisualInfo(dpy, screenNumber,
+                                           depth, TrueColor,
+                                           &vinfo);
+        if (!foundVisual)
+            return NS_ERROR_FAILURE;
+
+        visual = vinfo.visual;
+    }
+
+    RefPtr<gfxXlibSurface> xsurf =
+        gfxXlibSurface::Create(screen, visual,
+                               mozilla::gfx::IntSize(size.width, size.height));
+
+    if (!isOpaque) {
+        gfxUtils::ClearThebesSurface(xsurf);
+    }
+
+    nsresult rv = DrawWithXlib(xsurf->CairoSurface(), nsIntPoint(0, 0), nullptr, 0);
+
+    if (NS_FAILED(rv))
+        return rv;
+
+    ctx->SetSource(xsurf);
+    ctx->Paint();
+
+    return rv;
+}
diff --git a/gfx/thebes/gfxQtNativeRenderer.h b/gfx/thebes/gfxQtNativeRenderer.h
new file mode 100644
index 000000000000..23c138e11fc0
--- /dev/null
+++ b/gfx/thebes/gfxQtNativeRenderer.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef GFXQTNATIVERENDER_H_
+#define GFXQTNATIVERENDER_H_
+
+#include "gfxContext.h"
+#include "gfxXlibSurface.h"
+#include "mozilla/gfx/Rect.h"
+
+/**
+ * This class lets us take code that draws into an Xlib surface drawable and lets us
+ * use it to draw into any Thebes context. The user should subclass this class,
+ * override NativeDraw, and then call Draw(). The drawing will be subjected
+ * to all Thebes transformations, clipping etc.
+ */
+class gfxQtNativeRenderer {
+public:
+    /**
+     * Perform the native drawing.
+     * @param offsetX draw at this offset into the given drawable
+     * @param offsetY draw at this offset into the given drawable
+     * @param clipRects an array of rects; clip to the union
+     * @param numClipRects the number of rects in the array, or zero if
+     * no clipping is required
+     */
+    virtual nsresult DrawWithXlib(cairo_surface_t* surface,
+                                  nsIntPoint offset,
+                                  mozilla::gfx::IntRect* clipRects,
+                                  uint32_t numClipRects) = 0;
+
+    enum {
+        // If set, then Draw() is opaque, i.e., every pixel in the intersection
+        // of the clipRect and (offset.x,offset.y,bounds.width,bounds.height)
+        // will be set and there is no dependence on what the existing pixels
+        // in the drawable are set to.
+        DRAW_IS_OPAQUE = 0x01,
+        // If set, then numClipRects can be zero or one
+        DRAW_SUPPORTS_CLIP_RECT = 0x04,
+        // If set, then numClipRects can be any value. If neither this
+        // nor CLIP_RECT are set, then numClipRects will be zero
+        DRAW_SUPPORTS_CLIP_LIST = 0x08,
+        // If set, then the visual passed in can be any visual, otherwise the
+        // visual passed in must be the default visual for dpy's default screen
+        DRAW_SUPPORTS_ALTERNATE_VISUAL = 0x10,
+        // If set, then the Screen 'screen' in the callback can be different
+        // from the default Screen of the display passed to 'Draw' and can be
+        // on a different display.
+        DRAW_SUPPORTS_ALTERNATE_SCREEN = 0x20
+    };
+
+    /**
+     * @param flags see above
+     * @param size Draw()'s drawing is guaranteed to be restricted to
+     * the rectangle (offset.x,offset.y,size.width,size.height)
+     * @param dpy a display to use for the drawing if ctx doesn't have one
+     * @param resultSurface if non-null, we will try to capture a copy of the
+     * rendered image into a surface similar to the surface of ctx; if
+     * successful, a pointer to the new gfxASurface is stored in *resultSurface,
+     * otherwise *resultSurface is set to nullptr.
+     */
+    nsresult Draw(gfxContext* ctx, mozilla::gfx::IntSize size,
+                  uint32_t flags, Screen* screen, Visual* visual);
+};
+
+#endif /*GFXQTNATIVERENDER_H_*/
diff --git a/gfx/thebes/gfxQtPlatform.cpp b/gfx/thebes/gfxQtPlatform.cpp
new file mode 100644
index 000000000000..191fa494b903
--- /dev/null
+++ b/gfx/thebes/gfxQtPlatform.cpp
@@ -0,0 +1,185 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QPixmap>
+#include <QWindow>
+
+#include <QGuiApplication>
+#include <QScreen>
+
+#include "gfxQtPlatform.h"
+
+#include "mozilla/gfx/2D.h"
+
+#include "cairo.h"
+
+#include "gfxImageSurface.h"
+#include "nsUnicodeProperties.h"
+#include "gfxFcPlatformFontList.h"
+
+#include "gfxContext.h"
+#include "gfxUserFontSet.h"
+#include <gfxTextRun.h>
+
+#include "nsUnicharUtils.h"
+
+#include "nsMathUtils.h"
+#include "nsTArray.h"
+
+#include "qcms.h"
+
+#include "mozilla/Preferences.h"
+
+using namespace mozilla;
+using namespace mozilla::unicode;
+using namespace mozilla::gfx;
+
+static gfxImageFormat sOffscreenFormat = SurfaceFormat::X8R8G8B8_UINT32;
+
+#define GFX_PREF_MAX_GENERIC_SUBSTITUTIONS \
+  "gfx.font_rendering.fontconfig.max_generic_substitutions"
+
+gfxQtPlatform::gfxQtPlatform()
+{
+    mMaxGenericSubstitutions = UNINITIALIZED_VALUE;
+
+    int32_t depth = GetScreenDepth();
+    if (depth == 16) {
+        sOffscreenFormat = SurfaceFormat::R5G6B5_UINT16;
+    }
+    uint32_t canvasMask = BackendTypeBit(BackendType::CAIRO) | BackendTypeBit(BackendType::SKIA);
+    uint32_t contentMask = BackendTypeBit(BackendType::CAIRO) | BackendTypeBit(BackendType::SKIA);
+    InitBackendPrefs(canvasMask, BackendType::CAIRO,
+                     contentMask, BackendType::CAIRO);
+}
+
+gfxQtPlatform::~gfxQtPlatform()
+{
+}
+
+already_AddRefed<gfxASurface>
+gfxQtPlatform::CreateOffscreenSurface(const IntSize& aSize,
+                                      gfxImageFormat aFormat)
+{
+    RefPtr<gfxASurface> newSurface =
+        new gfxImageSurface(aSize, aFormat);
+
+    return newSurface.forget();
+}
+
+nsresult
+gfxQtPlatform::GetFontList(nsAtom *aLangGroup,
+                           const nsACString& aGenericFamily,
+                           nsTArray<nsString>& aListOfFonts)
+{
+    gfxPlatformFontList::PlatformFontList()->GetFontList(
+        aLangGroup, aGenericFamily, aListOfFonts);
+    return NS_OK;
+}
+
+nsresult
+gfxQtPlatform::UpdateFontList()
+{
+    gfxPlatformFontList::PlatformFontList()->UpdateFontList();
+    return NS_OK;
+}
+
+gfxPlatformFontList *gfxQtPlatform::CreatePlatformFontList()
+{
+  gfxPlatformFontList* list = new gfxFcPlatformFontList();
+  if (NS_SUCCEEDED(list->InitFontList())) {
+    return list;
+  }
+  gfxPlatformFontList::Shutdown();
+  return nullptr;
+}
+
+nsresult
+gfxQtPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
+{
+    gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName,
+                                                                   aFamilyName);
+    return NS_OK;
+}
+
+gfxFontGroup *
+gfxQtPlatform::CreateFontGroup(const FontFamilyList& aFontFamilyList,
+                               const gfxFontStyle *aStyle,
+                               gfxTextPerfMetrics* aTextPerf,
+                               gfxUserFontSet* aUserFontSet,
+                               gfxFloat aDevToCssSize)
+{
+    return new gfxFontGroup(aFontFamilyList, aStyle, aTextPerf, aUserFontSet,
+                            aDevToCssSize);
+}
+
+gfxFontEntry*
+gfxQtPlatform::LookupLocalFont(const nsAString& aFontName,
+                               uint16_t aWeight,
+                               int16_t aStretch,
+                               uint8_t aStyle)
+{
+    gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
+    return pfl->LookupLocalFont(aFontName, aWeight, aStretch, aStyle);
+}
+
+gfxFontEntry*
+gfxQtPlatform::MakePlatformFont(const nsAString& aFontName,
+                                uint16_t aWeight,
+                                int16_t aStretch,
+                                uint8_t aStyle,
+                                const uint8_t* aFontData,
+                                uint32_t aLength)
+{
+    gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
+    return pfl->MakePlatformFont(aFontName, aWeight, aStretch, aStyle, aFontData,
+                                 aLength);
+}
+
+void
+gfxQtPlatform::GetPlatformCMSOutputProfile(void *&mem, size_t &size)
+{
+    mem = nullptr;
+    size = 0;
+}
+
+int32_t
+gfxQtPlatform::GetDPI()
+{
+    return qApp->primaryScreen()->logicalDotsPerInch();
+}
+
+gfxImageFormat
+gfxQtPlatform::GetOffscreenFormat()
+{
+    return sOffscreenFormat;
+}
+
+void gfxQtPlatform::FontsPrefsChanged(const char *aPref)
+{
+    // only checking for generic substitions, pass other changes up
+    if (strcmp(GFX_PREF_MAX_GENERIC_SUBSTITUTIONS, aPref)) {
+      gfxPlatform::FontsPrefsChanged(aPref);
+      return;
+    }
+
+    mMaxGenericSubstitutions = UNINITIALIZED_VALUE;
+    gfxFcPlatformFontList* pfl = gfxFcPlatformFontList::PlatformFontList();
+    pfl->ClearGenericMappings();
+    FlushFontAndWordCaches();
+}
+
+uint32_t gfxQtPlatform::MaxGenericSubstitions()
+{
+    if (mMaxGenericSubstitutions == UNINITIALIZED_VALUE) {
+      mMaxGenericSubstitutions =
+          Preferences::GetInt(GFX_PREF_MAX_GENERIC_SUBSTITUTIONS, 3);
+      if (mMaxGenericSubstitutions < 0) {
+        mMaxGenericSubstitutions = 3;
+      }
+    }
+
+    return uint32_t(mMaxGenericSubstitutions);
+}
diff --git a/gfx/thebes/gfxQtPlatform.h b/gfx/thebes/gfxQtPlatform.h
new file mode 100644
index 000000000000..928e9a33e123
--- /dev/null
+++ b/gfx/thebes/gfxQtPlatform.h
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef GFX_PLATFORM_QT_H
+#define GFX_PLATFORM_QT_H
+
+#include "gfxPlatform.h"
+#include "nsAutoRef.h"
+#include "nsDataHashtable.h"
+#include "nsTArray.h"
+#ifdef MOZ_X11
+#include "X11/Xlib.h"
+#endif
+
+class QWindow;
+
+class gfxQtPlatform : public gfxPlatform {
+public:
+    gfxQtPlatform();
+    virtual ~gfxQtPlatform();
+
+    static gfxQtPlatform *GetPlatform() {
+        return static_cast<gfxQtPlatform*>(gfxPlatform::GetPlatform());
+    }
+
+    virtual already_AddRefed<gfxASurface>
+      CreateOffscreenSurface(const IntSize& aSize,
+                             gfxImageFormat aFormat) override;
+
+    virtual nsresult GetFontList(nsAtom *aLangGroup,
+                                 const nsACString& aGenericFamily,
+                                 nsTArray<nsString>& aListOfFonts) override;
+
+    virtual nsresult UpdateFontList() override;
+
+    virtual gfxPlatformFontList* CreatePlatformFontList() override;
+
+    virtual nsresult GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName) override;
+
+    gfxFontGroup*
+    CreateFontGroup(const mozilla::FontFamilyList& aFontFamilyList,
+                    const gfxFontStyle *aStyle,
+                    gfxTextPerfMetrics* aTextPerf,
+                    gfxUserFontSet *aUserFontSet,
+                    gfxFloat aDevToCssSize) override;
+
+    /**
+     * Look up a local platform font using the full font face name (needed to
+     * support @font-face src local() )
+     */
+    virtual gfxFontEntry* LookupLocalFont(const nsAString& aFontName,
+                                          uint16_t aWeight,
+                                          int16_t aStretch,
+                                          uint8_t aStyle) override;
+
+    /**
+     * Activate a platform font (needed to support @font-face src url() )
+     *
+     */
+    virtual gfxFontEntry* MakePlatformFont(const nsAString& aFontName,
+                                           uint16_t aWeight,
+                                           int16_t aStretch,
+                                           uint8_t aStyle,
+                                           const uint8_t* aFontData,
+                                           uint32_t aLength) override;
+
+    static int32_t GetDPI();
+
+    virtual gfxImageFormat GetOffscreenFormat() override;
+
+    bool AccelerateLayersByDefault() override {
+      return true;
+    }
+
+    void FontsPrefsChanged(const char* aPref) override;
+
+    uint32_t MaxGenericSubstitions();
+
+protected:
+    int8_t mMaxGenericSubstitutions;
+
+private:
+    virtual void GetPlatformCMSOutputProfile(void *&mem, size_t &size) override;
+
+    int mScreenDepth;
+};
+
+#endif /* GFX_PLATFORM_QT_H */
+
diff --git a/gfx/thebes/moz.build b/gfx/thebes/moz.build
index 3eaeeedb58f4..b4a48a231258 100644
--- a/gfx/thebes/moz.build
+++ b/gfx/thebes/moz.build
@@ -129,6 +129,32 @@ elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
             'gfxXlibSurface.cpp',
         ]
 
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    EXPORTS += [
+        'gfxFT2FontBase.h',
+        'gfxQtNativeRenderer.h',
+        'gfxQtPlatform.h',
+    ]
+    EXPORTS.mozilla.gfx += [
+        'PrintTargetPDF.h',
+    ]
+    SOURCES += [
+        'gfxFcPlatformFontList.cpp',
+        'gfxFT2FontBase.cpp',
+        'gfxFT2Utils.cpp',
+        'gfxQtPlatform.cpp',
+        'PrintTargetPDF.cpp',
+    ]
+
+    if CONFIG['MOZ_X11']:
+        EXPORTS += [
+            'gfxXlibSurface.h',
+        ]
+        SOURCES += [
+            'gfxQtNativeRenderer.cpp',
+            'gfxXlibSurface.cpp',
+        ]
+
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':
     EXPORTS += [
         'gfxDWriteFonts.h',
@@ -251,7 +277,7 @@ LOCAL_INCLUDES += [
     '/dom/xml',
 ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3', 'qt'):
     DEFINES['MOZ_ENABLE_FREETYPE'] = True
 
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':
@@ -267,7 +293,7 @@ CFLAGS += CONFIG['TK_CFLAGS']
 if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android'):
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     CXXFLAGS += CONFIG['MOZ_PANGO_CFLAGS']
 
 LOCAL_INCLUDES += CONFIG['SKIA_INCLUDES']
diff --git a/gfx/webrender_bindings/Moz2DImageRenderer.cpp b/gfx/webrender_bindings/Moz2DImageRenderer.cpp
index 672a71966b3c..e9dd73865cbf 100644
--- a/gfx/webrender_bindings/Moz2DImageRenderer.cpp
+++ b/gfx/webrender_bindings/Moz2DImageRenderer.cpp
@@ -95,7 +95,7 @@ void AddNativeFontHandle(WrFontKey aKey, void *aHandle, uint32_t aIndex) {
 #elif defined(XP_WIN)
     font.mUnscaledFont = new UnscaledFontDWrite(
         reinterpret_cast<IDWriteFontFace *>(aHandle), nullptr);
-#elif defined(ANDROID)
+#elif defined(ANDROID) || defined(MOZ_WIDGET_QT)
     font.mUnscaledFont = new UnscaledFontFreeType(
         reinterpret_cast<const char *>(aHandle), aIndex);
 #else
@@ -136,7 +136,7 @@ RefPtr<UnscaledFont> GetUnscaledFont(Translator *aTranslator, wr::FontKey key) {
       FontType::MAC;
 #elif defined(XP_WIN)
       FontType::DWRITE;
-#elif defined(ANDROID)
+#elif defined(ANDROID) || defined(MOZ_WIDGET_QT)
       FontType::FREETYPE;
 #else
       FontType::FONTCONFIG;
diff --git a/gfx/webrender_bindings/moz.build b/gfx/webrender_bindings/moz.build
index 3e652b862d93..132678df81e5 100644
--- a/gfx/webrender_bindings/moz.build
+++ b/gfx/webrender_bindings/moz.build
@@ -55,7 +55,7 @@ if CONFIG['MOZ_ENABLE_D3D10_LAYER']:
         'RenderD3D11TextureHostOGL.cpp',
     ]
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3'):
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('android', 'gtk3', 'qt'):
     CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
     CXXFLAGS += CONFIG['CAIRO_FT_CFLAGS']
 
diff --git a/image/decoders/icon/moz.build b/image/decoders/icon/moz.build
index 9c6106fa7db6..c3bfa2050383 100644
--- a/image/decoders/icon/moz.build
+++ b/image/decoders/icon/moz.build
@@ -19,6 +19,9 @@ platform = None
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     platform = 'gtk'
 
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    platform = 'qt'
+
 if CONFIG['OS_ARCH'] == 'WINNT':
     platform = 'win'
 
diff --git a/image/decoders/icon/qt/gtkqticonsconverter.js b/image/decoders/icon/qt/gtkqticonsconverter.js
new file mode 100644
index 000000000000..23afe8af77c8
--- /dev/null
+++ b/image/decoders/icon/qt/gtkqticonsconverter.js
@@ -0,0 +1,145 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+
+function GtkQtIconsConverter()
+{ };
+
+#ifdef 0
+#endif
+
+GtkQtIconsConverter.prototype =
+{
+  classID:          Components.ID("{c0783c34-a831-40c6-8c03-98c9f74cca45}"),
+  QueryInterface: XPCOMUtils.generateQI(
+                                [Components.interfaces.nsIGtkQtIconsConverter]),
+  convert: function(icon) { return this._gtk_qt_icons_table[icon]; },
+  _gtk_qt_icons_table:
+  {
+    'about':
+    0,
+    'add':
+    0,
+    'apply':
+    44, // QStyle::SP_DialogApplyButton
+    'cancel':
+    39, // QStyle::SP_DialogCancelButton
+    'clear':
+    45, // QStyle::SP_DialogResetButton
+    'color-picker':
+    0,
+    'copy':
+    0,
+    'close':
+    43, // QStyle::SP_DialogCloseButton
+    'cut':
+    0,
+    'delete':
+    0,
+    'dialog-error':
+    0,
+    'dialog-info':
+    0,
+    'dialog-question':
+    12, // QStyle::SP_MessageBoxQuestion
+    'dialog-warning':
+    10, // QStyle::SP_MessageBoxWarning
+    'directory':
+    37, // QStyle::SP_DirIcon
+    'file':
+    24, // QStyle::SP_FileIcon
+    'find':
+    0,
+    'go-back-ltr':
+    53, // QStyle::SP_ArrowBack
+    'go-back-rtl':
+    53, // QStyle::SP_ArrowBack
+    'go-back':
+    53, // QStyle::SP_ArrowBack
+    'go-forward-ltr':
+    54, // QStyle::SP_ArrowForward
+    'go-forward-rtl':
+    54, // QStyle::SP_ArrowForward
+    'go-forward':
+    54, // QStyle::SP_ArrowForward
+    'go-up':
+    49, // QStyle::SP_ArrowUp
+    'goto-first':
+    0,
+    'goto-last':
+    0,
+    'help':
+    7, // QStyle::SP_TitleBarContextHelpButton
+    'home':
+    55, // QStyle::SP_DirHomeIcon
+    'info':
+    9, // QStyle::SP_MessageBoxInformation
+    'jump-to':
+    0,
+    'media-pause':
+    0,
+    'media-play':
+    0,
+    'network':
+    20, // QStyle::SP_DriveNetIcon
+    'no':
+    48, // QStyle::SP_DialogNoButton
+    'ok':
+    38, // QStyle::SP_DialogOkButton
+    'open':
+    21, // QStyle::SP_DirOpenIcon
+    'orientation-landscape':
+    0,
+    'orientation-portrait':
+    0,
+    'paste':
+    0,
+    'preferences':
+    34, // QStyle::SP_FileDialogContentsView
+    'print-preview':
+    0,
+    'print':
+    0,
+    'properties':
+    0,
+    'quit':
+    0,
+    'redo':
+    0,
+    'refresh':
+    58, // QStyle::SP_BrowserReload
+    'remove':
+    0,
+    'revert-to-saved':
+    0,
+    'save-as':
+    42, // QStyle::SP_DialogSaveButton
+    'save':
+    42, // QStyle::SP_DialogSaveButton
+    'select-all':
+    0,
+    'select-font':
+    0,
+    'stop':
+    59, // QStyle::SP_BrowserStop
+    'undelete':
+    0,
+    'undo':
+    0,
+    'yes':
+    47, // QStyle::SP_DialogYesButton
+    'zoom-100':
+    0,
+    'zoom-in':
+    0,
+    'zoom-out':
+    0
+  },
+}
+var components = [GtkQtIconsConverter];
+this.NSGetFactory = XPCOMUtils.generateNSGetFactory(components);
+
diff --git a/image/decoders/icon/qt/gtkqticonsconverter.manifest b/image/decoders/icon/qt/gtkqticonsconverter.manifest
new file mode 100644
index 000000000000..4d6ede281431
--- /dev/null
+++ b/image/decoders/icon/qt/gtkqticonsconverter.manifest
@@ -0,0 +1,2 @@
+component {c0783c34-a831-40c6-8c03-98c9f74cca45} gtkqticonsconverter.js
+contract @mozilla.org/gtkqticonsconverter;1 {c0783c34-a831-40c6-8c03-98c9f74cca45}
diff --git a/image/decoders/icon/qt/moz.build b/image/decoders/icon/qt/moz.build
new file mode 100644
index 000000000000..0cf20fdb6d40
--- /dev/null
+++ b/image/decoders/icon/qt/moz.build
@@ -0,0 +1,27 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+XPIDL_SOURCES += [
+    'nsGtkQtIconsConverter.idl',
+]
+
+XPIDL_MODULE = 'gtkqticonsconverter'
+
+SOURCES += [
+    'nsIconChannel.cpp',
+]
+
+EXTRA_COMPONENTS += [
+    'gtkqticonsconverter.manifest',
+]
+
+EXTRA_PP_COMPONENTS += [
+    'gtkqticonsconverter.js',
+]
+
+FINAL_LIBRARY = 'xul'
+
+CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/image/decoders/icon/qt/nsGtkQtIconsConverter.idl b/image/decoders/icon/qt/nsGtkQtIconsConverter.idl
new file mode 100644
index 000000000000..958ae3394f69
--- /dev/null
+++ b/image/decoders/icon/qt/nsGtkQtIconsConverter.idl
@@ -0,0 +1,12 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+[scriptable, uuid(c0783c34-a831-40c6-8c03-98c9f74cca45)]
+interface nsIGtkQtIconsConverter : nsISupports
+{
+  long convert(in string icon);
+};
diff --git a/image/decoders/icon/qt/nsIconChannel.cpp b/image/decoders/icon/qt/nsIconChannel.cpp
new file mode 100644
index 000000000000..eb29ef15797d
--- /dev/null
+++ b/image/decoders/icon/qt/nsIconChannel.cpp
@@ -0,0 +1,134 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QIcon>
+
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "mozilla/EndianUtils.h"
+
+#include "nsMimeTypes.h"
+#include "nsIMIMEService.h"
+
+#include "nsIStringStream.h"
+#include "nsIStringBundle.h"
+
+#include "nsNetUtil.h"
+#include "NullPrincipal.h"
+#include "nsIURL.h"
+
+#include "nsIconChannel.h"
+#include "nsGtkQtIconsConverter.h"
+
+NS_IMPL_ISUPPORTS(nsIconChannel,
+                  nsIRequest,
+                  nsIChannel)
+
+static nsresult
+moz_qicon_to_channel(QImage* image, nsIURI* aURI,
+                     nsIChannel** aChannel)
+{
+  NS_ENSURE_ARG_POINTER(image);
+
+  int width = image->width();
+  int height = image->height();
+
+  NS_ENSURE_TRUE(height < 256 && width < 256 && height > 0 && width > 0,
+                 NS_ERROR_UNEXPECTED);
+
+  const int n_channels = 4;
+  long int buf_size = 2 + n_channels * height * width;
+  uint8_t* const buf = (uint8_t*)moz_xmalloc(buf_size);
+  NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
+  uint8_t* out = buf;
+
+  *(out++) = width;
+  *(out++) = height;
+
+  const uchar* const pixels = image->bits();
+  int rowextra = image->bytesPerLine() - width * n_channels;
+
+  // encode the RGB data and the A data
+  const uchar* in = pixels;
+  for (int y = 0; y < height; ++y, in += rowextra) {
+    for (int x = 0; x < width; ++x) {
+      uint8_t r = *(in++);
+      uint8_t g = *(in++);
+      uint8_t b = *(in++);
+      uint8_t a = *(in++);
+#define DO_PREMULTIPLY(c_) uint8_t(uint16_t(c_) * uint16_t(a) / uint16_t(255))
+#if MOZ_LITTLE_ENDIAN
+      *(out++) = DO_PREMULTIPLY(b);
+      *(out++) = DO_PREMULTIPLY(g);
+      *(out++) = DO_PREMULTIPLY(r);
+      *(out++) = a;
+#else
+      *(out++) = a;
+      *(out++) = DO_PREMULTIPLY(r);
+      *(out++) = DO_PREMULTIPLY(g);
+      *(out++) = DO_PREMULTIPLY(b);
+#endif
+#undef DO_PREMULTIPLY
+    }
+  }
+
+  NS_ASSERTION(out == buf + buf_size, "size miscalculation");
+
+  nsresult rv;
+  nsCOMPtr<nsIStringInputStream> stream =
+    do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stream->AdoptData((char*)buf, buf_size);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // nsIconProtocolHandler::NewChannel2 will provide the correct loadInfo for
+  // this iconChannel. Use the most restrictive security settings for the
+  // temporary loadInfo to make sure the channel can not be openend.
+  nsCOMPtr<nsIPrincipal> nullPrincipal = NullPrincipal::Create();
+  return NS_NewInputStreamChannel(aChannel,
+                                  aURI,
+                                  stream.forget(),
+                                  nullPrincipal,
+                                  nsILoadInfo::SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED,
+                                  nsIContentPolicy::TYPE_INTERNAL_IMAGE,
+                                  NS_LITERAL_CSTRING(IMAGE_ICON_MS));
+}
+
+nsresult
+nsIconChannel::Init(nsIURI* aURI)
+{
+
+  nsCOMPtr<nsIMozIconURI> iconURI = do_QueryInterface(aURI);
+  NS_ASSERTION(iconURI, "URI is not an nsIMozIconURI");
+
+  nsAutoCString stockIcon;
+  iconURI->GetStockIcon(stockIcon);
+
+  nsAutoCString iconSizeString;
+  iconURI->GetIconSize(iconSizeString);
+
+  uint32_t desiredImageSize;
+  iconURI->GetImageSize(&desiredImageSize);
+
+  nsAutoCString iconStateString;
+  iconURI->GetIconState(iconStateString);
+  bool disabled = iconStateString.EqualsLiteral("disabled");
+
+  // This is a workaround for
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=662299
+  // Try to find corresponding freedesktop icon and fallback to empty QIcon
+  // if failed.
+  QIcon icon = QIcon::fromTheme(QString(stockIcon.get()).replace("gtk-",
+                                                                 "edit-"));
+  QPixmap pixmap = icon.pixmap(desiredImageSize, desiredImageSize,
+                               disabled ? QIcon::Disabled : QIcon::Normal);
+
+  QImage image = pixmap.toImage();
+
+  return moz_qicon_to_channel(&image, iconURI,
+                              getter_AddRefs(mRealChannel));
+}
diff --git a/image/decoders/icon/qt/nsIconChannel.h b/image/decoders/icon/qt/nsIconChannel.h
new file mode 100644
index 000000000000..059891a71fae
--- /dev/null
+++ b/image/decoders/icon/qt/nsIconChannel.h
@@ -0,0 +1,40 @@
+/* vim:set ts=2 sw=2 sts=2 cin et: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_image_encoders_icon_qt_nsIconChannel_h
+#define mozilla_image_encoders_icon_qt_nsIconChannel_h
+
+#include "mozilla/Attributes.h"
+
+#include "nsIChannel.h"
+#include "nsIStreamListener.h"
+#include "nsIURI.h"
+#include "nsIIconURI.h"
+#include "nsCOMPtr.h"
+
+/// This class is the gnome implementation of nsIconChannel. It basically asks
+/// qt for an icon, and creates a new channel for
+/// that file to which all calls will be proxied.
+class nsIconChannel final : public nsIChannel {
+  public:
+    NS_DECL_ISUPPORTS
+    NS_FORWARD_NSIREQUEST(mRealChannel->)
+    NS_FORWARD_NSICHANNEL(mRealChannel->)
+
+    nsIconChannel() { };
+
+    /// Called by nsIconProtocolHandler after it creates this channel.
+    /// Must be called before calling any other function on this object.
+    /// If this method fails, no other function must be called on this object.
+    nsresult Init(nsIURI* aURI);
+  private:
+    ~nsIconChannel() { };
+
+    /// The channel to the temp icon file (e.g. to /tmp/2qy9wjqw.html).
+    /// Will always be non-null after a successful Init.
+    nsCOMPtr<nsIChannel> mRealChannel;
+};
+
+#endif // mozilla_image_encoders_icon_qt_nsIconChannel_h
diff --git a/image/decoders/moz.build b/image/decoders/moz.build
index 851b4956fbd4..a400fd1386b8 100644
--- a/image/decoders/moz.build
+++ b/image/decoders/moz.build
@@ -10,6 +10,8 @@ toolkit = CONFIG['MOZ_WIDGET_TOOLKIT']
 # fix that another time.
 if 'gtk' in toolkit:
     DIRS += ['icon/gtk', 'icon']
+elif toolkit == 'qt':
+    DIRS += ['icon/qt', 'icon']
 
 if CONFIG['OS_ARCH'] == 'WINNT':
     DIRS += ['icon/win', 'icon']
diff --git a/intl/locale/moz.build b/intl/locale/moz.build
index e4544fa80e8f..87afd03bafb9 100644
--- a/intl/locale/moz.build
+++ b/intl/locale/moz.build
@@ -14,6 +14,8 @@ elif toolkit == 'cocoa':
     DIRS += ['mac']
 elif 'gtk' in toolkit:
     DIRS += ['gtk']
+elif 'qt' in toolkit:
+    DIRS += ['gtk']
 elif toolkit == 'android':
     DIRS += ['android']
 
@@ -78,3 +80,6 @@ for prefix in prefixes:
 
 if CONFIG['ENABLE_TESTS']:
     DIRS += ['tests/gtest']
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/ipc/chromium/moz.build b/ipc/chromium/moz.build
index 7888251982e8..516deeec0d48 100644
--- a/ipc/chromium/moz.build
+++ b/ipc/chromium/moz.build
@@ -125,6 +125,11 @@ if os_bsd or os_linux:
         SOURCES += [
             'src/base/message_pump_glib.cc',
         ]
+    if CONFIG['MOZ_ENABLE_QT']:
+        SOURCES += [
+            '!moc_message_pump_qt.cc',
+            'src/base/message_pump_qt.cc',
+        ]
 
 if os_solaris:
     SOURCES += [
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
index afe67f005bf4..180a360f26ba 100644
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2085,12 +2085,17 @@ gfxUserFontSet* nsPresContext::GetUserFontSet(bool aFlushUserFontSet) {
 void nsPresContext::UserFontSetUpdated(gfxUserFontEntry* aUpdatedFont) {
   if (!mShell) return;
 
+  bool usePlatformFontList = true;
+#if defined(MOZ_WIDGET_QT)
+  usePlatformFontList = false;
+#endif
+
   // Note: this method is called without a font when rules in the userfont set
   // are updated, which may occur during reflow as a result of the lazy
   // initialization of the userfont set. It would be better to avoid a full
   // restyle but until this method is only called outside of reflow, schedule a
   // full restyle in these cases.
-  if (!aUpdatedFont) {
+  if (!usePlatformFontList || !aUpdatedFont) {
     PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW,
                                  eRestyle_ForceDescendants);
     return;
diff --git a/layout/generic/moz.build b/layout/generic/moz.build
index c277ca131e81..4f410062f05c 100644
--- a/layout/generic/moz.build
+++ b/layout/generic/moz.build
@@ -226,3 +226,6 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
 
 if CONFIG['CC_TYPE'] in ('clang', 'gcc'):
     CXXFLAGS += ['-Wno-error=shadow']
+
+if CONFIG['MOZ_ENABLE_QT']:
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/netwerk/base/moz.build b/netwerk/base/moz.build
index 20bd77c140dc..3fa53da9b0b5 100644
--- a/netwerk/base/moz.build
+++ b/netwerk/base/moz.build
@@ -313,3 +313,11 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
 
 if CONFIG['CC_TYPE'] in ('clang', 'gcc'):
     CXXFLAGS += ['-Wno-error=shadow']
+
+if CONFIG['MOZ_ENABLE_QTNETWORK']:
+    LOCAL_INCLUDES += [
+        '/netwerk/system/qt',
+    ]
+
+if CONFIG['MOZ_ENABLE_QTNETWORK']:
+    CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/netwerk/build/moz.build b/netwerk/build/moz.build
index 215348159747..f7b20a73b8fb 100644
--- a/netwerk/build/moz.build
+++ b/netwerk/build/moz.build
@@ -50,6 +50,11 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
         '/netwerk/system/mac',
     ]
 
+if CONFIG['MOZ_ENABLE_QTNETWORK']:
+    LOCAL_INCLUDES += [
+        '/netwerk/system/qt',
+    ]
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     LOCAL_INCLUDES += [
         '/netwerk/system/android',
diff --git a/netwerk/build/nsNetModule.cpp b/netwerk/build/nsNetModule.cpp
index ef080f151533..44cf75dc037b 100644
--- a/netwerk/build/nsNetModule.cpp
+++ b/netwerk/build/nsNetModule.cpp
@@ -382,6 +382,9 @@ NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsNotifyAddrListener, Init)
 #elif defined(MOZ_WIDGET_COCOA)
 #include "nsNetworkLinkService.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsNetworkLinkService, Init)
+#elif defined(MOZ_ENABLE_QTNETWORK)
+#include "nsQtNetworkLinkService.h"
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsQtNetworkLinkService, Init)
 #elif defined(MOZ_WIDGET_ANDROID)
 #include "nsAndroidNetworkLinkService.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsAndroidNetworkLinkService)
@@ -755,6 +758,8 @@ NS_DEFINE_NAMED_CID(NS_WEBSOCKETSSLPROTOCOLHANDLER_CID);
 NS_DEFINE_NAMED_CID(NS_NETWORK_LINK_SERVICE_CID);
 #elif defined(MOZ_WIDGET_COCOA)
 NS_DEFINE_NAMED_CID(NS_NETWORK_LINK_SERVICE_CID);
+#elif defined(MOZ_ENABLE_QTNETWORK)
+NS_DEFINE_NAMED_CID(NS_NETWORK_LINK_SERVICE_CID);
 #elif defined(MOZ_WIDGET_ANDROID)
 NS_DEFINE_NAMED_CID(NS_NETWORK_LINK_SERVICE_CID);
 #elif defined(XP_LINUX)
@@ -880,6 +885,8 @@ static const mozilla::Module::CIDEntry kNeckoCIDs[] = {
     { &kNS_NETWORK_LINK_SERVICE_CID, false, nullptr, nsNotifyAddrListenerConstructor },
 #elif defined(MOZ_WIDGET_COCOA)
     { &kNS_NETWORK_LINK_SERVICE_CID, false, nullptr, nsNetworkLinkServiceConstructor },
+#elif defined(MOZ_ENABLE_QTNETWORK)
+    { &kNS_NETWORK_LINK_SERVICE_CID, false, nullptr, nsQtNetworkLinkServiceConstructor },
 #elif defined(MOZ_WIDGET_ANDROID)
     { &kNS_NETWORK_LINK_SERVICE_CID, false, nullptr, nsAndroidNetworkLinkServiceConstructor },
 #elif defined(XP_LINUX)
@@ -1010,6 +1017,8 @@ static const mozilla::Module::ContractIDEntry kNeckoContracts[] = {
     { NS_NETWORK_LINK_SERVICE_CONTRACTID, &kNS_NETWORK_LINK_SERVICE_CID },
 #elif defined(MOZ_WIDGET_COCOA)
     { NS_NETWORK_LINK_SERVICE_CONTRACTID, &kNS_NETWORK_LINK_SERVICE_CID },
+#elif defined(MOZ_ENABLE_QTNETWORK)
+    { NS_NETWORK_LINK_SERVICE_CONTRACTID, &kNS_NETWORK_LINK_SERVICE_CID },
 #elif defined(MOZ_WIDGET_ANDROID)
     { NS_NETWORK_LINK_SERVICE_CONTRACTID, &kNS_NETWORK_LINK_SERVICE_CID },
 #elif defined(XP_LINUX)
diff --git a/netwerk/protocol/moz.build b/netwerk/protocol/moz.build
index c73d7bb95880..e4c7b57fd8fb 100644
--- a/netwerk/protocol/moz.build
+++ b/netwerk/protocol/moz.build
@@ -5,6 +5,6 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DIRS += ['about', 'data', 'file', 'ftp']
-if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk', 'qt'):
     DIRS += ['gio']
 DIRS += ['http', 'res', 'viewsource', 'websocket', 'wyciwyg']
diff --git a/netwerk/system/moz.build b/netwerk/system/moz.build
index 08c41342bdb1..4117996b559e 100644
--- a/netwerk/system/moz.build
+++ b/netwerk/system/moz.build
@@ -10,6 +10,9 @@ if CONFIG['OS_ARCH'] == 'WINNT':
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
     DIRS += ['mac']
 
+if CONFIG['MOZ_ENABLE_QTNETWORK']:
+    DIRS += ['qt']
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
     DIRS += ['android']
 
diff --git a/netwerk/system/qt/moz.build b/netwerk/system/qt/moz.build
new file mode 100644
index 000000000000..cc8b5ef5fbc7
--- /dev/null
+++ b/netwerk/system/qt/moz.build
@@ -0,0 +1,18 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+SOURCES += [
+    '!moc_nsQtNetworkManager.cpp',
+    'nsQtNetworkLinkService.cpp',
+    'nsQtNetworkManager.cpp',
+]
+
+FINAL_LIBRARY = 'xul'
+LOCAL_INCLUDES += [
+    '/netwerk/base',
+]
+
+CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
diff --git a/netwerk/system/qt/nsQtNetworkLinkService.cpp b/netwerk/system/qt/nsQtNetworkLinkService.cpp
new file mode 100644
index 000000000000..f08aabbd8ed6
--- /dev/null
+++ b/netwerk/system/qt/nsQtNetworkLinkService.cpp
@@ -0,0 +1,98 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsQtNetworkManager.h"
+#include "nsQtNetworkLinkService.h"
+#include "nsCOMPtr.h"
+#include "nsIObserverService.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "mozilla/Services.h"
+#include "nsCRT.h"
+
+NS_IMPL_ISUPPORTS(nsQtNetworkLinkService,
+                  nsINetworkLinkService,
+                  nsIObserver)
+
+nsQtNetworkLinkService::nsQtNetworkLinkService()
+{
+}
+
+nsQtNetworkLinkService::~nsQtNetworkLinkService()
+{
+}
+
+NS_IMETHODIMP
+nsQtNetworkLinkService::GetIsLinkUp(bool* aIsUp)
+{
+  *aIsUp = nsQtNetworkManager::get()->isOnline();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsQtNetworkLinkService::GetLinkStatusKnown(bool* aIsKnown)
+{
+  *aIsKnown = nsQtNetworkManager::get()->isOnline();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsQtNetworkLinkService::GetLinkType(uint32_t *aLinkType)
+{
+  NS_ENSURE_ARG_POINTER(aLinkType);
+
+  // XXX This function has not yet been implemented for this platform
+  *aLinkType = nsINetworkLinkService::LINK_TYPE_UNKNOWN;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsQtNetworkLinkService::Observe(nsISupports* aSubject,
+                                const char* aTopic,
+                                const char16_t* aData)
+{
+  if (!strcmp(aTopic, "xpcom-shutdown")) {
+    Shutdown();
+    nsQtNetworkManager::get()->destroy();
+  }
+
+  if (!strcmp(aTopic, "browser-lastwindow-close-granted")) {
+    Shutdown();
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsQtNetworkLinkService::Init(void)
+{
+  nsCOMPtr<nsIObserverService> observerService =
+    mozilla::services::GetObserverService();
+  if (!observerService) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsQtNetworkManager::create();
+  nsresult rv;
+
+  rv = observerService->AddObserver(this, "xpcom-shutdown", false);
+  if (NS_FAILED(rv)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  rv = observerService->AddObserver(this, "browser-lastwindow-close-granted", false);
+  if (NS_FAILED(rv)) {
+    return NS_ERROR_FAILURE;
+  }
+
+
+  return NS_OK;
+}
+
+nsresult
+nsQtNetworkLinkService::Shutdown()
+{
+  nsQtNetworkManager::get()->closeSession();
+  return NS_OK;
+}
diff --git a/netwerk/system/qt/nsQtNetworkLinkService.h b/netwerk/system/qt/nsQtNetworkLinkService.h
new file mode 100644
index 000000000000..681d49e39bfb
--- /dev/null
+++ b/netwerk/system/qt/nsQtNetworkLinkService.h
@@ -0,0 +1,29 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef NSQTNETWORKLINKSERVICE_H_
+#define NSQTNETWORKLINKSERVICE_H_
+
+#include "nsINetworkLinkService.h"
+#include "nsIObserver.h"
+
+class nsQtNetworkLinkService: public nsINetworkLinkService,
+                              public nsIObserver
+{
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSINETWORKLINKSERVICE
+  NS_DECL_NSIOBSERVER
+
+  nsQtNetworkLinkService();
+
+  nsresult Init();
+  nsresult Shutdown();
+
+private:
+  virtual ~nsQtNetworkLinkService();
+};
+
+#endif /* NSQTNETWORKLINKSERVICE_H_ */
diff --git a/netwerk/system/qt/nsQtNetworkManager.cpp b/netwerk/system/qt/nsQtNetworkManager.cpp
new file mode 100644
index 000000000000..c4be6faa7326
--- /dev/null
+++ b/netwerk/system/qt/nsQtNetworkManager.cpp
@@ -0,0 +1,162 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsQtNetworkManager.h"
+
+#include "nsCOMPtr.h"
+#include "nsThreadUtils.h"
+#include "nsINetworkLinkService.h"
+#include "nsIOService.h"
+#include "nsIObserverService.h"
+#include "nsIOService.h"
+
+#include <QHostInfo>
+#include <QHostAddress>
+#include <QTime>
+
+nsQtNetworkManager* nsQtNetworkManager::gQtNetworkManager = nullptr;
+
+void nsQtNetworkManager::create()
+{
+    if (!gQtNetworkManager) {
+        gQtNetworkManager = new nsQtNetworkManager();
+        connect(gQtNetworkManager, SIGNAL(openConnectionSignal()),
+                gQtNetworkManager, SLOT(openSession()),
+                Qt::BlockingQueuedConnection);
+        connect(&gQtNetworkManager->networkConfigurationManager,
+                SIGNAL(onlineStateChanged(bool)), gQtNetworkManager,
+                SLOT(onlineStateChanged(bool)));
+    }
+}
+
+void nsQtNetworkManager::destroy()
+{
+    delete gQtNetworkManager;
+    gQtNetworkManager = nullptr;
+}
+
+nsQtNetworkManager::nsQtNetworkManager(QObject* parent)
+  : QObject(parent), networkSession(0)
+{
+    mOnline = networkConfigurationManager.isOnline();
+    NS_ASSERTION(NS_IsMainThread(), "nsQtNetworkManager can only initiated in Main Thread");
+}
+
+nsQtNetworkManager::~nsQtNetworkManager()
+{
+    closeSession();
+    networkSession->deleteLater();
+}
+
+bool
+nsQtNetworkManager::isOnline()
+{
+    static bool sForceOnlineUSB = getenv("MOZ_MEEGO_NET_ONLINE") != 0;
+    return sForceOnlineUSB || mOnline;
+}
+
+void
+nsQtNetworkManager::onlineStateChanged(bool online)
+{
+    mOnline = online;
+}
+
+/*
+  This function is called from different threads, we need to make sure that
+  the attempt to create a network connection is done in the mainthread
+
+  In case this function is called by another thread than the mainthread
+  we emit a signal which is connected through "BlockingQueue"-Connection Type.
+
+  This cause that the current thread is blocked and waiting for the result.
+
+  Of course, in case this gets called from the mainthread we must not emit the signal,
+  but call the slot directly.
+*/
+
+bool
+nsQtNetworkManager::openConnection(const QString& host)
+{
+    // we are already online -> return true.
+    if (isOnline()) {
+        return true;
+    }
+
+    if (NS_IsMainThread()) {
+        openSession();
+    } else {
+        // jump to mainthread and do the work there
+        Q_EMIT openConnectionSignal();
+    }
+
+    // if its claiming its online -> send one resolve request ahead.
+    // this is important because on mobile the first request can take up to 10 seconds
+    // sending here one will help to avoid trouble and timeouts later
+    if (isOnline()) {
+        QHostInfo::fromName(host);
+    }
+
+    return isOnline();
+}
+
+void
+nsQtNetworkManager::openSession()
+{
+    if (mBlockTimer.isActive()) {
+        // if openSession is called within 200 ms again, we forget this attempt since
+        // its mostlike an automatic connection attempt which was not successful or canceled 200ms ago.
+        // we reset the timer and start it again.
+
+        // As example: Go in firefox mobile into AwesomeView, see that the icons are not always cached and
+        // get loaded on the fly. Not having the 200 ms rule here would mean that instantly
+        // after the user dismissed the one connection dialog once another
+        // would get opened. The user will never be able to close / leave the view until each such attempt is gone through.
+
+        // Basically 200 ms are working fine, its huge enough for automatic attempts to get covered and small enough to
+        // still be able to react on direct user request.
+
+        mBlockTimer.stop();
+        mBlockTimer.setSingleShot(true);
+        mBlockTimer.start(200);
+        return;
+    }
+
+    if (isOnline()) {
+        return;
+    }
+
+    // this only means we did not shutdown before...
+    // renew Session every time
+    // fix/workaround for prestart bug
+    if (networkSession) {
+        networkSession->close();
+        networkSession->deleteLater();
+    }
+
+    // renew always to react on changed Configurations
+    networkConfigurationManager.updateConfigurations();
+    // go always with default configuration
+    networkConfiguration = networkConfigurationManager.defaultConfiguration();
+    networkSession = new QNetworkSession(networkConfiguration);
+
+    networkSession->open();
+    QTime current;
+    current.start();
+    networkSession->waitForOpened(-1);
+
+    if (current.elapsed() < 1000) {
+        NS_WARNING("Connection Creation was to fast, something is not right.");
+    }
+
+    mBlockTimer.setSingleShot(true);
+    mBlockTimer.start(200);
+}
+
+void
+nsQtNetworkManager::closeSession()
+{
+    if (networkSession) {
+        networkSession->close();
+    }
+}
diff --git a/netwerk/system/qt/nsQtNetworkManager.h b/netwerk/system/qt/nsQtNetworkManager.h
new file mode 100644
index 000000000000..314e3fc02873
--- /dev/null
+++ b/netwerk/system/qt/nsQtNetworkManager.h
@@ -0,0 +1,56 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef NSQTNETWORKMANAGER_H_
+#define NSQTNETWORKMANAGER_H_
+
+#include <QNetworkConfigurationManager>
+#include <QObject>
+#include <QTimer>
+#include <QNetworkConfiguration>
+#include <QNetworkSession>
+#include "nscore.h"
+
+class nsQtNetworkManager;
+
+
+
+class nsQtNetworkManager : public QObject
+{
+  Q_OBJECT
+  public:
+    static void create();
+    static void destroy();
+    virtual ~nsQtNetworkManager();
+
+    static nsQtNetworkManager* get() { return gQtNetworkManager; }
+
+    static bool IsConnected();
+    static bool GetLinkStatusKnown();
+    static void enableInstance();
+    bool openConnection(const QString&);
+    bool isOnline();
+  Q_SIGNALS:
+    void openConnectionSignal();
+
+  public Q_SLOTS:
+    void closeSession();
+    void onlineStateChanged(bool);
+
+  private Q_SLOTS:
+    void openSession();
+
+  private:
+    explicit nsQtNetworkManager(QObject* parent = 0);
+
+    static nsQtNetworkManager* gQtNetworkManager;
+    QNetworkSession* networkSession;
+    QNetworkConfiguration networkConfiguration;
+    QNetworkConfigurationManager networkConfigurationManager;
+    QTimer mBlockTimer;
+    bool mOnline;
+};
+
+#endif /* NSQTNETWORKMANAGER_H_ */
+
diff --git a/old-configure.in b/old-configure.in
index 46e823b9f741..ae16f305943c 100644
--- a/old-configure.in
+++ b/old-configure.in
@@ -1261,6 +1261,7 @@ if test -n "$MOZ_X11"; then
     AC_CHECK_LIB(Xext, XextAddDisplay, [XEXT_LIBS="-lXext"],
         [MISSING_X="$MISSING_X -lXext"], $XLIBS)
 
+    if test "$MOZ_WIDGET_TOOLKIT" != qt; then
     AC_CHECK_LIB(Xt, XtFree, [ XT_LIBS="-lXt"], [
         unset ac_cv_lib_Xt_XtFree
         AC_CHECK_LIB(ICE, IceFlush, [XT_LIBS="-lICE $XT_LIBS"],, $XT_LIBS $XLIBS)
@@ -1268,6 +1269,7 @@ if test -n "$MOZ_X11"; then
         AC_CHECK_LIB(Xt, XtFree, [ XT_LIBS="-lXt $XT_LIBS"],
             [MISSING_X="$MISSING_X -lXt"], $X_PRE_LIBS $XT_LIBS $XLIBS)
         ])
+    fi
 
     dnl ========================================================
     dnl = Check for xcb
@@ -2067,6 +2069,12 @@ dnl ========================================================
 
 case "$MOZ_WIDGET_TOOLKIT" in
 
+qt)
+    MOZ_ENABLE_QT=1
+
+    AC_DEFINE(QT_NO_KEYWORDS)
+    ;;
+
 cocoa)
     LDFLAGS="$LDFLAGS -framework Cocoa -lobjc"
     # Use -Wl as a trick to avoid -framework and framework names from
@@ -2165,9 +2173,174 @@ then
 fi
 AC_SUBST(MOZ_ENABLE_STARTUP_NOTIFICATION)
 
+dnl ========================================================
+dnl = QT support
+dnl ========================================================
+if test "$MOZ_ENABLE_QT"
+then
+    MOZ_ARG_WITH_STRING(qtdir,
+    [  --with-qtdir=\$dir       Specify Qt directory ],
+    [ QTDIR=$withval])
+
+    if test -z "$QTDIR"; then
+        AC_CHECK_PROGS(HOST_QMAKE, $HOST_QMAKE qmake, "")
+    else
+        HOST_QMAKE="$QTDIR/bin/qmake"
+    fi
+    QT_VERSION=`$HOST_QMAKE -v | grep 'Using Qt version' | egrep -o '[[0-9]]+\.[[0-9]]+\.[[0-9]]+'`
+
+    if test -z "$QTDIR"; then
+        case $QT_VERSION in
+        5.*)
+            AC_MSG_RESULT("Using qt5: $QT_VERSION")
+            PKG_CHECK_MODULES(MOZ_QT, Qt5Gui Qt5Network Qt5Core Qt5Quick, ,
+            [
+              AC_MSG_ERROR([$MOZ_QT_PKG_ERRORS Need qtbase development packages, (On Ubuntu, you might try installing the packages qtbase5-dev libqt5opengl5-dev.)])
+            ])
+            QT5INCDIR=`pkg-config --variable=includedir Qt5Gui`
+            MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QT5INCDIR/QtGui/$QT_VERSION/QtGui"
+            if test "$NS_PRINTING"; then
+                PKG_CHECK_MODULES(MOZ_QT_WIDGETS, Qt5PrintSupport, ,
+                [
+                  AC_MSG_ERROR([$MOZ_QT_PKG_ERRORS Need qt5 printsupport development package])
+                ])
+                MOZ_QT_LIBS="$MOZ_QT_LIBS $MOZ_QT_WIDGETS_LIBS"
+                MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $MOZ_QT_WIDGETS_CFLAGS"
+            fi
+            ;;
+        *)
+            AC_MSG_ERROR([* * * Unsupported Qt Version: $QT_VERSION])
+            ;;
+        esac
+
+        AC_CHECK_PROGS(HOST_MOC, $MOC moc, "")
+        AC_CHECK_PROGS(HOST_RCC, $RCC rcc, "")
+    else
+        MOZ_QT_CFLAGS="-DQT_SHARED"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtGui"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtCore"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtNetwork"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtXml"
+        MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtDeclarative"
+        case $QT_VERSION in
+        5.*)
+            AC_MSG_RESULT("Using qt5: $QT_VERSION")
+            MOZ_QT_LIBS="$MOZ_QT_LIBS -L$QTDIR/lib/ -lQt5Gui -lQt5Network -lQt5Core -lQt5Xml"
+            MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtGui/$QT_VERSION/QtGui"
+            if test "$NS_PRINTING"; then
+                MOZ_QT_LIBS="$MOZ_QT_LIBS -lQt5Widgets -lQt5PrintSupport"
+                MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtPrintSupport"
+            fi
+            ;;
+        *)
+            AC_MSG_ERROR([* * * Unsupported Qt Version: $QT_VERSION])
+            ;;
+        esac
+
+        HOST_MOC="$QTDIR/bin/moc"
+        HOST_RCC="$QTDIR/bin/rcc"
+    fi
+    if test -z "$HOST_MOC"; then
+        AC_MSG_ERROR([No acceptable moc preprocessor found. Qt SDK is not installed or --with-qt is incorrect])
+    fi
+    if test -z "$HOST_RCC"; then
+        AC_MSG_ERROR([No acceptable rcc preprocessor found. Qt SDK is not installed or --with-qt is incorrect])
+    fi
+
+    MOC=$HOST_MOC
+    RCC=$HOST_RCC
+
+    MOZ_ENABLE_QMSYSTEM2=
+    PKG_CHECK_MODULES(_QMSYSTEM2, qmsystem2,
+                      MOZ_ENABLE_QMSYSTEM2=1,
+                      MOZ_ENABLE_QMSYSTEM2=)
+
+    if test "$MOZ_ENABLE_QMSYSTEM2"; then
+      MOZ_ENABLE_QMSYSTEM2=1
+      MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $_QMSYSTEM2_CFLAGS"
+      MOZ_QT_LIBS="$MOZ_QT_LIBS $_QMSYSTEM2_LIBS"
+      AC_DEFINE(MOZ_ENABLE_QMSYSTEM2)
+    fi
+
+    MOZ_ENABLE_QTNETWORK=
+    PKG_CHECK_MODULES(_QTNETWORK, QtNetwork >= 4.7,
+                      MOZ_ENABLE_QTNETWORK=1,
+                      MOZ_ENABLE_QTNETWORK=)
+
+    if test "$MOZ_ENABLE_QTNETWORK"; then
+      MOZ_ENABLE_QTNETWORK=1
+      AC_DEFINE(MOZ_ENABLE_QTNETWORK)
+    fi
+
+    MOZ_ENABLE_QTMOBILITY=
+    PKG_CHECK_MODULES(_QTMOBILITY, QtSensors QtFeedback QtLocation,
+                      MOZ_ENABLE_QTMOBILITY=1,
+                      MOZ_ENABLE_QTMOBILITY=)
+    if test "$MOZ_ENABLE_QTMOBILITY"; then
+       MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $_QTMOBILITY_CFLAGS"
+       MOZ_QT_LIBS="$MOZ_QT_LIBS $_QTMOBILITY_LIBS"
+    else
+       AC_CHECK_LIB(QtSensors, main, [
+          MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtMobility"
+          MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtSensors"
+          MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtFeedback"
+          MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS -I$QTDIR/include/QtLocation"
+          MOZ_QT_LIBS="$MOZ_QT_LIBS -lQtSensors -lQtFeedback -lQtLocation"
+       ])
+    fi
+
+    MOZ_ENABLE_QT5FEEDBACK=
+    PKG_CHECK_MODULES(_QT5FEEDBACK, Qt0Feedback,
+                      MOZ_ENABLE_QT5FEEDBACK=1,
+                      MOZ_ENABLE_QT5FEEDBACK=)
+    if test "$MOZ_ENABLE_QT5FEEDBACK"; then
+       MOZ_ENABLE_QT5FEEDBACK=1
+       MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $_QT5FEEDBACK_CFLAGS"
+       MOZ_QT_LIBS="$MOZ_QT_LIBS $_QT5FEEDBACK_LIBS"
+       AC_DEFINE(MOZ_ENABLE_QT5FEEDBACK)
+       AC_SUBST(MOZ_ENABLE_QT5FEEDBACK)
+    fi
+
+    MOZ_ENABLE_QT5GEOPOSITION=
+    PKG_CHECK_MODULES(_QT5GEOPOSITION, Qt5Positioning,
+                      MOZ_ENABLE_QT5GEOPOSITION=1,
+                      MOZ_ENABLE_QT5GEOPOSITION=)
+    if test "$MOZ_ENABLE_QT5GEOPOSITION"; then
+       MOZ_ENABLE_QT5GEOPOSITION=1
+       MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $_QT5GEOPOSITION_CFLAGS"
+       MOZ_QT_LIBS="$MOZ_QT_LIBS $_QT5GEOPOSITION_LIBS"
+       AC_DEFINE(MOZ_ENABLE_QT5GEOPOSITION)
+       AC_SUBST(MOZ_ENABLE_QT5GEOPOSITION)
+    fi
+
+    if test "$MOZ_ENABLE_CONTENTACTION"; then
+      MOZ_ENABLE_CONTENTACTION=1
+      AC_DEFINE(MOZ_ENABLE_CONTENTACTION)
+    fi
+
+    MOZ_ENABLE_CONTENTACTION=
+    PKG_CHECK_MODULES(LIBCONTENTACTION, contentaction-0.1, _LIB_FOUND=1, _LIB_FOUND=)
+    if test "$MOZ_ENABLE_CONTENTACTION"; then
+       MOZ_ENABLE_CONTENTACTION=1
+       MOZ_QT_CFLAGS="$MOZ_QT_CFLAGS $_CONTENTACTION_CFLAGS"
+       MOZ_QT_LIBS="$MOZ_QT_LIBS $_CONTENTACTION_LIBS"
+       AC_DEFINE(MOZ_ENABLE_CONTENTACTION)
+       AC_SUBST(MOZ_ENABLE_CONTENTACTION)
+    fi
+    TK_CFLAGS=$MOZ_QT_CFLAGS
+    TK_LIBS=$MOZ_QT_LIBS
+fi
+
 AC_SUBST_LIST(TK_CFLAGS)
 AC_SUBST_LIST(TK_LIBS)
 
+AC_SUBST(MOZ_ENABLE_QT)
+AC_SUBST(MOZ_ENABLE_QTNETWORK)
+AC_SUBST(MOZ_ENABLE_QMSYSTEM2)
+AC_SUBST_LIST(MOZ_QT_CFLAGS)
+AC_SUBST_LIST(MOZ_QT_LIBS)
+
 AC_SUBST(MOC)
 AC_SUBST(RCC)
 
@@ -2266,7 +2439,7 @@ dnl ========================================================
 dnl = libproxy support
 dnl ========================================================
 
-if test "$MOZ_ENABLE_GTK"
+if test "$MOZ_ENABLE_GTK" -o "$MOZ_ENABLE_QT"
 then
     MOZ_ENABLE_LIBPROXY=
 
@@ -2287,7 +2460,7 @@ dnl ========================================================
 dnl = dbus support
 dnl ========================================================
 
-if test "$MOZ_ENABLE_GTK"
+if test "$MOZ_ENABLE_GTK" -o "$MOZ_ENABLE_QT"
 then
     MOZ_ENABLE_DBUS=1
 
@@ -3906,7 +4079,7 @@ dnl ========================================================
 
 if test -z "$SKIP_PATH_CHECKS"; then
 if test -z "${GLIB_CFLAGS}" -o -z "${GLIB_LIBS}" ; then
-    if test "$MOZ_ENABLE_GTK" ; then
+    if test "$MOZ_ENABLE_GTK" -o "$MOZ_ENABLE_QT"; then
         PKG_CHECK_MODULES(GLIB, glib-2.0 >= 1.3.7 gobject-2.0)
     fi
 fi
@@ -4016,6 +4189,9 @@ if test "$_HAVE_FREETYPE2"; then
 fi
 
 case "$MOZ_WIDGET_TOOLKIT" in
+  qt)
+    QT_SURFACE_FEATURE="#define CAIRO_HAS_QT_SURFACE 1"
+    ;;
   cocoa | uikit)
     QUARTZ_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_SURFACE 1"
     QUARTZ_IMAGE_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_IMAGE_SURFACE 1"
diff --git a/toolkit/library/moz.build b/toolkit/library/moz.build
index 80463f571e07..2410081cb05c 100644
--- a/toolkit/library/moz.build
+++ b/toolkit/library/moz.build
@@ -155,7 +155,7 @@ if CONFIG['MOZ_JPROF']:
         'jprof',
     ]
 
-if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT'] or \
+if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT'] or CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt' or \
         CONFIG['MOZ_TREE_FREETYPE']:
     USE_LIBS += [
         'freetype',
@@ -283,6 +283,13 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
         'gthread-2.0',
     ]
 
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    OS_LIBS += CONFIG['XLDFLAGS']
+    OS_LIBS += CONFIG['XLIBS']
+    OS_LIBS += CONFIG['XT_LIBS']
+    OS_LIBS += CONFIG['MOZ_QT_LIBS']
+    OS_LIBS += CONFIG['MOZ_PANGO_LIBS']
+
 if CONFIG['MOZ_ENABLE_STARTUP_NOTIFICATION']:
     OS_LIBS += CONFIG['MOZ_STARTUP_NOTIFICATION_LIBS']
 
@@ -335,6 +342,9 @@ if CONFIG['OS_ARCH'] == 'WINNT':
             'oleacc',
         ]
 
+if CONFIG['MOZ_ENABLE_QT']:
+    OS_LIBS += CONFIG['XEXT_LIBS']
+
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':
     OS_LIBS += [
         'usp10',
diff --git a/toolkit/modules/AppConstants.jsm b/toolkit/modules/AppConstants.jsm
index 8dabe0ff6f5d..43c65904d834 100644
--- a/toolkit/modules/AppConstants.jsm
+++ b/toolkit/modules/AppConstants.jsm
@@ -150,6 +150,8 @@ this.AppConstants = Object.freeze({
   platform:
 #ifdef MOZ_WIDGET_GTK
   "linux",
+#elif MOZ_WIDGET_QT
+  "linux",
 #elif XP_WIN
   "win",
 #elif XP_MACOSX
diff --git a/toolkit/moz.build b/toolkit/moz.build
index df0b09d3bc0f..0edf2d553307 100644
--- a/toolkit/moz.build
+++ b/toolkit/moz.build
@@ -35,7 +35,7 @@ if CONFIG['MOZ_MAINTENANCE_SERVICE']:
 
 DIRS += ['xre']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('gtk3', 'qt'):
     DIRS += ['system/unixproxy']
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
     DIRS += ['system/osxproxy']
diff --git a/toolkit/moz.configure b/toolkit/moz.configure
index ea40a2305bf8..729b39ab1c8e 100644
--- a/toolkit/moz.configure
+++ b/toolkit/moz.configure
@@ -112,7 +112,7 @@ set_config('L10NBASEDIR', l10n_base)
 # `choices` depending on the target, but that doesn't pan out for the same
 # reason.
 option('--enable-default-toolkit', nargs=1,
-       choices=('cairo-windows', 'cairo-gtk3', 'cairo-gtk3-wayland',
+       choices=('cairo-windows', 'cairo-gtk3', 'cairo-gtk3-wayland', 'cairo-qt',
                 'cairo-cocoa', 'cairo-uikit', 'cairo-android'),
        help='Select default toolkit')
 
@@ -129,7 +129,7 @@ def toolkit(value, target, _):
     elif target.os == 'Android':
         platform_choices = ('cairo-android',)
     else:
-        platform_choices = ('cairo-gtk3', 'cairo-gtk3-wayland')
+        platform_choices = ('cairo-gtk3', 'cairo-gtk3-wayland', 'cairo-qt')
 
     if value:
         if value[0] not in platform_choices:
@@ -174,10 +174,10 @@ option('--without-x', env='WITHOUT_X', help='Disable X11 support')
 
 @depends('--without-x', toolkit)
 def x11(value, toolkit):
-    if not value:
-        die('--without-x is not supported')
+    if not value and toolkit != 'qt':
+        die('--without-x is only valid with --enable-default-toolkit=qt')
 
-    x11_toolkits = ('gtk3',)
+    x11_toolkits = ('gtk3', 'qt')
     if value and value.origin != 'default' and toolkit not in x11_toolkits:
         die('--with-x is only valid with --enable-default-toolkit={%s}',
             ','.join(x11_toolkits))
@@ -238,7 +238,7 @@ set_define(gl_provider_define, True)
 # ==============================================================
 @depends(toolkit)
 def pdf_printing(toolkit):
-    if toolkit in ('windows', 'gtk3', 'android'):
+    if toolkit in ('windows', 'gtk3', 'android', 'qt'):
         return True
 
 @depends(pdf_printing)
@@ -275,7 +275,7 @@ option(env='USE_FC_FREETYPE',
 
 @depends('USE_FC_FREETYPE', toolkit)
 def fc_freetype(value, toolkit):
-    if value or (toolkit == 'gtk3' and
+    if value or (toolkit in ('gtk3', 'qt') and
                  value.origin == 'default'):
         return True
 
diff --git a/toolkit/themes/moz.build b/toolkit/themes/moz.build
index 442c62c94c5b..468ea128786f 100644
--- a/toolkit/themes/moz.build
+++ b/toolkit/themes/moz.build
@@ -20,7 +20,7 @@ app = CONFIG['MOZ_BUILD_APP']
 
 if toolkit == 'cocoa':
     DIRS += ['osx']
-elif toolkit == 'gtk3':
+elif toolkit in ('gtk3', 'qt'):
     DIRS += ['linux']
 elif app == 'mobile/android':
     DIRS += ['mobile']
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
index 4c5f91862aed..6af0de70ef94 100644
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -69,6 +69,13 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'uikit':
         'nsNativeAppSupportDefault.cpp',
         'UIKitDirProvider.mm',
     ]
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    EXPORTS += ['nsQAppInstance.h']
+    SOURCES += [
+        '!moc_nsNativeAppSupportQt.cpp',
+        'nsNativeAppSupportQt.cpp',
+        'nsQAppInstance.cpp',
+    ]
 elif 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     UNIFIED_SOURCES += [
         'nsNativeAppSupportUnix.cpp',
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index 2725ea3fb83b..f1864273b75c 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -3,6 +3,12 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(MOZ_WIDGET_QT)
+#include <QGuiApplication>
+#include <QStringList>
+#include "nsQAppInstance.h"
+#endif // MOZ_WIDGET_QT
+
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/ipc/GeckoChildProcessHost.h"
@@ -254,6 +260,11 @@ bool gIsGtest = false;
 
 nsString gAbsoluteArgv0Path;
 
+#ifdef MOZ_WIDGET_QT
+static int    gQtOnlyArgc;
+static char **gQtOnlyArgv;
+#endif
+
 #if defined(MOZ_WIDGET_GTK)
 #include <glib.h>
 #if defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING)
@@ -1757,8 +1768,14 @@ static nsresult LaunchChild(nsINativeAppSupport* aNative,
 #endif
 
   if (aBlankCommandLine) {
+#if defined(MOZ_WIDGET_QT)
+    // Remove only arguments not given to Qt
+    gRestartArgc = gQtOnlyArgc;
+    gRestartArgv = gQtOnlyArgv;
+#else
     gRestartArgc = 1;
     gRestartArgv[gRestartArgc] = nullptr;
+#endif
   }
 
   SaveToEnv("MOZ_LAUNCHED_CHILD=1");
@@ -3795,6 +3812,25 @@ int XREMain::XRE_mainStartup(bool* aExitFlag) {
   }
 #endif
 
+#if defined(MOZ_WIDGET_QT)
+  nsQAppInstance::AddRef(gArgc, gArgv, true);
+
+  QStringList nonQtArguments = qApp->arguments();
+  gQtOnlyArgc = 1;
+  gQtOnlyArgv = (char**) malloc(sizeof(char*)
+                * (gRestartArgc - nonQtArguments.size() + 2));
+
+  // copy binary path
+  gQtOnlyArgv[0] = gRestartArgv[0];
+
+  for (int i = 1; i < gRestartArgc; ++i) {
+    if (!nonQtArguments.contains(gRestartArgv[i])) {
+      // copy arguments used by Qt for later
+      gQtOnlyArgv[gQtOnlyArgc++] = gRestartArgv[i];
+    }
+  }
+  gQtOnlyArgv[gQtOnlyArgc] = nullptr;
+#endif
 #if defined(MOZ_WIDGET_GTK)
   // setup for private colormap.  Ideally we'd like to do this
   // in nsAppShell::Create, but we need to get in before gtk
@@ -4817,6 +4853,10 @@ int XREMain::XRE_main(int argc, char* argv[], const BootstrapConfig& aConfig) {
   mProfileLock->Unlock();
   gProfileLock = nullptr;
 
+#if defined(MOZ_WIDGET_QT)
+  nsQAppInstance::Release();
+#endif
+
   // Restart the app after XPCOM has been shut down cleanly.
   if (appInitiatedRestart) {
     RestoreStateForAppInitiatedRestart();
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
index 2b7c8a7fa7cd..950005c7bb70 100644
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -4,6 +4,10 @@
 
 #include "mozilla/DebugOnly.h"
 
+#if defined(MOZ_WIDGET_QT)
+#include "nsQAppInstance.h"
+#endif
+
 #include "base/basictypes.h"
 
 #include "nsXULAppAPI.h"
@@ -515,6 +519,10 @@ nsresult XRE_InitChildProcess(int aArgc, char* aArgv[],
   g_set_prgname(aArgv[0]);
 #endif
 
+#if defined(MOZ_WIDGET_QT)
+  nsQAppInstance::AddRef();
+#endif
+
 #ifdef OS_POSIX
   if (PR_GetEnv("MOZ_DEBUG_CHILD_PROCESS") ||
       PR_GetEnv("MOZ_DEBUG_CHILD_PAUSE")) {
diff --git a/toolkit/xre/nsNativeAppSupportQt.cpp b/toolkit/xre/nsNativeAppSupportQt.cpp
new file mode 100644
index 000000000000..98ea4805e725
--- /dev/null
+++ b/toolkit/xre/nsNativeAppSupportQt.cpp
@@ -0,0 +1,118 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <stdlib.h>
+#include <QTimer>
+#include "mozilla/ipc/GeckoChildProcessHost.h"
+#include "nsNativeAppSupportQt.h"
+#include "nsCOMPtr.h"
+#include "nsIObserverService.h"
+#include "mozilla/Services.h"
+
+#ifdef MOZ_ENABLE_QMSYSTEM2
+void
+nsNativeAppSupportQt::activityChanged(MeeGo::QmActivity::Activity activity)
+{
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (!os)
+        return;
+
+    if (MeeGo::QmActivity::Inactive == activity) {
+        os->NotifyObservers(nullptr, "system-idle", nullptr);
+    } else {
+        os->NotifyObservers(nullptr, "system-active", nullptr);
+    }
+}
+
+void
+nsNativeAppSupportQt::displayStateChanged(MeeGo::QmDisplayState::DisplayState state)
+{
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (!os)
+        return;
+
+    switch (state) {
+    case MeeGo::QmDisplayState::On:
+        os->NotifyObservers(nullptr, "system-display-on", nullptr);
+        break;
+    case MeeGo::QmDisplayState::Off:
+        os->NotifyObservers(nullptr, "system-display-off", nullptr);
+        break;
+    case MeeGo::QmDisplayState::Dimmed:
+        os->NotifyObservers(nullptr, "system-display-dimmed", nullptr);
+        break;
+    default:
+        NS_WARNING("Unknown display state");
+        break;
+    }
+}
+
+void nsNativeAppSupportQt::deviceModeChanged(MeeGo::QmDeviceMode::DeviceMode mode)
+{
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (!os)
+        return;
+
+    switch (mode) {
+    case MeeGo::QmDeviceMode::DeviceMode::Normal:
+        os->NotifyObservers(nullptr, "profile-change-net-restore", nullptr);
+        break;
+    case MeeGo::QmDeviceMode::DeviceMode::Flight:
+        os->NotifyObservers(nullptr, "profile-change-net-teardown", nullptr);
+        break;
+    case MeeGo::QmDeviceMode::DeviceMode::Error:
+    default:
+        NS_WARNING("Unknown DeviceMode");
+        break;
+    }
+}
+
+void nsNativeAppSupportQt::RefreshStates()
+{
+  activityChanged(mActivity.get());
+  displayStateChanged(mDisplayState.get());
+  deviceModeChanged(mDeviceMode.getMode());
+}
+#endif
+
+NS_IMETHODIMP
+nsNativeAppSupportQt::Start(bool* aRetVal)
+{
+  NS_ASSERTION(gAppData, "gAppData must not be null.");
+
+#ifdef MOZ_ENABLE_QMSYSTEM2
+  connect(&mActivity, SIGNAL(activityChanged(MeeGo::QmActivity::Activity)), this, SLOT(activityChanged(MeeGo::QmActivity::Activity)));
+  connect(&mDeviceMode, SIGNAL(deviceModeChanged(MeeGo::QmDeviceMode::DeviceMode)), this, SLOT(deviceModeChanged(MeeGo::QmDeviceMode::DeviceMode)));
+  connect(&mDisplayState, SIGNAL(displayStateChanged(MeeGo::QmDisplayState::DisplayState)), this, SLOT(displayStateChanged(MeeGo::QmDisplayState::DisplayState)));
+  // Init states withing next event loop iteration
+  QTimer::singleShot(0, this, SLOT(RefreshStates()));
+#endif
+
+  *aRetVal = true;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNativeAppSupportQt::Stop(bool* aResult)
+{
+  NS_ENSURE_ARG(aResult);
+  *aResult = true;
+
+  return NS_OK;
+}
+
+nsresult
+NS_CreateNativeAppSupport(nsINativeAppSupport** aResult)
+{
+  nsNativeAppSupportBase* native = new nsNativeAppSupportQt();
+  if (!native)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  *aResult = native;
+  NS_ADDREF(*aResult);
+
+  return NS_OK;
+}
diff --git a/toolkit/xre/nsNativeAppSupportQt.h b/toolkit/xre/nsNativeAppSupportQt.h
new file mode 100644
index 000000000000..b55db36a5dee
--- /dev/null
+++ b/toolkit/xre/nsNativeAppSupportQt.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <stdlib.h>
+#include <QObject>
+#ifdef MOZ_ENABLE_QMSYSTEM2
+#include "qmdevicemode.h"
+#include "qmdisplaystate.h"
+#include "qmactivity.h"
+#endif
+#include "nsNativeAppSupportBase.h"
+#include "nsString.h"
+
+class nsNativeAppSupportQt : public QObject, public nsNativeAppSupportBase
+{
+  Q_OBJECT
+public:
+  NS_IMETHOD Start(bool* aRetVal);
+  NS_IMETHOD Stop(bool* aResult);
+
+#ifdef MOZ_ENABLE_QMSYSTEM2
+public Q_SLOTS:
+  void activityChanged(MeeGo::QmActivity::Activity activity);
+  void deviceModeChanged(MeeGo::QmDeviceMode::DeviceMode mode);
+  void displayStateChanged(MeeGo::QmDisplayState::DisplayState state);
+  void RefreshStates();
+
+private:
+  MeeGo::QmDeviceMode mDeviceMode;
+  MeeGo::QmDisplayState mDisplayState;
+  MeeGo::QmActivity mActivity;
+#endif
+};
+
diff --git a/toolkit/xre/nsQAppInstance.cpp b/toolkit/xre/nsQAppInstance.cpp
new file mode 100644
index 000000000000..73a6d009adbb
--- /dev/null
+++ b/toolkit/xre/nsQAppInstance.cpp
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsQAppInstance.h"
+#include <QGuiApplication>
+#include "prenv.h"
+#include "nsXPCOMPrivate.h"
+#include <stdlib.h>
+
+QGuiApplication *nsQAppInstance::sQAppInstance = nullptr;
+int nsQAppInstance::sQAppRefCount = 0;
+
+void nsQAppInstance::AddRef(int& aArgc, char** aArgv, bool aDefaultProcess) {
+  if (qApp)
+    return;
+  if (!sQAppInstance) {
+    mozilla::SetICUMemoryFunctions();
+    sQAppInstance = new QGuiApplication(aArgc, aArgv);
+  }
+  sQAppRefCount++;
+}
+
+void nsQAppInstance::Release(void) {
+  if (sQAppInstance && !--sQAppRefCount) {
+    delete sQAppInstance;
+    sQAppInstance = nullptr;
+  }
+}
diff --git a/toolkit/xre/nsQAppInstance.h b/toolkit/xre/nsQAppInstance.h
new file mode 100644
index 000000000000..52e6a8ce2fa9
--- /dev/null
+++ b/toolkit/xre/nsQAppInstance.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsQAppInstance_h
+#define nsQAppInstance_h
+
+// declared in nsAppRunner.cpp
+extern int    gArgc;
+extern char **gArgv;
+
+class QGuiApplication;
+class nsQAppInstance
+{
+public:
+  static void AddRef(int& aArgc = gArgc,
+                     char** aArgv = gArgv,
+                     bool aDefaultProcess = false);
+  static void Release(void);
+
+private:
+  static QGuiApplication *sQAppInstance;
+  static int sQAppRefCount;
+};
+
+#endif /* nsQAppInstance_h */
diff --git a/uriloader/exthandler/moz.build b/uriloader/exthandler/moz.build
index 8f7e6f0b934b..cabe2513273d 100644
--- a/uriloader/exthandler/moz.build
+++ b/uriloader/exthandler/moz.build
@@ -92,6 +92,14 @@ elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
         'android/nsExternalURLHandlerService.cpp',
         'android/nsMIMEInfoAndroid.cpp',
     ]
+elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'qt':
+    SOURCES += [
+        'unix/nsMIMEInfoQt.cpp',
+    ]
+    UNIFIED_SOURCES += [
+        'unix/nsGNOMERegistry.cpp',
+        'unix/nsMIMEInfoUnix.cpp',
+    ]
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':
     UNIFIED_SOURCES += [
         'win/nsMIMEInfoWin.cpp',
@@ -135,6 +143,6 @@ if CONFIG['MOZ_ENABLE_DBUS']:
     CXXFLAGS += CONFIG['TK_CFLAGS']
     CXXFLAGS += CONFIG['MOZ_DBUS_CFLAGS']
 
-if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('qt', 'gtk3'):
     CXXFLAGS += CONFIG['TK_CFLAGS']
     CXXFLAGS += CONFIG['MOZ_DBUS_GLIB_CFLAGS']
diff --git a/uriloader/exthandler/unix/nsMIMEInfoQt.cpp b/uriloader/exthandler/unix/nsMIMEInfoQt.cpp
new file mode 100644
index 000000000000..72020064660e
--- /dev/null
+++ b/uriloader/exthandler/unix/nsMIMEInfoQt.cpp
@@ -0,0 +1,30 @@
+/* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifdef MOZ_WIDGET_QT
+#include <QDesktopServices>
+#include <QUrl>
+#include <QString>
+#include <QStringList>
+#endif
+
+#include "nsMIMEInfoQt.h"
+#include "nsIURI.h"
+#include "nsString.h"
+
+nsresult
+nsMIMEInfoQt::LoadUriInternal(nsIURI * aURI)
+{
+#ifdef MOZ_WIDGET_QT
+  nsAutoCString spec;
+  aURI->GetAsciiSpec(spec);
+  if (QDesktopServices::openUrl(QUrl(spec.get()))) {
+    return NS_OK;
+  }
+#endif
+
+  return NS_ERROR_FAILURE;
+}
diff --git a/uriloader/exthandler/unix/nsMIMEInfoQt.h b/uriloader/exthandler/unix/nsMIMEInfoQt.h
new file mode 100644
index 000000000000..35df6b6aa162
--- /dev/null
+++ b/uriloader/exthandler/unix/nsMIMEInfoQt.h
@@ -0,0 +1,20 @@
+/* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsMIMEInfoQt_h_
+#define nsMIMEInfoQt_h_
+
+#include "nsCOMPtr.h"
+
+class nsIURI;
+
+class nsMIMEInfoQt
+{
+public:
+  static nsresult LoadUriInternal(nsIURI * aURI);
+};
+
+#endif // nsMIMEInfoQt_h_
diff --git a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
index deb3e8b56e5c..807583a57d12 100644
--- a/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
+++ b/uriloader/exthandler/unix/nsMIMEInfoUnix.cpp
@@ -4,6 +4,13 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#ifdef MOZ_WIDGET_QT
+#if (MOZ_ENABLE_CONTENTACTION)
+#include <contentaction/contentaction.h>
+#include "nsContentHandlerApp.h"
+#endif
+#endif
+
 #include "nsMIMEInfoUnix.h"
 #include "nsGNOMERegistry.h"
 #include "nsIGIOService.h"
@@ -13,9 +20,20 @@
 #ifdef MOZ_ENABLE_DBUS
 #include "nsDBusHandlerApp.h"
 #endif
+#ifdef MOZ_WIDGET_QT
+#include "nsMIMEInfoQt.h"
+#endif
 
 nsresult nsMIMEInfoUnix::LoadUriInternal(nsIURI *aURI) {
-  return nsGNOMERegistry::LoadURL(aURI);
+  nsresult rv = nsGNOMERegistry::LoadURL(aURI);
+
+#ifdef MOZ_WIDGET_QT
+  if (NS_FAILED(rv)) {
+    rv = nsMIMEInfoQt::LoadUriInternal(aURI);
+  }
+#endif
+
+  return rv;
 }
 
 NS_IMETHODIMP
diff --git a/widget/NativeKeyToDOMCodeName.h b/widget/NativeKeyToDOMCodeName.h
index 1330f154cd32..8bc4bfce9d59 100644
--- a/widget/NativeKeyToDOMCodeName.h
+++ b/widget/NativeKeyToDOMCodeName.h
@@ -36,7 +36,7 @@
 #define CODE_MAP_MAC(aCPPCodeName, aNativeKey)     \
   NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX(aNativeKey, \
                                        CODE_NAME_INDEX_##aCPPCodeName)
-#elif defined(MOZ_WIDGET_GTK)
+#elif defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)
 #undef CODE_MAP_X11
 // aNativeKey is hardware_keycode of GDKEvent or nativeScanCode of QKeyEvent.
 #define CODE_MAP_X11(aCPPCodeName, aNativeKey)     \
diff --git a/widget/NativeKeyToDOMKeyName.h b/widget/NativeKeyToDOMKeyName.h
index 24d942227020..3409eb610578 100644
--- a/widget/NativeKeyToDOMKeyName.h
+++ b/widget/NativeKeyToDOMKeyName.h
@@ -25,6 +25,8 @@
 #define KEY_MAP_COCOA(aCPPKeyName, aNativeKey)
 // GTK
 #define KEY_MAP_GTK(aCPPKeyName, aNativeKey)
+// Qt
+#define KEY_MAP_QT(aCPPKeyName, aNativeKey)
 // Android and B2G
 #define KEY_MAP_ANDROID(aCPPKeyName, aNativeKey)
 // Only for Android
@@ -75,6 +77,10 @@
 #undef KEY_MAP_GTK
 #define KEY_MAP_GTK(aCPPKeyName, aNativeKey) \
   NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX(aNativeKey, KEY_NAME_INDEX_##aCPPKeyName)
+#elif defined(MOZ_WIDGET_QT)
+#undef KEY_MAP_QT
+#define KEY_MAP_QT(aCPPKeyName, aNativeKey) \
+  NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX(aNativeKey, KEY_NAME_INDEX_##aCPPKeyName)
 #elif defined(ANDROID)
 #undef KEY_MAP_ANDROID
 #define KEY_MAP_ANDROID(aCPPKeyName, aNativeKey) \
@@ -95,6 +101,7 @@ KEY_MAP_COCOA(Alt, kVK_Option)
 KEY_MAP_COCOA(Alt, kVK_RightOption)
 KEY_MAP_GTK(Alt, GDK_Alt_L)
 KEY_MAP_GTK(Alt, GDK_Alt_R)
+KEY_MAP_QT(Alt, Qt::Key_Alt)
 KEY_MAP_ANDROID(Alt, AKEYCODE_ALT_LEFT)
 KEY_MAP_ANDROID(Alt, AKEYCODE_ALT_RIGHT)
 
@@ -111,11 +118,14 @@ KEY_MAP_GTK(AltGraph, GDK_ISO_Level3_Lock)
 KEY_MAP_GTK(AltGraph, GDK_ISO_Level5_Shift)
 KEY_MAP_GTK(AltGraph, GDK_ISO_Level5_Latch)
 KEY_MAP_GTK(AltGraph, GDK_ISO_Level5_Lock)
+KEY_MAP_QT(AltGraph, Qt::Key_AltGr)
+KEY_MAP_QT(AltGraph, Qt::Key_Mode_switch)
 
 // CapsLock
 KEY_MAP_WIN(CapsLock, VK_CAPITAL)
 KEY_MAP_COCOA(CapsLock, kVK_CapsLock)
 KEY_MAP_GTK(CapsLock, GDK_Caps_Lock)
+KEY_MAP_QT(CapsLock, Qt::Key_CapsLock)
 KEY_MAP_ANDROID(CapsLock, AKEYCODE_CAPS_LOCK)
 
 // Control
@@ -126,6 +136,7 @@ KEY_MAP_COCOA(Control, kVK_Control)
 KEY_MAP_COCOA(Control, kVK_RightControl)
 KEY_MAP_GTK(Control, GDK_Control_L)
 KEY_MAP_GTK(Control, GDK_Control_R)
+KEY_MAP_QT(Control, Qt::Key_Control)
 KEY_MAP_ANDROID(Control, AKEYCODE_CTRL_LEFT)
 KEY_MAP_ANDROID(Control, AKEYCODE_CTRL_RIGHT)
 
@@ -138,12 +149,14 @@ KEY_MAP_COCOA(Meta, kVK_Command)
 KEY_MAP_COCOA(Meta, kVK_RightCommand)
 KEY_MAP_GTK(Meta, GDK_Meta_L)
 KEY_MAP_GTK(Meta, GDK_Meta_R)
+KEY_MAP_QT(Meta, Qt::Key_Meta)
 KEY_MAP_ANDROID(Meta, AKEYCODE_META_LEFT)
 KEY_MAP_ANDROID(Meta, AKEYCODE_META_RIGHT)
 
 // NumLock
 KEY_MAP_WIN(NumLock, VK_NUMLOCK)
 KEY_MAP_GTK(NumLock, GDK_Num_Lock)
+KEY_MAP_QT(NumLock, Qt::Key_NumLock)
 KEY_MAP_ANDROID(NumLock, AKEYCODE_NUM_LOCK)
 
 // OS
@@ -153,10 +166,15 @@ KEY_MAP_GTK(OS, GDK_Super_L)
 KEY_MAP_GTK(OS, GDK_Super_R)
 KEY_MAP_GTK(OS, GDK_Hyper_L)
 KEY_MAP_GTK(OS, GDK_Hyper_R)
+KEY_MAP_QT(OS, Qt::Key_Super_L)
+KEY_MAP_QT(OS, Qt::Key_Super_R)
+KEY_MAP_QT(OS, Qt::Key_Hyper_L)
+KEY_MAP_QT(OS, Qt::Key_Hyper_R)
 
 // ScrollLock
 KEY_MAP_WIN(ScrollLock, VK_SCROLL)
 KEY_MAP_GTK(ScrollLock, GDK_Scroll_Lock)
+KEY_MAP_QT(ScrollLock, Qt::Key_ScrollLock)
 KEY_MAP_ANDROID(ScrollLock, AKEYCODE_SCROLL_LOCK)
 
 // Shift
@@ -168,6 +186,7 @@ KEY_MAP_COCOA(Shift, kVK_RightShift)
 KEY_MAP_GTK(Shift, GDK_Shift_L)
 KEY_MAP_GTK(Shift, GDK_Shift_R)
 KEY_MAP_GTK(Shift, GDK_Shift_Lock)  // Let's treat as Shift key (bug 769159)
+KEY_MAP_QT(Shift, Qt::Key_Shift)
 KEY_MAP_ANDROID(Shift, AKEYCODE_SHIFT_LEFT)
 KEY_MAP_ANDROID(Shift, AKEYCODE_SHIFT_RIGHT)
 
@@ -186,6 +205,8 @@ KEY_MAP_GTK(Enter, GDK_Return)
 KEY_MAP_GTK(Enter, GDK_KP_Enter)
 KEY_MAP_GTK(Enter, GDK_ISO_Enter)
 KEY_MAP_GTK(Enter, GDK_3270_Enter)
+KEY_MAP_QT(Enter, Qt::Key_Return)
+KEY_MAP_QT(Enter, Qt::Key_Enter)
 KEY_MAP_ANDROID(Enter, AKEYCODE_DPAD_CENTER)
 KEY_MAP_ANDROID(Enter, AKEYCODE_ENTER)
 KEY_MAP_ANDROID(Enter, AKEYCODE_NUMPAD_ENTER)
@@ -196,6 +217,7 @@ KEY_MAP_COCOA(Tab, kVK_Tab)
 KEY_MAP_GTK(Tab, GDK_Tab)
 KEY_MAP_GTK(Tab, GDK_ISO_Left_Tab)  // Shift+Tab
 KEY_MAP_GTK(Tab, GDK_KP_Tab)
+KEY_MAP_QT(Tab, Qt::Key_Tab)
 KEY_MAP_ANDROID(Tab, AKEYCODE_TAB)
 
 /******************************************************************************
@@ -206,6 +228,7 @@ KEY_MAP_WIN(ArrowDown, VK_DOWN)
 KEY_MAP_COCOA(ArrowDown, kVK_DownArrow)
 KEY_MAP_GTK(ArrowDown, GDK_Down)
 KEY_MAP_GTK(ArrowDown, GDK_KP_Down)
+KEY_MAP_QT(ArrowDown, Qt::Key_Down)
 KEY_MAP_ANDROID(ArrowDown, AKEYCODE_DPAD_DOWN)
 
 // ArrowLeft
@@ -213,6 +236,7 @@ KEY_MAP_WIN(ArrowLeft, VK_LEFT)
 KEY_MAP_COCOA(ArrowLeft, kVK_LeftArrow)
 KEY_MAP_GTK(ArrowLeft, GDK_Left)
 KEY_MAP_GTK(ArrowLeft, GDK_KP_Left)
+KEY_MAP_QT(ArrowLeft, Qt::Key_Left)
 KEY_MAP_ANDROID(ArrowLeft, AKEYCODE_DPAD_LEFT)
 
 // ArrowRight
@@ -220,6 +244,7 @@ KEY_MAP_WIN(ArrowRight, VK_RIGHT)
 KEY_MAP_COCOA(ArrowRight, kVK_RightArrow)
 KEY_MAP_GTK(ArrowRight, GDK_Right)
 KEY_MAP_GTK(ArrowRight, GDK_KP_Right)
+KEY_MAP_QT(ArrowRight, Qt::Key_Right)
 KEY_MAP_ANDROID(ArrowRight, AKEYCODE_DPAD_RIGHT)
 
 // ArrowUp
@@ -227,6 +252,7 @@ KEY_MAP_WIN(ArrowUp, VK_UP)
 KEY_MAP_COCOA(ArrowUp, kVK_UpArrow)
 KEY_MAP_GTK(ArrowUp, GDK_Up)
 KEY_MAP_GTK(ArrowUp, GDK_KP_Up)
+KEY_MAP_QT(ArrowUp, Qt::Key_Up)
 KEY_MAP_ANDROID(ArrowUp, AKEYCODE_DPAD_UP)
 
 // End
@@ -234,6 +260,7 @@ KEY_MAP_WIN(End, VK_END)
 KEY_MAP_COCOA(End, kVK_End)
 KEY_MAP_GTK(End, GDK_End)
 KEY_MAP_GTK(End, GDK_KP_End)
+KEY_MAP_QT(End, Qt::Key_End)
 KEY_MAP_ANDROID(End, AKEYCODE_MOVE_END)
 
 // Home
@@ -241,6 +268,7 @@ KEY_MAP_WIN(Home, VK_HOME)
 KEY_MAP_COCOA(Home, kVK_Home)
 KEY_MAP_GTK(Home, GDK_Home)
 KEY_MAP_GTK(Home, GDK_KP_Home)
+KEY_MAP_QT(Home, Qt::Key_Home)
 KEY_MAP_ANDROID(Home, AKEYCODE_MOVE_HOME)
 
 // PageDown
@@ -248,6 +276,7 @@ KEY_MAP_WIN(PageDown, VK_NEXT)
 KEY_MAP_COCOA(PageDown, kVK_PageDown)
 KEY_MAP_GTK(PageDown, GDK_Page_Down /* same as GDK_Next */)
 KEY_MAP_GTK(PageDown, GDK_KP_Page_Down /* same as GDK_KP_Next */)
+KEY_MAP_QT(PageDown, Qt::Key_PageDown)
 KEY_MAP_ANDROID(PageDown, AKEYCODE_PAGE_DOWN)
 
 // PageUp
@@ -255,6 +284,7 @@ KEY_MAP_WIN(PageUp, VK_PRIOR)
 KEY_MAP_COCOA(PageUp, kVK_PageUp)
 KEY_MAP_GTK(PageUp, GDK_Page_Up /* same as GDK_Prior */)
 KEY_MAP_GTK(PageUp, GDK_KP_Page_Up /* same as GDK_KP_Prior */)
+KEY_MAP_QT(PageUp, Qt::Key_PageUp)
 KEY_MAP_ANDROID(PageUp, AKEYCODE_PAGE_UP)
 
 /******************************************************************************
@@ -264,6 +294,7 @@ KEY_MAP_ANDROID(PageUp, AKEYCODE_PAGE_UP)
 KEY_MAP_WIN(Backspace, VK_BACK)
 KEY_MAP_COCOA(Backspace, kVK_PC_Backspace)
 KEY_MAP_GTK(Backspace, GDK_BackSpace)
+KEY_MAP_QT(Backspace, Qt::Key_Backspace)
 KEY_MAP_ANDROID(Backspace, AKEYCODE_DEL)
 
 // Clear
@@ -271,11 +302,13 @@ KEY_MAP_WIN(Clear, VK_CLEAR)
 KEY_MAP_WIN(Clear, VK_OEM_CLEAR)
 KEY_MAP_COCOA(Clear, kVK_ANSI_KeypadClear)
 KEY_MAP_GTK(Clear, GDK_Clear)
+KEY_MAP_QT(Clear, Qt::Key_Clear)
 KEY_MAP_ANDROID(Clear, AKEYCODE_CLEAR)
 
 // Copy
 KEY_MAP_WIN_CMD(Copy, APPCOMMAND_COPY)
 KEY_MAP_GTK(Copy, GDK_Copy)
+KEY_MAP_QT(Copy, Qt::Key_Copy)
 KEY_MAP_ANDROID(Copy, AKEYCODE_COPY)
 
 // CrSel
@@ -285,6 +318,7 @@ KEY_MAP_GTK(CrSel, GDK_3270_CursorSelect)  // legacy IBM keyboard layout
 // Cut
 KEY_MAP_WIN_CMD(Cut, APPCOMMAND_CUT)
 KEY_MAP_GTK(Cut, GDK_Cut)
+KEY_MAP_QT(Cut, Qt::Key_Cut)
 KEY_MAP_ANDROID(Cut, AKEYCODE_CUT)
 
 // Delete
@@ -292,6 +326,7 @@ KEY_MAP_WIN(Delete, VK_DELETE)
 KEY_MAP_COCOA(Delete, kVK_PC_Delete)
 KEY_MAP_GTK(Delete, GDK_Delete)
 KEY_MAP_GTK(Delete, GDK_KP_Delete)
+KEY_MAP_QT(Delete, Qt::Key_Delete)
 KEY_MAP_ANDROID(Delete, AKEYCODE_FORWARD_DEL)
 
 // EraseEof
@@ -306,11 +341,13 @@ KEY_MAP_GTK(ExSel, GDK_3270_ExSelect)  // legacy IBM keyboard layout
 KEY_MAP_WIN(Insert, VK_INSERT)
 KEY_MAP_GTK(Insert, GDK_Insert)
 KEY_MAP_GTK(Insert, GDK_KP_Insert)
+KEY_MAP_QT(Insert, Qt::Key_Insert)
 KEY_MAP_ANDROID(Insert, AKEYCODE_INSERT)
 
 // Paste
 KEY_MAP_WIN_CMD(Paste, APPCOMMAND_PASTE)
 KEY_MAP_GTK(Paste, GDK_Paste)
+KEY_MAP_QT(Paste, Qt::Key_Paste)
 KEY_MAP_ANDROID(Paste, AKEYCODE_PASTE)
 
 // Redo
@@ -334,22 +371,26 @@ KEY_MAP_GTK(Attn, GDK_3270_Attn)  // legacy IBM keyboard layout
 // Cancel
 KEY_MAP_WIN(Cancel, VK_CANCEL)
 KEY_MAP_GTK(Cancel, GDK_Cancel)
+KEY_MAP_QT(Cancel, Qt::Key_Cancel)
 
 // ContextMenu
 KEY_MAP_WIN(ContextMenu, VK_APPS)
 KEY_MAP_COCOA(ContextMenu, kVK_PC_ContextMenu)
 KEY_MAP_GTK(ContextMenu, GDK_Menu)
+KEY_MAP_QT(ContextMenu, Qt::Key_Menu)
 KEY_MAP_ANDROID(ContextMenu, AKEYCODE_MENU)
 
 // Escape
 KEY_MAP_WIN(Escape, VK_ESCAPE)
 KEY_MAP_COCOA(Escape, kVK_Escape)
 KEY_MAP_GTK(Escape, GDK_Escape)
+KEY_MAP_QT(Escape, Qt::Key_Escape)
 KEY_MAP_ANDROID(Escape, AKEYCODE_ESCAPE)
 
 // Execute
 KEY_MAP_WIN(Execute, VK_EXECUTE)
 KEY_MAP_GTK(Execute, GDK_Execute)
+KEY_MAP_QT(Execute, Qt::Key_Execute)
 
 // Find
 KEY_MAP_WIN_CMD(Find, APPCOMMAND_FIND)
@@ -360,6 +401,7 @@ KEY_MAP_WIN(Help, VK_HELP)
 KEY_MAP_WIN_CMD(Help, APPCOMMAND_HELP)
 KEY_MAP_COCOA(Help, kVK_Help)
 KEY_MAP_GTK(Help, GDK_Help)
+KEY_MAP_QT(Help, Qt::Key_Help)
 KEY_MAP_ANDROID(Help, AKEYCODE_HELP)
 
 // Pause
@@ -367,11 +409,13 @@ KEY_MAP_WIN(Pause, VK_PAUSE)
 KEY_MAP_GTK(Pause, GDK_Pause)
 // Break is typically mapped to Alt+Pause or Ctrl+Pause on GTK.
 KEY_MAP_GTK(Pause, GDK_Break)
+KEY_MAP_QT(Pause, Qt::Key_Pause)
 KEY_MAP_ANDROID(Pause, AKEYCODE_BREAK)
 
 // Play
 KEY_MAP_WIN(Play, VK_PLAY)
 KEY_MAP_GTK(Play, GDK_3270_Play)  // legacy IBM keyboard layout
+KEY_MAP_QT(Play, Qt::Key_Play)
 
 // Select
 KEY_MAP_WIN(Select, VK_SELECT)
@@ -379,10 +423,12 @@ KEY_MAP_GTK(Select, GDK_Select)
 
 // ZoomIn
 KEY_MAP_GTK(ZoomIn, GDK_ZoomIn)
+KEY_MAP_QT(ZoomIn, Qt::Key_ZoomIn)
 KEY_MAP_ANDROID(ZoomIn, AKEYCODE_ZOOM_IN)
 
 // ZoomOut
 KEY_MAP_GTK(ZoomOut, GDK_ZoomOut)
+KEY_MAP_QT(ZoomOut, Qt::Key_ZoomOut)
 KEY_MAP_ANDROID(ZoomOut, AKEYCODE_ZOOM_OUT)
 
 /******************************************************************************
@@ -390,18 +436,22 @@ KEY_MAP_ANDROID(ZoomOut, AKEYCODE_ZOOM_OUT)
  ******************************************************************************/
 // BrightnessDown
 KEY_MAP_GTK(BrightnessDown, GDK_MonBrightnessDown)
+KEY_MAP_QT(BrightnessDown, Qt::Key_MonBrightnessDown)
 KEY_MAP_ANDROID(BrightnessDown, AKEYCODE_BRIGHTNESS_DOWN)
 
 // BrightnessUp
 KEY_MAP_GTK(BrightnessUp, GDK_MonBrightnessUp)
+KEY_MAP_QT(BrightnessUp, Qt::Key_MonBrightnessUp)
 KEY_MAP_ANDROID(BrightnessUp, AKEYCODE_BRIGHTNESS_UP)
 
 // Eject
 KEY_MAP_GTK(Eject, GDK_Eject)
+KEY_MAP_QT(Eject, Qt::Key_Eject)
 KEY_MAP_ANDROID(Eject, AKEYCODE_MEDIA_EJECT)
 
 // LogOff
 KEY_MAP_GTK(LogOff, GDK_LogOff)
+KEY_MAP_QT(LogOff, Qt::Key_LogOff)
 
 // Power
 KEY_MAP_ANDROID(Power, AKEYCODE_POWER)
@@ -409,26 +459,35 @@ KEY_MAP_ANDROID(Power, AKEYCODE_POWER)
 // PowerOff
 KEY_MAP_GTK(PowerOff, GDK_PowerDown)
 KEY_MAP_GTK(PowerOff, GDK_PowerOff)
+KEY_MAP_QT(PowerOff, Qt::Key_PowerDown)
+KEY_MAP_QT(PowerOff, Qt::Key_PowerOff)
 
 // PrintScreen
 KEY_MAP_WIN(PrintScreen, VK_SNAPSHOT)
 KEY_MAP_GTK(PrintScreen, GDK_3270_PrintScreen)
 KEY_MAP_GTK(PrintScreen, GDK_Print)
 KEY_MAP_GTK(PrintScreen, GDK_Sys_Req)
+KEY_MAP_QT(PrintScreen, Qt::Key_Print)
+KEY_MAP_QT(PrintScreen, Qt::Key_SysReq)
 KEY_MAP_ANDROID(PrintScreen, AKEYCODE_SYSRQ)
 
 // Hibernate
 KEY_MAP_GTK(Hibernate, GDK_Hibernate)
+KEY_MAP_QT(Hibernate, Qt::Key_Hibernate)
 
 // Standby
 KEY_MAP_WIN(Standby, VK_SLEEP)
 KEY_MAP_GTK(Standby, GDK_Standby)
 KEY_MAP_GTK(Standby, GDK_Suspend)
 KEY_MAP_GTK(Standby, GDK_Sleep)
+KEY_MAP_QT(Standby, Qt::Key_Standby)
+KEY_MAP_QT(Standby, Qt::Key_Suspend)
+KEY_MAP_QT(Standby, Qt::Key_Sleep)
 KEY_MAP_ANDROID(Standby, AKEYCODE_SLEEP)
 
 // WakeUp
 KEY_MAP_GTK(WakeUp, GDK_WakeUp)
+KEY_MAP_QT(WakeUp, Qt::Key_WakeUp)
 KEY_MAP_ANDROID(WakeUp, AKEYCODE_WAKEUP)
 
 /******************************************************************************
@@ -436,21 +495,27 @@ KEY_MAP_ANDROID(WakeUp, AKEYCODE_WAKEUP)
  ******************************************************************************/
 // AllCandidates
 KEY_MAP_GTK(AllCandidates, GDK_MultipleCandidate)  // OADG 109, Zen Koho
+KEY_MAP_QT(AllCandidates, Qt::Key_MultipleCandidate)
 
 // Alphanumeric
 KEY_MAP_WIN_JPN(Alphanumeric, VK_OEM_ATTN)
 KEY_MAP_GTK(Alphanumeric, GDK_Eisu_Shift)
 KEY_MAP_GTK(Alphanumeric, GDK_Eisu_toggle)
+KEY_MAP_QT(Alphanumeric, Qt::Key_Eisu_Shift)
+KEY_MAP_QT(Alphanumeric, Qt::Key_Eisu_toggle)
 
 // CodeInput
 KEY_MAP_GTK(CodeInput, GDK_Codeinput)  // OADG 109, Kanji Bangou
+KEY_MAP_QT(CodeInput, Qt::Key_Codeinput)
 
 // Compose
 KEY_MAP_GTK(Compose, GDK_Multi_key)  // "Multi Key" is "Compose key" on X
+KEY_MAP_QT(Compose, Qt::Key_Multi_key)
 
 // Convert
 KEY_MAP_WIN(Convert, VK_CONVERT)
 KEY_MAP_GTK(Convert, GDK_Henkan)
+KEY_MAP_QT(Convert, Qt::Key_Henkan)
 KEY_MAP_ANDROID(Convert, AKEYCODE_HENKAN)
 
 // Dead
@@ -499,6 +564,25 @@ KEY_MAP_GTK(Dead, GDK_dead_U)
 KEY_MAP_GTK(Dead, GDK_dead_small_schwa)
 KEY_MAP_GTK(Dead, GDK_dead_capital_schwa)
 KEY_MAP_GTK(Dead, GDK_dead_greek)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Grave)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Acute)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Circumflex)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Tilde)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Macron)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Breve)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Abovedot)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Diaeresis)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Abovering)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Doubleacute)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Caron)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Cedilla)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Ogonek)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Iota)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Voiced_Sound)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Semivoiced_Sound)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Belowdot)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Hook)
+KEY_MAP_QT(Dead, Qt::Key_Dead_Horn)
 
 // FinalMode
 KEY_MAP_WIN(FinalMode, VK_FINAL)
@@ -523,13 +607,16 @@ KEY_MAP_ANDROID(ModeChange, AKEYCODE_SWITCH_CHARSET)
 // NonConvert
 KEY_MAP_WIN(NonConvert, VK_NONCONVERT)
 KEY_MAP_GTK(NonConvert, GDK_Muhenkan)
+KEY_MAP_QT(NonConvert, Qt::Key_Muhenkan)
 KEY_MAP_ANDROID(NonConvert, AKEYCODE_MUHENKAN)
 
 // PreviousCandidate
 KEY_MAP_GTK(PreviousCandidate, GDK_PreviousCandidate)  // OADG 109, Mae Koho
+KEY_MAP_QT(PreviousCandidate, Qt::Key_PreviousCandidate)
 
 // SingleCandidate
 KEY_MAP_GTK(SingleCandidate, GDK_SingleCandidate)
+KEY_MAP_QT(SingleCandidate, Qt::Key_SingleCandidate)
 
 /******************************************************************************
  * Keys specific to Korean keyboards
@@ -553,13 +640,16 @@ KEY_MAP_ANDROID(Eisu, AKEYCODE_EISU)
 // Hankaku
 KEY_MAP_WIN_JPN(Hankaku, VK_OEM_AUTO)
 KEY_MAP_GTK(Hankaku, GDK_Hankaku)
+KEY_MAP_QT(Hankaku, Qt::Key_Hankaku)
 
 // Hiragana
 KEY_MAP_WIN_JPN(Hiragana, VK_OEM_COPY)
 KEY_MAP_GTK(Hiragana, GDK_Hiragana)
+KEY_MAP_QT(Hiragana, Qt::Key_Hiragana)
 
 // HiraganaKatakana
 KEY_MAP_GTK(HiraganaKatakana, GDK_Hiragana_Katakana)
+KEY_MAP_QT(HiraganaKatakana, Qt::Key_Hiragana_Katakana)
 KEY_MAP_ANDROID(HiraganaKatakana, AKEYCODE_KATAKANA_HIRAGANA)
 
 // KanaMode
@@ -569,28 +659,35 @@ KEY_MAP_WIN_JPN(KanaMode, VK_KANA /* same as VK_HANGUL */)
 KEY_MAP_WIN_JPN(KanaMode, VK_ATTN)
 KEY_MAP_GTK(KanaMode, GDK_Kana_Lock)
 KEY_MAP_GTK(KanaMode, GDK_Kana_Shift)
+KEY_MAP_QT(KanaMode, Qt::Key_Kana_Lock)
+KEY_MAP_QT(KanaMode, Qt::Key_Kana_Shift)
 
 // KanjiMode
 KEY_MAP_WIN_JPN(KanjiMode, VK_KANJI /* same as VK_HANJA */)
 KEY_MAP_COCOA(KanjiMode, kVK_JIS_Kana)  // Kana key opens IME
 KEY_MAP_GTK(KanjiMode, GDK_Kanji)       // Typically, Alt + Hankaku/Zenkaku key
+KEY_MAP_QT(KanjiMode, Qt::Key_Kanji)
 // Assuming that KANA key of Android is the Kana key on Mac keyboard.
 KEY_MAP_ANDROID(KanjiMode, AKEYCODE_KANA)
 
 // Katakana
 KEY_MAP_WIN_JPN(Katakana, VK_OEM_FINISH)
 KEY_MAP_GTK(Katakana, GDK_Katakana)
+KEY_MAP_QT(Katakana, Qt::Key_Katakana)
 
 // Romaji
 KEY_MAP_WIN_JPN(Romaji, VK_OEM_BACKTAB)
 KEY_MAP_GTK(Romaji, GDK_Romaji)
+KEY_MAP_QT(Romaji, Qt::Key_Romaji)
 
 // Zenkaku
 KEY_MAP_WIN_JPN(Zenkaku, VK_OEM_ENLW)
 KEY_MAP_GTK(Zenkaku, GDK_Zenkaku)
+KEY_MAP_QT(Zenkaku, Qt::Key_Zenkaku)
 
 // ZenkakuHankaku
 KEY_MAP_GTK(ZenkakuHankaku, GDK_Zenkaku_Hankaku)
+KEY_MAP_QT(ZenkakuHankaku, Qt::Key_Zenkaku_Hankaku)
 KEY_MAP_ANDROID(ZenkakuHankaku, AKEYCODE_ZENKAKU_HANKAKU)
 
 /******************************************************************************
@@ -601,6 +698,7 @@ KEY_MAP_WIN(F1, VK_F1)
 KEY_MAP_COCOA(F1, kVK_F1)
 KEY_MAP_GTK(F1, GDK_F1)
 KEY_MAP_GTK(F1, GDK_KP_F1)
+KEY_MAP_QT(F1, Qt::Key_F1)
 KEY_MAP_ANDROID(F1, AKEYCODE_F1)
 
 // F2
@@ -608,6 +706,7 @@ KEY_MAP_WIN(F2, VK_F2)
 KEY_MAP_COCOA(F2, kVK_F2)
 KEY_MAP_GTK(F2, GDK_F2)
 KEY_MAP_GTK(F2, GDK_KP_F2)
+KEY_MAP_QT(F2, Qt::Key_F2)
 KEY_MAP_ANDROID(F2, AKEYCODE_F2)
 
 // F3
@@ -615,6 +714,7 @@ KEY_MAP_WIN(F3, VK_F3)
 KEY_MAP_COCOA(F3, kVK_F3)
 KEY_MAP_GTK(F3, GDK_F3)
 KEY_MAP_GTK(F3, GDK_KP_F3)
+KEY_MAP_QT(F3, Qt::Key_F3)
 KEY_MAP_ANDROID(F3, AKEYCODE_F3)
 
 // F4
@@ -622,143 +722,176 @@ KEY_MAP_WIN(F4, VK_F4)
 KEY_MAP_COCOA(F4, kVK_F4)
 KEY_MAP_GTK(F4, GDK_F4)
 KEY_MAP_GTK(F4, GDK_KP_F4)
+KEY_MAP_QT(F4, Qt::Key_F4)
 KEY_MAP_ANDROID(F4, AKEYCODE_F4)
 
 // F5
 KEY_MAP_WIN(F5, VK_F5)
 KEY_MAP_COCOA(F5, kVK_F5)
 KEY_MAP_GTK(F5, GDK_F5)
+KEY_MAP_QT(F5, Qt::Key_F5)
 KEY_MAP_ANDROID(F5, AKEYCODE_F5)
 
 // F6
 KEY_MAP_WIN(F6, VK_F6)
 KEY_MAP_COCOA(F6, kVK_F6)
 KEY_MAP_GTK(F6, GDK_F6)
+KEY_MAP_QT(F6, Qt::Key_F6)
 KEY_MAP_ANDROID(F6, AKEYCODE_F6)
 
 // F7
 KEY_MAP_WIN(F7, VK_F7)
 KEY_MAP_COCOA(F7, kVK_F7)
 KEY_MAP_GTK(F7, GDK_F7)
+KEY_MAP_QT(F7, Qt::Key_F7)
 KEY_MAP_ANDROID(F7, AKEYCODE_F7)
 
 // F8
 KEY_MAP_WIN(F8, VK_F8)
 KEY_MAP_COCOA(F8, kVK_F8)
 KEY_MAP_GTK(F8, GDK_F8)
+KEY_MAP_QT(F8, Qt::Key_F8)
 KEY_MAP_ANDROID(F8, AKEYCODE_F8)
 
 // F9
 KEY_MAP_WIN(F9, VK_F9)
 KEY_MAP_COCOA(F9, kVK_F9)
 KEY_MAP_GTK(F9, GDK_F9)
+KEY_MAP_QT(F9, Qt::Key_F9)
 KEY_MAP_ANDROID(F9, AKEYCODE_F9)
 
 // F10
 KEY_MAP_WIN(F10, VK_F10)
 KEY_MAP_COCOA(F10, kVK_F10)
 KEY_MAP_GTK(F10, GDK_F10)
+KEY_MAP_QT(F10, Qt::Key_F10)
 KEY_MAP_ANDROID(F10, AKEYCODE_F10)
 
 // F11
 KEY_MAP_WIN(F11, VK_F11)
 KEY_MAP_COCOA(F11, kVK_F11)
 KEY_MAP_GTK(F11, GDK_F11 /* same as GDK_L1 */)
+KEY_MAP_QT(F11, Qt::Key_F11)
 KEY_MAP_ANDROID(F11, AKEYCODE_F11)
 
 // F12
 KEY_MAP_WIN(F12, VK_F12)
 KEY_MAP_COCOA(F12, kVK_F12)
 KEY_MAP_GTK(F12, GDK_F12 /* same as GDK_L2 */)
+KEY_MAP_QT(F12, Qt::Key_F12)
 KEY_MAP_ANDROID(F12, AKEYCODE_F12)
 
 // F13
 KEY_MAP_WIN(F13, VK_F13)
 KEY_MAP_COCOA(F13, kVK_F13)
 KEY_MAP_GTK(F13, GDK_F13 /* same as GDK_L3 */)
+KEY_MAP_QT(F13, Qt::Key_F13)
 
 // F14
 KEY_MAP_WIN(F14, VK_F14)
 KEY_MAP_COCOA(F14, kVK_F14)
 KEY_MAP_GTK(F14, GDK_F14 /* same as GDK_L4 */)
+KEY_MAP_QT(F14, Qt::Key_F14)
 
 // F15
 KEY_MAP_WIN(F15, VK_F15)
 KEY_MAP_COCOA(F15, kVK_F15)
 KEY_MAP_GTK(F15, GDK_F15 /* same as GDK_L5 */)
+KEY_MAP_QT(F15, Qt::Key_F15)
 
 // F16
 KEY_MAP_WIN(F16, VK_F16)
 KEY_MAP_COCOA(F16, kVK_F16)
 KEY_MAP_GTK(F16, GDK_F16 /* same as GDK_L6 */)
+KEY_MAP_QT(F16, Qt::Key_F16)
 
 // F17
 KEY_MAP_WIN(F17, VK_F17)
 KEY_MAP_COCOA(F17, kVK_F17)
 KEY_MAP_GTK(F17, GDK_F17 /* same as GDK_L7 */)
+KEY_MAP_QT(F17, Qt::Key_F17)
 
 // F18
 KEY_MAP_WIN(F18, VK_F18)
 KEY_MAP_COCOA(F18, kVK_F18)
 KEY_MAP_GTK(F18, GDK_F18 /* same as GDK_L8 */)
+KEY_MAP_QT(F18, Qt::Key_F18)
 
 // F19
 KEY_MAP_WIN(F19, VK_F19)
 KEY_MAP_COCOA(F19, kVK_F19)
 KEY_MAP_GTK(F19, GDK_F19 /* same as GDK_L9 */)
+KEY_MAP_QT(F19, Qt::Key_F19)
 
 // F20
 KEY_MAP_WIN(F20, VK_F20)
 KEY_MAP_GTK(F20, GDK_F20 /* same as GDK_L10 */)
+KEY_MAP_QT(F20, Qt::Key_F20)
 
 // F21
 KEY_MAP_WIN(F21, VK_F21)
 KEY_MAP_GTK(F21, GDK_F21 /* same as GDK_R1 */)
+KEY_MAP_QT(F21, Qt::Key_F21)
 
 // F22
 KEY_MAP_WIN(F22, VK_F22)
 KEY_MAP_GTK(F22, GDK_F22 /* same as GDK_R2 */)
+KEY_MAP_QT(F22, Qt::Key_F22)
 
 // F23
 KEY_MAP_WIN(F23, VK_F23)
 KEY_MAP_GTK(F23, GDK_F23 /* same as GDK_R3 */)
+KEY_MAP_QT(F23, Qt::Key_F23)
 
 // F24
 KEY_MAP_WIN(F24, VK_F24)
 KEY_MAP_GTK(F24, GDK_F24 /* same as GDK_R4 */)
+KEY_MAP_QT(F24, Qt::Key_F24)
 
 // F25
 KEY_MAP_GTK(F25, GDK_F25 /* same as GDK_R5 */)
+KEY_MAP_QT(F25, Qt::Key_F25)
 
 // F26
 KEY_MAP_GTK(F26, GDK_F26 /* same as GDK_R6 */)
+KEY_MAP_QT(F26, Qt::Key_F26)
 
 // F27
 KEY_MAP_GTK(F27, GDK_F27 /* same as GDK_R7 */)
+KEY_MAP_QT(F27, Qt::Key_F27)
 
 // F28
 KEY_MAP_GTK(F28, GDK_F28 /* same as GDK_R8 */)
+KEY_MAP_QT(F28, Qt::Key_F28)
 
 // F29
 KEY_MAP_GTK(F29, GDK_F29 /* same as GDK_R9 */)
+KEY_MAP_QT(F29, Qt::Key_F29)
 
 // F30
 KEY_MAP_GTK(F30, GDK_F30 /* same as GDK_R10 */)
+KEY_MAP_QT(F30, Qt::Key_F30)
 
 // F31
 KEY_MAP_GTK(F31, GDK_F31 /* same as GDK_R11 */)
+KEY_MAP_QT(F31, Qt::Key_F31)
 
 // F32
 KEY_MAP_GTK(F32, GDK_F32 /* same as GDK_R12 */)
+KEY_MAP_QT(F32, Qt::Key_F32)
 
 // F33
 KEY_MAP_GTK(F33, GDK_F33 /* same as GDK_R13 */)
+KEY_MAP_QT(F33, Qt::Key_F33)
 
 // F34
 KEY_MAP_GTK(F34, GDK_F34 /* same as GDK_R14 */)
+KEY_MAP_QT(F34, Qt::Key_F34)
+
 
 // F35
 KEY_MAP_GTK(F35, GDK_F35 /* same as GDK_R15 */)
+KEY_MAP_QT(F35, Qt::Key_F35)
 
 /******************************************************************************
  * Multimedia Keys
@@ -776,65 +909,78 @@ KEY_MAP_ANDROID(ChannelUp, AKEYCODE_CHANNEL_UP)
 //       or window.
 KEY_MAP_WIN_CMD(Close, APPCOMMAND_CLOSE)
 KEY_MAP_GTK(Close, GDK_Close)
+KEY_MAP_QT(Close, Qt::Key_Close)
 
 // MailForward
 KEY_MAP_WIN_CMD(MailForward, APPCOMMAND_FORWARD_MAIL)
 KEY_MAP_GTK(MailForward, GDK_MailForward)
+KEY_MAP_QT(MailForward, Qt::Key_MailForward)
 
 // MailReply
 KEY_MAP_WIN_CMD(MailReply, APPCOMMAND_REPLY_TO_MAIL)
 KEY_MAP_GTK(MailReply, GDK_Reply)
+KEY_MAP_QT(MailReply, Qt::Key_Reply)
 
 // MailSend
 KEY_MAP_WIN_CMD(MailSend, APPCOMMAND_SEND_MAIL)
 KEY_MAP_GTK(MailSend, GDK_Send)
+KEY_MAP_QT(MailSend, Qt::Key_Send)
 
 // MediaFastForward
 KEY_MAP_WIN_CMD(MediaFastForward, APPCOMMAND_MEDIA_FAST_FORWARD)
 KEY_MAP_GTK(MediaFastForward, GDK_AudioForward)
+KEY_MAP_QT(MediaFastForward, Qt::Key_AudioForward)
 KEY_MAP_ANDROID(MediaFastForward, AKEYCODE_MEDIA_FAST_FORWARD)
 
 // MediaPause
 KEY_MAP_WIN_CMD(MediaPause, APPCOMMAND_MEDIA_PAUSE)
 KEY_MAP_GTK(MediaPause, GDK_AudioPause)
+KEY_MAP_QT(MediaPause, Qt::Key_MediaPause)
 KEY_MAP_ANDROID(MediaPause, AKEYCODE_MEDIA_PAUSE)
 
 // MediaPlay
 KEY_MAP_WIN_CMD(MediaPlay, APPCOMMAND_MEDIA_PLAY)
 KEY_MAP_GTK(MediaPlay, GDK_AudioPlay)
+KEY_MAP_QT(MediaPlay, Qt::Key_MediaPlay)
 KEY_MAP_ANDROID(MediaPlay, AKEYCODE_MEDIA_PLAY)
 
 // MediaPlayPause
 KEY_MAP_WIN(MediaPlayPause, VK_MEDIA_PLAY_PAUSE)
 KEY_MAP_WIN_CMD(MediaPlayPause, APPCOMMAND_MEDIA_PLAY_PAUSE)
+KEY_MAP_QT(MediaPlayPause, Qt::Key_MediaTogglePlayPause)
 KEY_MAP_ANDROID(MediaPlayPause, AKEYCODE_MEDIA_PLAY_PAUSE)
 
 // MediaRecord
 KEY_MAP_WIN_CMD(MediaRecord, APPCOMMAND_MEDIA_RECORD)
 KEY_MAP_GTK(MediaRecord, GDK_AudioRecord)
+KEY_MAP_QT(MediaRecord, Qt::Key_MediaRecord)
 KEY_MAP_ANDROID(MediaRecord, AKEYCODE_MEDIA_RECORD)
 
 // MediaRewind
 KEY_MAP_WIN_CMD(MediaRewind, APPCOMMAND_MEDIA_REWIND)
 KEY_MAP_GTK(MediaRewind, GDK_AudioRewind)
+KEY_MAP_QT(MediaRewind, Qt::Key_AudioRewind)
 KEY_MAP_ANDROID(MediaRewind, AKEYCODE_MEDIA_REWIND)
 
 // MediaStop
 KEY_MAP_WIN(MediaStop, VK_MEDIA_STOP)
 KEY_MAP_WIN_CMD(MediaStop, APPCOMMAND_MEDIA_STOP)
 KEY_MAP_GTK(MediaStop, GDK_AudioStop)
+KEY_MAP_QT(MediaStop, Qt::Key_MediaStop)
 KEY_MAP_ANDROID(MediaStop, AKEYCODE_MEDIA_STOP)
 
 // MediaTrackNext
 KEY_MAP_WIN(MediaTrackNext, VK_MEDIA_NEXT_TRACK)
 KEY_MAP_WIN_CMD(MediaTrackNext, APPCOMMAND_MEDIA_NEXTTRACK)
 KEY_MAP_GTK(MediaTrackNext, GDK_AudioNext)
+KEY_MAP_QT(MediaTrackNext, Qt::Key_MediaNext)
 KEY_MAP_ANDROID(MediaTrackNext, AKEYCODE_MEDIA_NEXT)
 
 // MediaTrackPrevious
 KEY_MAP_WIN(MediaTrackPrevious, VK_MEDIA_PREV_TRACK)
 KEY_MAP_WIN_CMD(MediaTrackPrevious, APPCOMMAND_MEDIA_PREVIOUSTRACK)
 KEY_MAP_GTK(MediaTrackPrevious, GDK_AudioPrev)
+KEY_MAP_QT(MediaTrackPrevious, Qt::Key_MediaPrevious)
 KEY_MAP_ANDROID(MediaTrackPrevious, AKEYCODE_MEDIA_PREVIOUS)
 
 // New
@@ -847,29 +993,35 @@ KEY_MAP_GTK(Open, GDK_Open)
 
 // Print
 KEY_MAP_WIN_CMD(Print, APPCOMMAND_PRINT)
+KEY_MAP_QT(Print, Qt::Key_Printer)
 
 // Save
 KEY_MAP_WIN_CMD(Save, APPCOMMAND_SAVE)
 KEY_MAP_GTK(Save, GDK_Save)
+KEY_MAP_QT(Save, Qt::Key_Save)
 
 // SpellCheck
 KEY_MAP_WIN_CMD(SpellCheck, APPCOMMAND_SPELL_CHECK)
 KEY_MAP_GTK(SpellCheck, GDK_Spell)
+KEY_MAP_QT(SpellCheck, Qt::Key_Spell)
 
 /******************************************************************************
  * Audio Keys
  *****************************************************************************/
 // AudioBassBoostDown
 KEY_MAP_WIN_CMD(AudioBassBoostDown, APPCOMMAND_BASS_DOWN)
+KEY_MAP_QT(AudioBassBoostDown, Qt::Key_BassDown)
 
 // AudioBassBoostUp
 KEY_MAP_WIN_CMD(AudioBassBoostUp, APPCOMMAND_BASS_UP)
+KEY_MAP_QT(AudioBassBoostUp, Qt::Key_BassUp)
 
 // AudioVolumeDown
 KEY_MAP_WIN(AudioVolumeDown, VK_VOLUME_DOWN)
 KEY_MAP_WIN_CMD(AudioVolumeDown, APPCOMMAND_VOLUME_DOWN)
 KEY_MAP_COCOA(AudioVolumeDown, kVK_VolumeDown)
 KEY_MAP_GTK(AudioVolumeDown, GDK_AudioLowerVolume)
+KEY_MAP_QT(AudioVolumeDown, Qt::Key_VolumeDown)
 KEY_MAP_ANDROID(AudioVolumeDown, AKEYCODE_VOLUME_DOWN)
 
 // AudioVolumeUp
@@ -877,6 +1029,7 @@ KEY_MAP_WIN(AudioVolumeUp, VK_VOLUME_UP)
 KEY_MAP_WIN_CMD(AudioVolumeUp, APPCOMMAND_VOLUME_UP)
 KEY_MAP_COCOA(AudioVolumeUp, kVK_VolumeUp)
 KEY_MAP_GTK(AudioVolumeUp, GDK_AudioRaiseVolume)
+KEY_MAP_QT(AudioVolumeUp, Qt::Key_VolumeUp)
 KEY_MAP_ANDROID(AudioVolumeUp, AKEYCODE_VOLUME_UP)
 
 // AudioVolumeMute
@@ -884,6 +1037,7 @@ KEY_MAP_WIN(AudioVolumeMute, VK_VOLUME_MUTE)
 KEY_MAP_WIN_CMD(AudioVolumeMute, APPCOMMAND_VOLUME_MUTE)
 KEY_MAP_COCOA(AudioVolumeMute, kVK_Mute)
 KEY_MAP_GTK(AudioVolumeMute, GDK_AudioMute)
+KEY_MAP_QT(AudioVolumeMute, Qt::Key_VolumeMute)
 KEY_MAP_ANDROID(AudioVolumeMute, AKEYCODE_VOLUME_MUTE)
 
 // MicrophoneVolumeMute
@@ -894,10 +1048,12 @@ KEY_MAP_ANDROID(MicrophoneVolumeMute, AKEYCODE_MUTE)
  ******************************************************************************/
 // LaunchCalculator
 KEY_MAP_GTK(LaunchCalculator, GDK_Calculator)
+KEY_MAP_QT(LaunchCalculator, Qt::Key_Calculator)
 KEY_MAP_ANDROID(LaunchCalculator, AKEYCODE_CALCULATOR)
 
 // LaunchCalendar
 KEY_MAP_GTK(LaunchCalendar, GDK_Calendar)
+KEY_MAP_QT(LaunchCalendar, Qt::Key_Calendar)
 KEY_MAP_ANDROID(LaunchCalendar, AKEYCODE_CALENDAR)
 
 // LaunchContacts
@@ -907,6 +1063,7 @@ KEY_MAP_ANDROID(LaunchContacts, AKEYCODE_CONTACTS)
 KEY_MAP_WIN(LaunchMail, VK_LAUNCH_MAIL)
 KEY_MAP_WIN_CMD(LaunchMail, APPCOMMAND_LAUNCH_MAIL)
 KEY_MAP_GTK(LaunchMail, GDK_Mail)
+KEY_MAP_QT(LaunchMail, Qt::Key_LaunchMail)
 KEY_MAP_ANDROID(LaunchMail, AKEYCODE_ENVELOPE)
 
 // LaunchMediaPlayer
@@ -917,86 +1074,114 @@ KEY_MAP_WIN_CMD(LaunchMediaPlayer, APPCOMMAND_LAUNCH_MEDIA_SELECT)
 KEY_MAP_GTK(LaunchMediaPlayer, GDK_CD)
 KEY_MAP_GTK(LaunchMediaPlayer, GDK_Video)
 KEY_MAP_GTK(LaunchMediaPlayer, GDK_AudioMedia)
+KEY_MAP_QT(LaunchMediaPlayer, Qt::Key_LaunchMedia)
+KEY_MAP_QT(LaunchMediaPlayer, Qt::Key_CD)
+KEY_MAP_QT(LaunchMediaPlayer, Qt::Key_Video)
 
 // LaunchMusicPlayer
 KEY_MAP_GTK(LaunchMusicPlayer, GDK_Music)
+KEY_MAP_QT(LaunchMusicPlayer, Qt::Key_Music)
 KEY_MAP_ANDROID(LaunchMusicPlayer, AKEYCODE_MUSIC)
 
 // LaunchMyComputer
 KEY_MAP_GTK(LaunchMyComputer, GDK_MyComputer)
 KEY_MAP_GTK(LaunchMyComputer, GDK_Explorer)
+KEY_MAP_QT(LaunchMyComputer, Qt::Key_Explorer)
 
 // LaunchScreenSaver
 KEY_MAP_GTK(LaunchScreenSaver, GDK_ScreenSaver)
+KEY_MAP_QT(LaunchScreenSaver, Qt::Key_ScreenSaver)
 
 // LaunchSpreadsheet
 KEY_MAP_GTK(LaunchSpreadsheet, GDK_Excel)
+KEY_MAP_QT(LaunchSpreadsheet, Qt::Key_Excel)
 
 // LaunchWebBrowser
 KEY_MAP_GTK(LaunchWebBrowser, GDK_WWW)
+KEY_MAP_QT(LaunchWebBrowser, Qt::Key_WWW)
 KEY_MAP_ANDROID(LaunchWebBrowser, AKEYCODE_EXPLORER)
 
 // LaunchWebCam
 KEY_MAP_GTK(LaunchWebCam, GDK_WebCam)
+KEY_MAP_QT(LaunchWebCam, Qt::Key_WebCam)
 
 // LaunchWordProcessor
 KEY_MAP_GTK(LaunchWordProcessor, GDK_Word)
+KEY_MAP_QT(LaunchWordProcessor, Qt::Key_Word)
 
 // LaunchApplication1
 KEY_MAP_WIN(LaunchApplication1, VK_LAUNCH_APP1)
 KEY_MAP_WIN_CMD(LaunchApplication1, APPCOMMAND_LAUNCH_APP1)
 KEY_MAP_GTK(LaunchApplication1, GDK_Launch0)
+KEY_MAP_QT(LaunchApplication1, Qt::Key_Launch0)
 
 // LaunchApplication2
 KEY_MAP_WIN(LaunchApplication2, VK_LAUNCH_APP2)
 KEY_MAP_WIN_CMD(LaunchApplication2, APPCOMMAND_LAUNCH_APP2)
 KEY_MAP_GTK(LaunchApplication2, GDK_Launch1)
+KEY_MAP_QT(LaunchApplication2, Qt::Key_Launch1)
 
 // LaunchApplication3
 KEY_MAP_GTK(LaunchApplication3, GDK_Launch2)
+KEY_MAP_QT(LaunchApplication3, Qt::Key_Launch2)
 
 // LaunchApplication4
 KEY_MAP_GTK(LaunchApplication4, GDK_Launch3)
+KEY_MAP_QT(LaunchApplication4, Qt::Key_Launch3)
 
 // LaunchApplication5
 KEY_MAP_GTK(LaunchApplication5, GDK_Launch4)
+KEY_MAP_QT(LaunchApplication5, Qt::Key_Launch4)
 
 // LaunchApplication6
 KEY_MAP_GTK(LaunchApplication6, GDK_Launch5)
+KEY_MAP_QT(LaunchApplication6, Qt::Key_Launch5)
 
 // LaunchApplication7
 KEY_MAP_GTK(LaunchApplication7, GDK_Launch6)
+KEY_MAP_QT(LaunchApplication7, Qt::Key_Launch6)
 
 // LaunchApplication8
 KEY_MAP_GTK(LaunchApplication8, GDK_Launch7)
+KEY_MAP_QT(LaunchApplication8, Qt::Key_Launch7)
 
 // LaunchApplication9
 KEY_MAP_GTK(LaunchApplication9, GDK_Launch8)
+KEY_MAP_QT(LaunchApplication9, Qt::Key_Launch8)
 
 // LaunchApplication10
 KEY_MAP_GTK(LaunchApplication10, GDK_Launch9)
+KEY_MAP_QT(LaunchApplication10, Qt::Key_Launch9)
 
 // LaunchApplication11
 KEY_MAP_GTK(LaunchApplication11, GDK_LaunchA)
+KEY_MAP_QT(LaunchApplication11, Qt::Key_LaunchA)
 
 // LaunchApplication12
 KEY_MAP_GTK(LaunchApplication12, GDK_LaunchB)
+KEY_MAP_QT(LaunchApplication12, Qt::Key_LaunchB)
 
 // LaunchApplication13
 KEY_MAP_GTK(LaunchApplication13, GDK_LaunchC)
+KEY_MAP_QT(LaunchApplication13, Qt::Key_LaunchC)
 
 // LaunchApplication14
 KEY_MAP_GTK(LaunchApplication14, GDK_LaunchD)
+KEY_MAP_QT(LaunchApplication14, Qt::Key_LaunchD)
 
 // LaunchApplication15
 KEY_MAP_GTK(LaunchApplication15, GDK_LaunchE)
+KEY_MAP_QT(LaunchApplication15, Qt::Key_LaunchE)
 
 // LaunchApplication16
 KEY_MAP_GTK(LaunchApplication16, GDK_LaunchF)
+KEY_MAP_QT(LaunchApplication16, Qt::Key_LaunchF)
 
 // LaunchApplication17
+KEY_MAP_QT(LaunchApplication17, Qt::Key_LaunchG)
 
 // LaunchApplication18
+KEY_MAP_QT(LaunchApplication18, Qt::Key_LaunchH)
 
 /******************************************************************************
  * Browser Keys
@@ -1005,39 +1190,48 @@ KEY_MAP_GTK(LaunchApplication16, GDK_LaunchF)
 KEY_MAP_WIN(BrowserBack, VK_BROWSER_BACK)
 KEY_MAP_WIN_CMD(BrowserBack, APPCOMMAND_BROWSER_BACKWARD)
 KEY_MAP_GTK(BrowserBack, GDK_Back)
+KEY_MAP_QT(BrowserBack, Qt::Key_Back)
 
 // BrowserFavorites
 KEY_MAP_WIN(BrowserFavorites, VK_BROWSER_FAVORITES)
 KEY_MAP_WIN_CMD(BrowserFavorites, APPCOMMAND_BROWSER_FAVORITES)
+KEY_MAP_QT(BrowserFavorites, Qt::Key_Favorites)
 KEY_MAP_ANDROID(BrowserFavorites, AKEYCODE_BOOKMARK)
 
 // BrowserForward
 KEY_MAP_WIN(BrowserForward, VK_BROWSER_FORWARD)
 KEY_MAP_WIN_CMD(BrowserForward, APPCOMMAND_BROWSER_FORWARD)
 KEY_MAP_GTK(BrowserForward, GDK_Forward)
+KEY_MAP_QT(BrowserForward, Qt::Key_Forward)
 KEY_MAP_ANDROID(BrowserForward, AKEYCODE_FORWARD)
 
 // BrowserHome
 KEY_MAP_WIN(BrowserHome, VK_BROWSER_HOME)
 KEY_MAP_WIN_CMD(BrowserHome, APPCOMMAND_BROWSER_HOME)
 KEY_MAP_GTK(BrowserHome, GDK_HomePage)
+KEY_MAP_QT(BrowserHome, Qt::Key_HomePage)
 
 // BrowserRefresh
 KEY_MAP_WIN(BrowserRefresh, VK_BROWSER_REFRESH)
 KEY_MAP_WIN_CMD(BrowserRefresh, APPCOMMAND_BROWSER_REFRESH)
 KEY_MAP_GTK(BrowserRefresh, GDK_Refresh)
 KEY_MAP_GTK(BrowserRefresh, GDK_Reload)
+KEY_MAP_QT(BrowserRefresh, Qt::Key_Refresh)
+KEY_MAP_QT(BrowserRefresh, Qt::Key_Reload)
+
 
 // BrowserSearch
 KEY_MAP_WIN(BrowserSearch, VK_BROWSER_SEARCH)
 KEY_MAP_WIN_CMD(BrowserSearch, APPCOMMAND_BROWSER_SEARCH)
 KEY_MAP_GTK(BrowserSearch, GDK_Search)
+KEY_MAP_QT(BrowserSearch, Qt::Key_Search)
 KEY_MAP_ANDROID(BrowserSearch, AKEYCODE_SEARCH)
 
 // BrowserStop
 KEY_MAP_WIN(BrowserStop, VK_BROWSER_STOP)
 KEY_MAP_WIN_CMD(BrowserStop, APPCOMMAND_BROWSER_STOP)
 KEY_MAP_GTK(BrowserStop, GDK_Stop)
+KEY_MAP_QT(BrowserStop, Qt::Key_Stop)
 
 /******************************************************************************
  * Mobile Phone Keys
@@ -1049,9 +1243,11 @@ KEY_MAP_ANDROID(AppSwitch, AKEYCODE_APP_SWITCH)
 KEY_MAP_ANDROID(Call, AKEYCODE_CALL)
 
 // Camera
+KEY_MAP_QT(Camera, Qt::Key_Camera)
 KEY_MAP_ANDROID(Camera, AKEYCODE_CAMERA)
 
 // CameraFocus
+KEY_MAP_QT(CameraFocus, Qt::Key_CameraFocus)
 KEY_MAP_ANDROID_EXCEPT_B2G(CameraFocus, AKEYCODE_FOCUS)
 
 // EndCall
@@ -1175,18 +1371,22 @@ KEY_MAP_ANDROID(AVRPower, AKEYCODE_AVR_POWER)
 
 // ColorF0Red
 KEY_MAP_GTK(ColorF0Red, GDK_Red)
+KEY_MAP_QT(ColorF0Red, Qt::Key_Red)
 KEY_MAP_ANDROID(ColorF0Red, AKEYCODE_PROG_RED)
 
 // ColorF1Green
 KEY_MAP_GTK(ColorF1Green, GDK_Green)
+KEY_MAP_QT(ColorF1Green, Qt::Key_Green)
 KEY_MAP_ANDROID(ColorF1Green, AKEYCODE_PROG_GREEN)
 
 // ColorF2Yellow
 KEY_MAP_GTK(ColorF2Yellow, GDK_Yellow)
+KEY_MAP_QT(ColorF2Yellow, Qt::Key_Yellow)
 KEY_MAP_ANDROID(ColorF2Yellow, AKEYCODE_PROG_YELLOW)
 
 // ColorF3Blue
 KEY_MAP_GTK(ColorF3Blue, GDK_Blue)
+KEY_MAP_QT(ColorF3Blue, Qt::Key_Blue)
 KEY_MAP_ANDROID(ColorF3Blue, AKEYCODE_PROG_BLUE)
 
 // ClosedCaptionToggle
@@ -1194,6 +1394,7 @@ KEY_MAP_ANDROID(ClosedCaptionToggle, AKEYCODE_CAPTIONS)
 
 // Dimmer
 KEY_MAP_GTK(Dimmer, GDK_BrightnessAdjust)
+KEY_MAP_QT(Dimmer, Qt::Key_BrightnessAdjust)
 
 // DVR
 KEY_MAP_ANDROID(DVR, AKEYCODE_DVR)
@@ -1209,6 +1410,7 @@ KEY_MAP_ANDROID(MediaAudioTrack, AKEYCODE_MEDIA_AUDIO_TRACK)
 
 // MediaLast
 KEY_MAP_ANDROID(MediaLast, AKEYCODE_LAST_CHANNEL)
+KEY_MAP_QT(MediaLast, Qt::Key_MediaLast)
 
 // MediaTopMenu
 KEY_MAP_ANDROID(MediaTopMenu, AKEYCODE_MEDIA_TOP_MENU)
@@ -1245,6 +1447,7 @@ KEY_MAP_ANDROID(PinPToggle, AKEYCODE_WINDOW)
 
 // RandomToggle
 KEY_MAP_GTK(RandomToggle, GDK_AudioRandomPlay)
+KEY_MAP_QT(RandomToggle, Qt::Key_AudioRandomPlay)
 
 // Settings
 KEY_MAP_ANDROID(Settings, AKEYCODE_SETTINGS)
@@ -1257,6 +1460,7 @@ KEY_MAP_ANDROID(STBPower, AKEYCODE_STB_POWER)
 
 // Subtitle
 KEY_MAP_GTK(Subtitle, GDK_Subtitle)
+KEY_MAP_QT(Subtitle, Qt::Key_Subtitle)
 
 // Teletext
 KEY_MAP_ANDROID(Teletext, AKEYCODE_TV_TELETEXT)
@@ -1266,6 +1470,7 @@ KEY_MAP_GTK(VideoModeNext, GDK_Next_VMode)
 
 // ZoomToggle
 KEY_MAP_WIN(ZoomToggle, VK_ZOOM)
+KEY_MAP_QT(ZoomToggle, Qt::Key_Zoom)
 KEY_MAP_ANDROID(ZoomToggle, AKEYCODE_TV_ZOOM_MODE)
 
 /******************************************************************************
@@ -1284,6 +1489,7 @@ KEY_MAP_ANDROID(SoftRight, AKEYCODE_SOFT_RIGHT)
 #undef KEY_MAP_WIN_CMD
 #undef KEY_MAP_COCOA
 #undef KEY_MAP_GTK
+#undef KEY_MAP_QT
 #undef KEY_MAP_ANDROID
 #undef KEY_MAP_ANDROID_EXCEPT_B2G
 #undef KEY_MAP_B2G
diff --git a/widget/headless/HeadlessWidget.h b/widget/headless/HeadlessWidget.h
index 02f7ec4d674f..b8eb42be3af0 100644
--- a/widget/headless/HeadlessWidget.h
+++ b/widget/headless/HeadlessWidget.h
@@ -18,6 +18,12 @@
 #define MOZ_HEADLESS_MOUSE_UP 7    // GDK_BUTTON_RELEASE
 #define MOZ_HEADLESS_SCROLL_MULTIPLIER 3
 #define MOZ_HEADLESS_SCROLL_DELTA_MODE nsIDOMWheelEvent::DOM_DELTA_LINE
+#elif defined(MOZ_WIDGET_QT)
+#define MOZ_HEADLESS_MOUSE_MOVE 5  // QEvent::MouseMove
+#define MOZ_HEADLESS_MOUSE_DOWN 2  // QEvent::MouseButtonPress
+#define MOZ_HEADLESS_MOUSE_UP 3    // QEvent::MouseButtonRelease
+#define MOZ_HEADLESS_SCROLL_MULTIPLIER 1
+#define MOZ_HEADLESS_SCROLL_DELTA_MODE nsIDOMWheelEvent::DOM_DELTA_LINE
 #elif defined(XP_WIN)
 #define MOZ_HEADLESS_MOUSE_MOVE 1  // MOUSEEVENTF_MOVE
 #define MOZ_HEADLESS_MOUSE_DOWN 2  // MOUSEEVENTF_LEFTDOWN
diff --git a/widget/moz.build b/widget/moz.build
index b79d075f0dfe..09d9eb4f25cf 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -36,7 +36,7 @@ with Files("*FontRange*"):
 
 toolkit = CONFIG['MOZ_WIDGET_TOOLKIT']
 
-if toolkit in ('cocoa', 'android', 'uikit'):
+if toolkit in ('cocoa', 'qt', 'android', 'uikit'):
     DIRS += [toolkit]
 
 if toolkit == 'windows':
@@ -259,13 +259,13 @@ if toolkit in ('cocoa', 'windows'):
         'nsBaseClipboard.cpp',
     ]
 
-if toolkit in {'gtk3', 'cocoa', 'windows',
+if toolkit in {'qt', 'gtk3', 'cocoa', 'windows',
                'android', 'uikit'}:
     UNIFIED_SOURCES += [
         'nsBaseFilePicker.cpp',
     ]
 
-if toolkit in ('gtk3', 'windows', 'cocoa', 'android'):
+if toolkit in ('qt', 'gtk3', 'windows', 'cocoa', 'android'):
     UNIFIED_SOURCES += [
         'nsNativeTheme.cpp',
     ]
diff --git a/widget/qt/GfxInfo.cpp b/widget/qt/GfxInfo.cpp
new file mode 100644
index 000000000000..64732917f2dc
--- /dev/null
+++ b/widget/qt/GfxInfo.cpp
@@ -0,0 +1,194 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "GfxInfo.h"
+
+using namespace mozilla::widget;
+
+/* GetD2DEnabled and GetDwriteEnabled shouldn't be called until after gfxPlatform initialization
+ * has occurred because they depend on it for information. (See bug 591561) */
+nsresult
+GfxInfo::GetD2DEnabled(bool *aEnabled)
+{
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+GfxInfo::GetDWriteEnabled(bool *aEnabled)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
+{
+  aAdapterDescription.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDescription2(nsAString & aAdapterDescription)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
+{
+  aAdapterRAM.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterRAM2(nsAString & aAdapterRAM)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
+{
+  aAdapterDriver.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriver2(nsAString & aAdapterDriver)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
+{
+  aAdapterDriverVersion.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
+{
+  aAdapterDriverDate.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDriverDate2(nsAString & aAdapterDriverDate)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterVendorID(nsAString & aAdapterVendorID)
+{
+  aAdapterVendorID.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterVendorID2(nsAString & aAdapterVendorID)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDeviceID(nsAString & aAdapterDeviceID)
+{
+  aAdapterDeviceID.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterDeviceID2(nsAString & aAdapterDeviceID)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterSubsysID(nsAString & aAdapterSubsysID)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetAdapterSubsysID2(nsAString & aAdapterSubsysID)
+{
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+GfxInfo::GetIsGPU2Active(bool* aIsGPU2Active)
+{
+  return NS_ERROR_FAILURE;
+}
+
+const nsTArray<GfxDriverInfo>&
+GfxInfo::GetGfxDriverInfo()
+{
+  return *mDriverInfo;
+}
+
+uint32_t GfxInfo::OperatingSystemVersion()
+{
+  return 0;
+}
+
+nsresult
+GfxInfo::GetFeatureStatusImpl(int32_t /*aFeature*/, 
+                              int32_t *aStatus, 
+                              nsAString & /*aSuggestedDriverVersion*/,
+                              const nsTArray<GfxDriverInfo>& /*aDriverInfo*/, 
+                              nsACString & /*aFailureId*/,
+                              OperatingSystem* /*aOS*/ /* = nullptr */)
+{
+  NS_ENSURE_ARG_POINTER(aStatus);
+  *aStatus = nsIGfxInfo::FEATURE_STATUS_OK;
+
+  return NS_OK;
+}
+
+#ifdef DEBUG
+
+// Implement nsIGfxInfoDebug
+
+NS_IMETHODIMP GfxInfo::SpoofVendorID(const nsAString &)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP GfxInfo::SpoofDeviceID(const nsAString &)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP GfxInfo::SpoofDriverVersion(const nsAString &)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP GfxInfo::SpoofOSVersion(uint32_t)
+{
+  return NS_OK;
+}
+
+#endif
diff --git a/widget/qt/GfxInfo.h b/widget/qt/GfxInfo.h
new file mode 100644
index 000000000000..362ce057a1dc
--- /dev/null
+++ b/widget/qt/GfxInfo.h
@@ -0,0 +1,66 @@
+/* vim: se cin sw=2 ts=2 et : */
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __mozilla_widget_GfxInfo_h__
+#define __mozilla_widget_GfxInfo_h__
+
+#include "GfxInfoBase.h"
+#include "GfxDriverInfo.h"
+
+#include "nsString.h"
+
+namespace mozilla {
+namespace widget {
+
+class GfxInfo : public GfxInfoBase
+{
+public:
+  // We only declare the subset of nsIGfxInfo that we actually implement. The
+  // rest is brought forward from GfxInfoBase.
+  NS_IMETHOD GetD2DEnabled(bool *aD2DEnabled) override;
+  NS_IMETHOD GetDWriteEnabled(bool *aDWriteEnabled) override;
+  NS_IMETHOD GetDWriteVersion(nsAString & aDwriteVersion) override;
+  NS_IMETHOD GetCleartypeParameters(nsAString & aCleartypeParams) override;
+  NS_IMETHOD GetAdapterDescription(nsAString & aAdapterDescription) override;
+  NS_IMETHOD GetAdapterDriver(nsAString & aAdapterDriver) override;
+  NS_IMETHOD GetAdapterVendorID(nsAString & aAdapterVendorID) override;
+  NS_IMETHOD GetAdapterDeviceID(nsAString & aAdapterDeviceID) override;
+  NS_IMETHOD GetAdapterSubsysID(nsAString & aAdapterSubsysID) override;
+  NS_IMETHOD GetAdapterRAM(nsAString & aAdapterRAM) override;
+  NS_IMETHOD GetAdapterDriverVersion(nsAString & aAdapterDriverVersion) override;
+  NS_IMETHOD GetAdapterDriverDate(nsAString & aAdapterDriverDate) override;
+  NS_IMETHOD GetAdapterDescription2(nsAString & aAdapterDescription) override;
+  NS_IMETHOD GetAdapterDriver2(nsAString & aAdapterDriver) override;
+  NS_IMETHOD GetAdapterVendorID2(nsAString & aAdapterVendorID) override;
+  NS_IMETHOD GetAdapterDeviceID2(nsAString & aAdapterDeviceID) override;
+  NS_IMETHOD GetAdapterSubsysID2(nsAString & aAdapterSubsysID) override;
+  NS_IMETHOD GetAdapterRAM2(nsAString & aAdapterRAM) override;
+  NS_IMETHOD GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion) override;
+  NS_IMETHOD GetAdapterDriverDate2(nsAString & aAdapterDriverDate) override;
+  NS_IMETHOD GetIsGPU2Active(bool *aIsGPU2Active) override;
+  using GfxInfoBase::GetFeatureStatus;
+  using GfxInfoBase::GetFeatureSuggestedDriverVersion;
+
+  virtual uint32_t OperatingSystemVersion() override;
+
+#ifdef DEBUG
+  NS_DECL_NSIGFXINFODEBUG
+#endif
+
+protected:
+  virtual nsresult GetFeatureStatusImpl(int32_t aFeature,
+                                        int32_t *aStatus,
+                                        nsAString & aSuggestedDriverVersion,
+                                        const nsTArray<GfxDriverInfo>& aDriverInfo, nsACString &aFailureId,
+                                        OperatingSystem* aOS = nullptr) override;
+  virtual const nsTArray<GfxDriverInfo>& GetGfxDriverInfo() override;
+};
+
+} // namespace widget
+} // namespace mozilla
+
+#endif /* __mozilla_widget_GfxInfo_h__ */
diff --git a/widget/qt/moz.build b/widget/qt/moz.build
new file mode 100644
index 000000000000..8003864d9559
--- /dev/null
+++ b/widget/qt/moz.build
@@ -0,0 +1,66 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+SOURCES += [
+    '!moc_mozqwidget.cpp',
+    '!moc_nsAppShell.cpp',
+    'mozqwidget.cpp',
+    'nsAppShell.cpp',
+    'nsBidiKeyboard.cpp',
+    'nsClipboard.cpp',
+    'nsIdleServiceQt.cpp',
+    'nsLookAndFeel.cpp',
+    'nsQtKeyUtils.cpp',
+    'nsScreenManagerQt.cpp',
+    'nsScreenQt.cpp',
+    'nsWidgetFactory.cpp',
+    'nsWindow.cpp',
+]
+
+
+if CONFIG['NS_PRINTING']:
+    SOURCES += [
+        'nsDeviceContextSpecQt.cpp',
+        'nsPrintDialogQt.cpp',
+        'nsPrintOptionsQt.cpp',
+        'nsPrintSettingsQt.cpp',
+    ]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+FINAL_LIBRARY = 'xul'
+
+LOCAL_INCLUDES += [
+    '/widget',
+]
+
+if CONFIG['MOZ_X11']:
+    LOCAL_INCLUDES += [
+        '../x11',
+    ]
+else:
+    SOURCES += [
+        'GfxInfo.cpp',
+    ]
+
+
+#DEFINES['DEBUG_WIDGETS'] = True
+
+if CONFIG['OS_ARCH'] == 'Linux':
+    DEFINES['_BSD_SOURCE'] = True
+
+if CONFIG['OS_ARCH'] == 'SunOS' and not CONFIG['GNU_CC']:
+    # When using Sun's WorkShop compiler, including
+    # /wherever/workshop-5.0/SC5.0/include/CC/std/time.h
+    # causes most of these compiles to fail with:
+    # line 29: Error: Multiple declaration for std::tm.
+    # So, this gets around the problem.
+    DEFINES['_TIME_H'] = 1
+
+CXXFLAGS += CONFIG['MOZ_QT_CFLAGS']
+CXXFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
+CFLAGS += CONFIG['MOZ_QT_CFLAGS']
+CFLAGS += CONFIG['MOZ_CAIRO_CFLAGS']
diff --git a/widget/qt/mozqwidget.cpp b/widget/qt/mozqwidget.cpp
new file mode 100644
index 000000000000..944cc2c08d3d
--- /dev/null
+++ b/widget/qt/mozqwidget.cpp
@@ -0,0 +1,231 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set ts=4 et sw=4 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QtCore/QCoreApplication>
+#include <QtGui/QResizeEvent>
+
+#include "mozqwidget.h"
+#include "nsWindow.h"
+
+using namespace mozilla::widget;
+
+MozQWidget::MozQWidget(nsWindow* aReceiver, QWindow* aParent)
+  : QWindow(aParent)
+  , mReceiver(aReceiver)
+  , mUpdatePending(false)
+{
+    mWindowType = mReceiver->WindowType();
+}
+
+MozQWidget::~MozQWidget()
+{
+}
+
+void MozQWidget::render(QPainter* painter)
+{
+    Q_UNUSED(painter);
+}
+
+void MozQWidget::renderLater()
+{
+    if (!isExposed() || eWindowType_child != mWindowType || !isVisible()) {
+        return;
+    }
+
+    if (!mUpdatePending) {
+        mUpdatePending = true;
+        QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest));
+    }
+}
+
+void MozQWidget::renderNow()
+{
+    if (!isExposed() || eWindowType_child != mWindowType || !isVisible()) {
+        return;
+    }
+
+    mReceiver->OnPaint();
+}
+
+bool MozQWidget::event(QEvent* event)
+{
+    switch (event->type()) {
+    case QEvent::UpdateRequest:
+        mUpdatePending = false;
+        renderNow();
+        return true;
+    default:
+        return QWindow::event(event);
+    }
+}
+
+void MozQWidget::exposeEvent(QExposeEvent* event)
+{
+    Q_UNUSED(event);
+    if (!isExposed() || eWindowType_child != mWindowType || !isVisible()) {
+        return;
+    }
+    LOG(("MozQWidget::%s [%p] flags:%x\n", __FUNCTION__, (void *)this, flags()));
+    renderNow();
+
+}
+
+void MozQWidget::resizeEvent(QResizeEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->resizeEvent(event);
+    QWindow::resizeEvent(event);
+}
+
+void MozQWidget::focusInEvent(QFocusEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->focusInEvent(event);
+    QWindow::focusInEvent(event);
+}
+
+void MozQWidget::focusOutEvent(QFocusEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->focusOutEvent(event);
+    QWindow::focusOutEvent(event);
+}
+
+void MozQWidget::hideEvent(QHideEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->hideEvent(event);
+    QWindow::hideEvent(event);
+}
+
+void MozQWidget::keyPressEvent(QKeyEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->keyPressEvent(event);
+    QWindow::keyPressEvent(event);
+}
+
+void MozQWidget::keyReleaseEvent(QKeyEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->keyReleaseEvent(event);
+    QWindow::keyReleaseEvent(event);
+}
+
+void MozQWidget::mouseDoubleClickEvent(QMouseEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->mouseDoubleClickEvent(event);
+    QWindow::mouseDoubleClickEvent(event);
+}
+
+void MozQWidget::mouseMoveEvent(QMouseEvent* event)
+{
+    mReceiver->mouseMoveEvent(event);
+    QWindow::mouseMoveEvent(event);
+}
+
+void MozQWidget::mousePressEvent(QMouseEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->mousePressEvent(event);
+    QWindow::mousePressEvent(event);
+}
+
+void MozQWidget::mouseReleaseEvent(QMouseEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->mouseReleaseEvent(event);
+    QWindow::mouseReleaseEvent(event);
+}
+
+void MozQWidget::moveEvent(QMoveEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->moveEvent(event);
+    QWindow::moveEvent(event);
+}
+
+void MozQWidget::showEvent(QShowEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->showEvent(event);
+    QWindow::showEvent(event);
+}
+
+void MozQWidget::wheelEvent(QWheelEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    mReceiver->wheelEvent(event);
+    QWindow::wheelEvent(event);
+}
+
+void MozQWidget::tabletEvent(QTabletEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    QWindow::tabletEvent(event);
+}
+
+void MozQWidget::touchEvent(QTouchEvent* event)
+{
+    LOG(("MozQWidget::%s [%p]\n", __FUNCTION__, (void *)this));
+    QWindow::touchEvent(event);
+}
+
+void MozQWidget::SetCursor(nsCursor aCursor)
+{
+    Qt::CursorShape cursor = Qt::ArrowCursor;
+    switch(aCursor) {
+    case eCursor_standard:
+        cursor = Qt::ArrowCursor;
+        break;
+    case eCursor_wait:
+        cursor = Qt::WaitCursor;
+        break;
+    case eCursor_select:
+        cursor = Qt::IBeamCursor;
+        break;
+    case eCursor_hyperlink:
+        cursor = Qt::PointingHandCursor;
+        break;
+    case eCursor_ew_resize:
+        cursor = Qt::SplitHCursor;
+        break;
+    case eCursor_ns_resize:
+        cursor = Qt::SplitVCursor;
+        break;
+    case eCursor_nw_resize:
+    case eCursor_se_resize:
+        cursor = Qt::SizeBDiagCursor;
+        break;
+    case eCursor_ne_resize:
+    case eCursor_sw_resize:
+        cursor = Qt::SizeFDiagCursor;
+        break;
+    case eCursor_crosshair:
+    case eCursor_move:
+        cursor = Qt::SizeAllCursor;
+        break;
+    case eCursor_help:
+        cursor = Qt::WhatsThisCursor;
+        break;
+    case eCursor_copy:
+    case eCursor_alias:
+        break;
+    case eCursor_context_menu:
+    case eCursor_cell:
+    case eCursor_grab:
+    case eCursor_grabbing:
+    case eCursor_spinning:
+    case eCursor_zoom_in:
+    case eCursor_zoom_out:
+
+    default:
+        break;
+    }
+
+    setCursor(cursor);
+}
diff --git a/widget/qt/mozqwidget.h b/widget/qt/mozqwidget.h
new file mode 100644
index 000000000000..4f3a4c31bd46
--- /dev/null
+++ b/widget/qt/mozqwidget.h
@@ -0,0 +1,71 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim: set ts=4 et sw=4 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZQWIDGET_H
+#define MOZQWIDGET_H
+
+#include "nsIWidget.h"
+
+#include <QtGui/QWindow>
+
+QT_BEGIN_NAMESPACE
+class QPainter;
+class QExposeEvent;
+class QResizeEvent;
+QT_END_NAMESPACE
+
+namespace mozilla {
+namespace widget {
+
+class nsWindow;
+
+class MozQWidget : public QWindow
+{
+    Q_OBJECT
+public:
+    explicit MozQWidget(nsWindow* aReceiver, QWindow* aParent = 0);
+    ~MozQWidget();
+
+    virtual void render(QPainter* painter);
+
+    virtual nsWindow* getReceiver() { return mReceiver; };
+    virtual void dropReceiver() { mReceiver = nullptr; };
+    virtual void SetCursor(nsCursor aCursor);
+
+public Q_SLOTS:
+    void renderLater();
+    void renderNow();
+
+protected:
+    virtual bool event(QEvent* event);
+    virtual void exposeEvent(QExposeEvent* event);
+    virtual void focusInEvent(QFocusEvent* event);
+    virtual void focusOutEvent(QFocusEvent* event);
+    virtual void hideEvent(QHideEvent* event);
+    virtual void keyPressEvent(QKeyEvent* event);
+    virtual void keyReleaseEvent(QKeyEvent* event);
+    virtual void mouseDoubleClickEvent(QMouseEvent* event);
+    virtual void mouseMoveEvent(QMouseEvent* event);
+    virtual void mousePressEvent(QMouseEvent* event);
+    virtual void mouseReleaseEvent(QMouseEvent* event);
+    virtual void moveEvent(QMoveEvent* event);
+    virtual void resizeEvent(QResizeEvent* event);
+    virtual void showEvent(QShowEvent* event);
+    virtual void tabletEvent(QTabletEvent* event);
+    virtual void touchEvent(QTouchEvent* event);
+    virtual void wheelEvent(QWheelEvent* event);
+
+private:
+    nsWindow* mReceiver;
+    bool mUpdatePending;
+    nsWindowType mWindowType;
+};
+
+} // namespace widget
+} // namespace mozilla
+
+#endif // MOZQWIDGET_H
+
diff --git a/widget/qt/nsAppShell.cpp b/widget/qt/nsAppShell.cpp
new file mode 100644
index 000000000000..a7a06a4f528d
--- /dev/null
+++ b/widget/qt/nsAppShell.cpp
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsAppShell.h"
+#include <QGuiApplication>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <qabstracteventdispatcher.h>
+#include <qthread.h>
+
+#include "prenv.h"
+#include "nsQAppInstance.h"
+
+#ifdef MOZ_LOGGING
+#include "mozilla/Logging.h"
+#endif
+
+using mozilla::LazyLogModule;
+
+LazyLogModule gWidgetLog("Widget");
+LazyLogModule gWidgetFocusLog("WidgetFocus");
+LazyLogModule gWidgetDragLog("WidgetDrag");
+LazyLogModule gWidgetDrawLog("WidgetDraw");
+
+static int sPokeEvent;
+
+nsAppShell::~nsAppShell()
+{
+    nsQAppInstance::Release();
+}
+
+nsresult
+nsAppShell::Init()
+{
+    sPokeEvent = QEvent::registerEventType();
+
+    nsQAppInstance::AddRef();
+
+    return nsBaseAppShell::Init();
+}
+
+void
+nsAppShell::ScheduleNativeEventCallback()
+{
+    QCoreApplication::postEvent(this,
+                                new QEvent((QEvent::Type) sPokeEvent));
+}
+
+
+bool
+nsAppShell::ProcessNextNativeEvent(bool mayWait)
+{
+    QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEvents;
+
+    if (mayWait)
+        flags |= QEventLoop::WaitForMoreEvents;
+
+    QAbstractEventDispatcher *dispatcher =  QAbstractEventDispatcher::instance(QThread::currentThread());
+    if (!dispatcher)
+        return false;
+
+    return dispatcher->processEvents(flags) ? true : false;
+}
+
+bool
+nsAppShell::event (QEvent *e)
+{
+    if (e->type() == sPokeEvent) {
+        NativeEventCallback();
+        return true;
+    }
+
+    return false;
+}
diff --git a/widget/qt/nsAppShell.h b/widget/qt/nsAppShell.h
new file mode 100644
index 000000000000..2d2f37d75864
--- /dev/null
+++ b/widget/qt/nsAppShell.h
@@ -0,0 +1,37 @@
+/* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsAppShell_h__
+#define nsAppShell_h__
+
+#include <qsocketnotifier.h>
+#include "nsBaseAppShell.h"
+#include "nsCOMPtr.h"
+
+/**
+ * Native QT Application shell wrapper
+ */
+
+class nsAppShell : public QObject,
+                   public nsBaseAppShell
+{
+  Q_OBJECT
+
+public:
+  nsAppShell() { };
+
+  nsresult Init();
+
+  virtual bool event (QEvent *e);
+
+protected:
+  virtual void ScheduleNativeEventCallback();
+  virtual bool ProcessNextNativeEvent(bool mayWait);
+  virtual ~nsAppShell();
+};
+
+
+#endif // nsAppShell_h__
+
diff --git a/widget/qt/nsBidiKeyboard.cpp b/widget/qt/nsBidiKeyboard.cpp
new file mode 100644
index 000000000000..92baf8eb39da
--- /dev/null
+++ b/widget/qt/nsBidiKeyboard.cpp
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <Qt>
+#include <QGuiApplication>
+
+#include "nsBidiKeyboard.h"
+
+NS_IMPL_ISUPPORTS(nsBidiKeyboard, nsIBidiKeyboard)
+
+nsBidiKeyboard::nsBidiKeyboard() : nsIBidiKeyboard()
+{
+  Reset();
+}
+
+nsBidiKeyboard::~nsBidiKeyboard()
+{
+}
+
+NS_IMETHODIMP nsBidiKeyboard::Reset()
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsBidiKeyboard::IsLangRTL(bool *aIsRTL)
+{
+    *aIsRTL = false;
+
+    QInputMethod* input = qApp->inputMethod();
+    Qt::LayoutDirection layoutDir = input ? input->inputDirection() : Qt::LeftToRight;
+
+    if (layoutDir == Qt::RightToLeft) {
+        *aIsRTL = true;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsBidiKeyboard::GetHaveBidiKeyboards(bool* aResult)
+{
+  // not implemented yet
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/widget/qt/nsBidiKeyboard.h b/widget/qt/nsBidiKeyboard.h
new file mode 100644
index 000000000000..c22bf4ab8c10
--- /dev/null
+++ b/widget/qt/nsBidiKeyboard.h
@@ -0,0 +1,25 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsBidiKeyboard
+#define __nsBidiKeyboard
+#include "nsIBidiKeyboard.h"
+
+class nsBidiKeyboard : public nsIBidiKeyboard
+{
+public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIBIDIKEYBOARD
+
+    nsBidiKeyboard();
+
+protected:
+    virtual ~nsBidiKeyboard();
+};
+
+
+#endif // __nsBidiKeyboard
diff --git a/widget/qt/nsClipboard.cpp b/widget/qt/nsClipboard.cpp
new file mode 100644
index 000000000000..e8a631bb0bb3
--- /dev/null
+++ b/widget/qt/nsClipboard.cpp
@@ -0,0 +1,563 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QGuiApplication>
+#include <QMimeData>
+#include <QString>
+#include <QStringList>
+#include <QByteArray>
+#include <QImage>
+#include <QImageWriter>
+#include <QBuffer>
+
+#include "nsArrayUtils.h" // for do_QueryElementAt
+#include "gfxPlatform.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/gfx/2D.h"
+
+#include "nsClipboard.h"
+#include "nsISupportsPrimitives.h"
+#include "nsPrimitiveHelpers.h"
+#include "nsIInputStream.h"
+#include "nsReadableUtils.h"
+#include "nsStringStream.h"
+#include "nsComponentManagerUtils.h"
+
+#include "imgIContainer.h"
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+
+NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard)
+
+//-------------------------------------------------------------------------
+//
+// nsClipboard constructor
+//
+//-------------------------------------------------------------------------
+nsClipboard::nsClipboard() : nsIClipboard(),
+                             mSelectionOwner(nullptr),
+                             mGlobalOwner(nullptr),
+                             mSelectionTransferable(nullptr),
+                             mGlobalTransferable(nullptr)
+{
+    // No implementation needed
+}
+
+//-------------------------------------------------------------------------
+//
+// nsClipboard destructor
+//
+//-------------------------------------------------------------------------
+nsClipboard::~nsClipboard()
+{
+}
+
+static inline QImage::Format
+_moz2dformat_to_qformat(SurfaceFormat aFormat)
+{
+    switch (aFormat) {
+    case SurfaceFormat::B8G8R8A8:
+        return QImage::Format_ARGB32_Premultiplied;
+    case SurfaceFormat::B8G8R8X8:
+        return QImage::Format_ARGB32;
+    case SurfaceFormat::R5G6B5_UINT16:
+        return QImage::Format_RGB16;
+    default:
+        return QImage::Format_Invalid;
+    }
+}
+
+// nsClipboard::SetNativeClipboardData ie. Copy
+
+NS_IMETHODIMP
+nsClipboard::SetNativeClipboardData( nsITransferable *aTransferable,
+                                     QClipboard::Mode clipboardMode )
+{
+    if (nullptr == aTransferable)
+    {
+        NS_WARNING("nsClipboard::SetNativeClipboardData(): no transferable!");
+        return NS_ERROR_FAILURE;
+    }
+
+    // get flavor list that includes all flavors that can be written (including
+    // ones obtained through conversion)
+    nsCOMPtr<nsIArray> flavorList;
+    nsresult rv = aTransferable->FlavorsTransferableCanExport( getter_AddRefs(flavorList) );
+
+    if (!flavorList || NS_FAILED(rv))
+    {
+        NS_WARNING("nsClipboard::SetNativeClipboardData(): no FlavorsTransferable !");
+        return NS_ERROR_FAILURE;
+    }
+
+    QClipboard *cb = QGuiApplication::clipboard();
+    QMimeData *mimeData = new QMimeData;
+
+    uint32_t flavorCount = 0;
+    flavorList->GetLength(&flavorCount);
+    bool imageAdded = false;
+
+    for (uint32_t i = 0; i < flavorCount; ++i)
+    {
+        nsCOMPtr<nsISupportsCString> currentFlavor = do_QueryElementAt(flavorList, i);
+        
+        if (currentFlavor)
+        {
+            // flavorStr is the mime type
+            nsCString flavorStr;
+            currentFlavor->ToString(getter_Copies(flavorStr));
+
+            // Clip is the data which will be sent to the clipboard
+            nsCOMPtr<nsISupports> clip;
+            // len is the length of the data
+            uint32_t len;
+
+            // Unicode text?
+            if (!strcmp(flavorStr.get(), kUnicodeMime))
+            {
+                rv = aTransferable->GetTransferData(flavorStr.get(), getter_AddRefs(clip), &len);
+                nsCOMPtr<nsISupportsString> wideString;
+                wideString = do_QueryInterface(clip);
+                if (!wideString || NS_FAILED(rv))
+                    continue;
+
+                nsAutoString utf16string;
+                wideString->GetData(utf16string);
+                QString str = QString::fromUtf16((const ushort*)utf16string.get());
+
+                // Add text to the mimeData
+                mimeData->setText(str);
+            }
+
+            // html?
+            else if (!strcmp(flavorStr.get(), kHTMLMime))
+            {
+                rv = aTransferable->GetTransferData(flavorStr.get(), getter_AddRefs(clip), &len);
+                nsCOMPtr<nsISupportsString> wideString;
+                wideString = do_QueryInterface(clip);
+                if (!wideString || NS_FAILED(rv))
+                    continue;
+
+                nsAutoString utf16string;
+                wideString->GetData(utf16string);
+                QString str = QString::fromUtf16((const ushort*)utf16string.get());
+
+                // Add html to the mimeData
+                mimeData->setHtml(str);
+            }
+
+            // image?
+            else if (!imageAdded // image is added only once to the clipboard
+                     && (!strcmp(flavorStr.get(), kNativeImageMime)
+                     ||  !strcmp(flavorStr.get(), kPNGImageMime)
+                     ||  !strcmp(flavorStr.get(), kJPEGImageMime)
+                     ||  !strcmp(flavorStr.get(), kJPGImageMime)
+                     ||  !strcmp(flavorStr.get(), kGIFImageMime))
+                    )
+            {
+                // Look through our transfer data for the image
+                static const char* const imageMimeTypes[] = {
+                    kNativeImageMime, kPNGImageMime, kJPEGImageMime, kJPGImageMime, kGIFImageMime };
+                nsCOMPtr<nsISupportsInterfacePointer> ptrPrimitive;
+                for (uint32_t i = 0; !ptrPrimitive && i < ArrayLength(imageMimeTypes); i++)
+                {
+                    aTransferable->GetTransferData(imageMimeTypes[i], getter_AddRefs(clip), &len);
+                    ptrPrimitive = do_QueryInterface(clip);
+                }
+
+                if (!ptrPrimitive)
+                    continue;
+
+                nsCOMPtr<nsISupports> primitiveData;
+                ptrPrimitive->GetData(getter_AddRefs(primitiveData));
+                nsCOMPtr<imgIContainer> image(do_QueryInterface(primitiveData));
+                if (!image)  // Not getting an image for an image mime type!?
+                   continue;
+
+                RefPtr<SourceSurface> surface =
+                  image->GetFrame(imgIContainer::FRAME_CURRENT,
+                                  imgIContainer::FLAG_SYNC_DECODE);
+                if (!surface)
+                  continue;
+
+                RefPtr<DataSourceSurface> dataSurface =
+                  surface->GetDataSurface();
+                if (!dataSurface)
+                  continue;
+
+                DataSourceSurface::MappedSurface map;
+                if (!dataSurface->Map(DataSourceSurface::MapType::READ, &map))
+                  continue;
+
+                QImage qImage(map.mData,
+                              dataSurface->GetSize().width,
+                              dataSurface->GetSize().height,
+                              map.mStride,
+                              _moz2dformat_to_qformat(dataSurface->GetFormat()));
+
+                dataSurface->Unmap();
+
+                // Add image to the mimeData
+                mimeData->setImageData(qImage);
+                imageAdded = true;
+            }
+
+            // Other flavors, adding data to clipboard "as is"
+            else
+            {
+                rv = aTransferable->GetTransferData(flavorStr.get(), getter_AddRefs(clip), &len);
+                // nothing found?
+                if (!clip || NS_FAILED(rv))
+                    continue;
+
+                void *primitive_data = nullptr;
+                nsPrimitiveHelpers::CreateDataFromPrimitive(flavorStr, clip,
+                                                            &primitive_data, len);
+
+                if (primitive_data)
+                {
+                    QByteArray data ((const char *)primitive_data, len);
+                    // Add data to the mimeData
+                    mimeData->setData(flavorStr.get(), data);
+                    free(primitive_data);
+                }
+            }
+        }
+    }
+
+    // If we have some mime data, add it to the clipboard
+    if(!mimeData->formats().isEmpty())
+        cb->setMimeData(mimeData, clipboardMode);
+    else
+        delete mimeData;
+
+    return NS_OK;
+}
+
+// nsClipboard::GetNativeClipboardData ie. Paste
+//
+NS_IMETHODIMP
+nsClipboard::GetNativeClipboardData(nsITransferable *aTransferable,
+                                    QClipboard::Mode clipboardMode)
+{
+    if (nullptr == aTransferable)
+    {
+        NS_WARNING("GetNativeClipboardData: Transferable is null!");
+        return NS_ERROR_FAILURE;
+    }
+
+    // get flavor list that includes all acceptable flavors (including
+    // ones obtained through conversion)
+    nsCOMPtr<nsIArray> flavorList;
+    nsresult errCode = aTransferable->FlavorsTransferableCanImport(getter_AddRefs(flavorList));
+
+    if (!flavorList || NS_FAILED(errCode))
+    {
+        NS_WARNING("nsClipboard::GetNativeClipboardData(): no FlavorsTransferable!");
+        return NS_ERROR_FAILURE;
+    }
+
+    QClipboard *cb = QGuiApplication::clipboard();
+    const QMimeData *mimeData = cb->mimeData(clipboardMode);
+
+    // Walk through flavors and see which flavor matches the one being pasted
+    uint32_t flavorCount;
+    flavorList->GetLength(&flavorCount);
+    nsAutoCString foundFlavor;
+
+    for (uint32_t i = 0; i < flavorCount; ++i)
+    {
+        nsCOMPtr<nsISupportsCString> currentFlavor = do_QueryElementAt(flavorList, i);
+
+        if (currentFlavor)
+        {
+            nsCString flavorStr;
+            currentFlavor->ToString(getter_Copies(flavorStr));
+
+            // Ok, so which flavor the data being pasted could be?
+            // Text?
+            if (!strcmp(flavorStr.get(), kUnicodeMime) && mimeData->hasText())
+            {
+                // Clipboard has text and flavor accepts text, so lets
+                // handle the data as text
+                foundFlavor = nsAutoCString(flavorStr);
+
+                // Get the text data from clipboard
+                QString text = mimeData->text();
+                const QChar *unicode = text.unicode();
+                // Is there a more correct way to get the size in UTF16?
+                uint32_t len = (uint32_t) 2*text.size();
+
+                // And then to genericDataWrapper
+                nsCOMPtr<nsISupports> genericDataWrapper;
+                nsPrimitiveHelpers::CreatePrimitiveForData(
+                        foundFlavor,
+                        (void*)unicode,
+                        len,
+                        getter_AddRefs(genericDataWrapper));
+                // Data is good, set it to the transferable
+                aTransferable->SetTransferData(foundFlavor.get(),
+                                               genericDataWrapper,len);
+                // And thats all
+                break;
+            }
+
+            // html?
+            if (!strcmp(flavorStr.get(), kHTMLMime) && mimeData->hasHtml())
+            {
+                // Clipboard has text/html and flavor accepts text/html, so lets
+                // handle the data as text/html
+                foundFlavor = nsAutoCString(flavorStr);
+
+                // Get the text data from clipboard
+                QString html = mimeData->html();
+                const QChar *unicode = html.unicode();
+                // Is there a more correct way to get the size in UTF16?
+                uint32_t len = (uint32_t) 2*html.size();
+
+                // And then to genericDataWrapper
+                nsCOMPtr<nsISupports> genericDataWrapper;
+                nsPrimitiveHelpers::CreatePrimitiveForData(
+                        foundFlavor,
+                        (void*)unicode,
+                        len,
+                        getter_AddRefs(genericDataWrapper));
+                // Data is good, set it to the transferable
+                aTransferable->SetTransferData(foundFlavor.get(),
+                                               genericDataWrapper,len);
+                // And thats all
+                break;
+            }
+
+            // Image?
+            if ((  !strcmp(flavorStr.get(), kJPEGImageMime)
+                || !strcmp(flavorStr.get(), kJPGImageMime)
+                || !strcmp(flavorStr.get(), kPNGImageMime)
+                || !strcmp(flavorStr.get(), kGIFImageMime))
+                && mimeData->hasImage())
+            {
+                // Try to retrieve an image from clipboard
+                QImage image = cb->image();
+                if(image.isNull())
+                    continue;
+
+                // Lets set the image format
+                QByteArray imageFormat;
+                if (!strcmp(flavorStr.get(), kJPEGImageMime) || !strcmp(flavorStr.get(), kJPGImageMime))
+                    imageFormat = "jpeg";
+                else if (!strcmp(flavorStr.get(), kPNGImageMime))
+                    imageFormat = "png";
+                else if (!strcmp(flavorStr.get(), kGIFImageMime))
+                    imageFormat = "gif";
+                else
+                    continue;
+
+                // Write image from clippboard to a QByteArrayBuffer
+                QByteArray imageData;
+                QBuffer imageBuffer(&imageData);
+                QImageWriter imageWriter(&imageBuffer, imageFormat);
+                if(!imageWriter.write(image))
+                    continue;
+
+                // Add the data to inputstream
+                nsCOMPtr<nsIInputStream> byteStream;
+                NS_NewByteInputStream(getter_AddRefs(byteStream), imageData.constData(),
+                                      imageData.size(), NS_ASSIGNMENT_COPY);
+                // Data is good, set it to the transferable
+                aTransferable->SetTransferData(flavorStr.get(), byteStream, sizeof(nsIInputStream*));
+
+                imageBuffer.close();
+
+                // And thats all
+                break;
+            }
+
+            // Other mimetype?
+            // Trying to forward the data "as is"
+            if(mimeData->hasFormat(flavorStr.get()))
+            {
+                // get the data from the clipboard
+                QByteArray clipboardData = mimeData->data(flavorStr.get());
+                // And add it to genericDataWrapper
+                nsCOMPtr<nsISupports> genericDataWrapper;
+                nsPrimitiveHelpers::CreatePrimitiveForData(
+                        foundFlavor,
+                        (void*) clipboardData.data(),
+                        clipboardData.size(),
+                        getter_AddRefs(genericDataWrapper));
+
+                // Data is good, set it to the transferable
+                aTransferable->SetTransferData(foundFlavor.get(),
+                                               genericDataWrapper,clipboardData.size());
+                // And thats all
+                break;
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsClipboard::HasDataMatchingFlavors(const char** aFlavorList, uint32_t aLength,
+                                    int32_t aWhichClipboard, bool *_retval)
+{
+    *_retval = false;
+    if (aWhichClipboard != kGlobalClipboard)
+        return NS_OK;
+
+    // Which kind of data in the clipboard
+    QClipboard *cb = QGuiApplication::clipboard();
+    const QMimeData *mimeData = cb->mimeData();
+    const char *flavor=nullptr;
+    QStringList formats = mimeData->formats();
+    for (uint32_t i = 0; i < aLength; ++i)
+    {
+        flavor = aFlavorList[i];
+        if (flavor)
+        {
+            QString qflavor(flavor);
+
+            if (strcmp(flavor,kTextMime) == 0)
+            {
+                NS_WARNING("DO NOT USE THE text/plain DATA FLAVOR ANY MORE. USE text/unicode INSTEAD");
+            }
+
+            // QClipboard says it has text/plain, mozilla wants to
+            // know if the data is text/unicode -> interpret text/plain to text/unicode
+            if (formats.contains(qflavor) ||
+                strcmp(flavor, kUnicodeMime) == 0)
+            {
+                // A match has been found, return'
+                *_retval = true;
+                break;
+            }
+        }
+    }
+    return NS_OK;
+}
+
+/**
+ * Sets the transferable object
+ */
+NS_IMETHODIMP
+nsClipboard::SetData(nsITransferable *aTransferable,
+                     nsIClipboardOwner *aOwner,
+                     int32_t aWhichClipboard)
+{
+    // See if we can short cut
+    if (
+        (aWhichClipboard == kGlobalClipboard
+           && aTransferable == mGlobalTransferable.get()
+           && aOwner == mGlobalOwner.get()
+        )
+       ||
+        (aWhichClipboard == kSelectionClipboard
+         && aTransferable == mSelectionTransferable.get()
+         && aOwner == mSelectionOwner.get()
+        )
+       )
+    {
+        return NS_OK;
+    }
+
+    EmptyClipboard(aWhichClipboard);
+
+    QClipboard::Mode mode;
+
+    if (kGlobalClipboard == aWhichClipboard)
+    {
+        mGlobalOwner = aOwner;
+        mGlobalTransferable = aTransferable;
+
+        mode = QClipboard::Clipboard;
+    }
+    else
+    {
+        mSelectionOwner = aOwner;
+        mSelectionTransferable = aTransferable;
+
+        mode = QClipboard::Selection;
+    }
+    return SetNativeClipboardData( aTransferable, mode );
+}
+
+/**
+ * Gets the transferable object
+ */
+NS_IMETHODIMP
+nsClipboard::GetData(nsITransferable *aTransferable, int32_t aWhichClipboard)
+{
+    if (nullptr != aTransferable)
+    {
+        QClipboard::Mode mode;
+        if (kGlobalClipboard == aWhichClipboard)
+        {
+            mode = QClipboard::Clipboard;
+        }
+        else
+        {
+            mode = QClipboard::Selection;
+        }
+        return GetNativeClipboardData(aTransferable, mode);
+    }
+    else
+    {
+        NS_WARNING("nsClipboard::GetData(), aTransferable is NULL.");
+    }
+    return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsClipboard::EmptyClipboard(int32_t aWhichClipboard)
+{
+    if (aWhichClipboard == kSelectionClipboard)
+    {
+        if (mSelectionOwner)
+        {
+            mSelectionOwner->LosingOwnership(mSelectionTransferable);
+            mSelectionOwner = nullptr;
+        }
+        mSelectionTransferable = nullptr;
+    }
+    else
+    {
+        if (mGlobalOwner)
+        {
+            mGlobalOwner->LosingOwnership(mGlobalTransferable);
+            mGlobalOwner = nullptr;
+        }
+        mGlobalTransferable = nullptr;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsClipboard::SupportsSelectionClipboard(bool *_retval)
+{
+    NS_ENSURE_ARG_POINTER(_retval);
+
+    QClipboard *cb = QGuiApplication::clipboard();
+    if (cb->supportsSelection())
+    {
+        *_retval = true; // we support the selection clipboard 
+    }
+    else
+    {
+        *_retval = false;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsClipboard::SupportsFindClipboard(bool* _retval)
+{
+  NS_ENSURE_ARG_POINTER(_retval);
+
+  *_retval = false;
+  return NS_OK;
+}
diff --git a/widget/qt/nsClipboard.h b/widget/qt/nsClipboard.h
new file mode 100644
index 000000000000..d348c4b551af
--- /dev/null
+++ b/widget/qt/nsClipboard.h
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef nsClipboard_h__
+#define nsClipboard_h__
+
+#include "nsIClipboard.h"
+#include "nsITransferable.h"
+#include "nsIClipboardOwner.h"
+#include "nsCOMPtr.h"
+
+#include <qclipboard.h>
+
+/* Native Qt Clipboard wrapper */
+class nsClipboard : public nsIClipboard
+{
+public:
+    nsClipboard();
+
+    //nsISupports
+    NS_DECL_ISUPPORTS
+
+    // nsIClipboard
+    NS_DECL_NSICLIPBOARD
+
+protected:
+    virtual ~nsClipboard();
+
+    NS_IMETHOD SetNativeClipboardData(nsITransferable *aTransferable,
+                                      QClipboard::Mode cbMode);
+    NS_IMETHOD GetNativeClipboardData(nsITransferable *aTransferable,
+                                      QClipboard::Mode cbMode);
+
+    nsCOMPtr<nsIClipboardOwner> mSelectionOwner;
+    nsCOMPtr<nsIClipboardOwner> mGlobalOwner;
+    nsCOMPtr<nsITransferable>   mSelectionTransferable;
+    nsCOMPtr<nsITransferable>   mGlobalTransferable;
+};
+
+#endif // nsClipboard_h__
diff --git a/widget/qt/nsDeviceContextSpecQt.cpp b/widget/qt/nsDeviceContextSpecQt.cpp
new file mode 100644
index 000000000000..aa24ffc1d6b8
--- /dev/null
+++ b/widget/qt/nsDeviceContextSpecQt.cpp
@@ -0,0 +1,228 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#include <QTemporaryFile>
+
+#define SET_PRINTER_FEATURES_VIA_PREFS 1
+#define PRINTERFEATURES_PREF "print.tmp.printerfeatures"
+
+#include "mozilla/gfx/PrintTargetPDF.h"
+#include "mozilla/Logging.h"
+
+#include "plstr.h"
+
+#include "nsDeviceContextSpecQt.h"
+
+#include "prenv.h" /* for PR_GetEnv */
+
+#include "nsReadableUtils.h"
+#include "nsStringEnumerator.h"
+#include "nsIServiceManager.h"
+#include "nsPrintSettingsQt.h"
+#include "nsIFileStreams.h"
+#include "nsIFile.h"
+#include "nsTArray.h"
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+
+static LazyLogModule DeviceContextSpecQtLM("DeviceContextSpecQt");
+/* Macro to make lines shorter */
+#define DO_PR_DEBUG_LOG(x) MOZ_LOG(DeviceContextSpecQtLM, mozilla::LogLevel::Debug, x)
+
+nsDeviceContextSpecQt::nsDeviceContextSpecQt()
+{
+    DO_PR_DEBUG_LOG(("nsDeviceContextSpecQt::nsDeviceContextSpecQt()\n"));
+}
+
+nsDeviceContextSpecQt::~nsDeviceContextSpecQt()
+{
+    DO_PR_DEBUG_LOG(("nsDeviceContextSpecQt::~nsDeviceContextSpecQt()\n"));
+}
+
+NS_IMPL_ISUPPORTS(nsDeviceContextSpecQt,
+        nsIDeviceContextSpec)
+
+already_AddRefed<PrintTarget> nsDeviceContextSpecQt::MakePrintTarget()
+{
+    double width, height;
+    mPrintSettings->GetEffectivePageSize(&width, &height);
+
+    // If we're in landscape mode, we'll be rotating the output --
+    // need to swap width & height.
+    int32_t orientation;
+    mPrintSettings->GetOrientation(&orientation);
+    if (nsIPrintSettings::kLandscapeOrientation == orientation) {
+        double tmp = width;
+        width = height;
+        height = tmp;
+    }
+
+    // convert twips to points
+    width  /= TWIPS_PER_POINT_FLOAT;
+    height /= TWIPS_PER_POINT_FLOAT;
+
+    DO_PR_DEBUG_LOG(("\"%s\", %f, %f\n", mPath, width, height));
+
+    QTemporaryFile file;
+    if(!file.open()) {
+        return nullptr;
+    }
+    file.setAutoRemove(false);
+
+    nsresult rv = NS_NewNativeLocalFile(
+            nsDependentCString(file.fileName().toUtf8().constData()),
+            false,
+            getter_AddRefs(mSpoolFile));
+    if (NS_FAILED(rv)) {
+        file.remove();
+        return nullptr;
+    }
+
+    mSpoolName = file.fileName().toUtf8().constData();
+
+    mSpoolFile->SetPermissions(0600);
+
+    nsCOMPtr<nsIFileOutputStream> stream =
+        do_CreateInstance("@mozilla.org/network/file-output-stream;1");
+
+    rv = stream->Init(mSpoolFile, -1, -1, 0);
+    if (NS_FAILED(rv))
+        return nullptr;
+
+    int16_t format;
+    mPrintSettings->GetOutputFormat(&format);
+
+    if (format == nsIPrintSettings::kOutputFormatNative) {
+        if (mIsPPreview) {
+            // There is nothing to detect on Print Preview, use PS.
+            // TODO: implement for Qt?
+            //format = nsIPrintSettings::kOutputFormatPS;
+            return nullptr;
+        }
+        format = nsIPrintSettings::kOutputFormatPDF;
+    }
+
+    IntSize size = IntSize::Truncate(width, height);
+
+    if (format == nsIPrintSettings::kOutputFormatPDF) {
+        return PrintTargetPDF::CreateOrNull(stream, size);
+    }
+
+    return nullptr;
+}
+
+NS_IMETHODIMP nsDeviceContextSpecQt::Init(nsIWidget* aWidget,
+        nsIPrintSettings* aPS,
+        bool aIsPrintPreview)
+{
+    DO_PR_DEBUG_LOG(("nsDeviceContextSpecQt::Init(aPS=%p)\n", aPS));
+
+    mPrintSettings = aPS;
+    mIsPPreview = aIsPrintPreview;
+
+    // This is only set by embedders
+    bool toFile;
+    aPS->GetPrintToFile(&toFile);
+
+    mToPrinter = !toFile && !aIsPrintPreview;
+
+    nsCOMPtr<nsPrintSettingsQt> printSettingsQt(do_QueryInterface(aPS));
+    if (!printSettingsQt)
+        return NS_ERROR_NO_INTERFACE;
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsDeviceContextSpecQt::BeginDocument(
+        const nsAString& aTitle,
+        const nsAString& aPrintToFileName,
+        int32_t aStartPage,
+        int32_t aEndPage)
+{
+    if (mToPrinter) {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsDeviceContextSpecQt::EndDocument()
+{
+    if (mToPrinter) {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+    // Handle print-to-file ourselves for the benefit of embedders
+    nsString targetPath;
+    nsCOMPtr<nsIFile> destFile;
+    mPrintSettings->GetToFileName(targetPath);
+
+    nsresult rv = NS_NewLocalFile(targetPath, false, getter_AddRefs(destFile));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsAutoString destLeafName;
+    rv = destFile->GetLeafName(destLeafName);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIFile> destDir;
+    rv = destFile->GetParent(getter_AddRefs(destDir));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = mSpoolFile->MoveTo(destDir, destLeafName);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // This is the standard way to get the UNIX umask. Ugh.
+    mode_t mask = umask(0);
+    umask(mask);
+    // If you're not familiar with umasks, they contain the bits of what NOT
+    // to set in the permissions
+    // (thats because files and directories have different numbers of bits
+    // for their permissions)
+    destFile->SetPermissions(0666 & ~(mask));
+
+    return NS_OK;
+}
+
+//  Printer Enumerator
+nsPrinterEnumeratorQt::nsPrinterEnumeratorQt()
+{
+}
+
+nsPrinterEnumeratorQt::~nsPrinterEnumeratorQt()
+{
+}
+
+NS_IMPL_ISUPPORTS(nsPrinterEnumeratorQt, nsIPrinterEnumerator)
+
+NS_IMETHODIMP nsPrinterEnumeratorQt::GetPrinterNameList(
+        nsIStringEnumerator** aPrinterNameList)
+{
+    NS_ENSURE_ARG_POINTER(aPrinterNameList);
+    *aPrinterNameList = nullptr;
+
+    nsTArray<nsString>* printers =
+        new nsTArray<nsString>(0);
+
+    return NS_NewAdoptingStringEnumerator(aPrinterNameList, printers);
+}
+
+NS_IMETHODIMP nsPrinterEnumeratorQt::GetDefaultPrinterName(nsAString &aDefaultPrinterName)
+{
+    DO_PR_DEBUG_LOG(("nsPrinterEnumeratorQt::GetDefaultPrinterName()\n"));
+    return NS_OK;
+}
+
+NS_IMETHODIMP nsPrinterEnumeratorQt::InitPrintSettingsFromPrinter(
+        const nsAString &aPrinterName,
+        nsIPrintSettings* aPrintSettings)
+{
+    DO_PR_DEBUG_LOG(("nsPrinterEnumeratorQt::InitPrintSettingsFromPrinter()"));
+    // XXX Leave NS_OK for now
+    // Probably should use NS_ERROR_NOT_IMPLEMENTED
+    return NS_OK;
+}
diff --git a/widget/qt/nsDeviceContextSpecQt.h b/widget/qt/nsDeviceContextSpecQt.h
new file mode 100644
index 000000000000..20b928ee03c6
--- /dev/null
+++ b/widget/qt/nsDeviceContextSpecQt.h
@@ -0,0 +1,60 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+
+#ifndef nsDeviceContextSpecQt_h___
+#define nsDeviceContextSpecQt_h___
+
+#include "nsIDeviceContextSpec.h"
+#include "nsIPrintSettings.h"
+#include "nsIPrinterEnumerator.h"
+#include "nsCOMPtr.h"
+
+#include "nsString.h"
+#include "nsCRT.h" /* should be <limits.h>? */
+
+class nsDeviceContextSpecQt : public nsIDeviceContextSpec
+{
+public:
+    nsDeviceContextSpecQt();
+
+    NS_DECL_ISUPPORTS
+
+    virtual already_AddRefed<PrintTarget> MakePrintTarget() final;
+
+    NS_IMETHOD Init(nsIWidget* aWidget,
+                    nsIPrintSettings* aPS,
+                    bool aIsPrintPreview) override;
+    NS_IMETHOD BeginDocument(const nsAString& aTitle,
+                             const nsAString& aPrintToFileName,
+                             int32_t aStartPage, int32_t aEndPage) override;
+    NS_IMETHOD EndDocument() override;
+    NS_IMETHOD BeginPage() override { return NS_OK; }
+    NS_IMETHOD EndPage() override { return NS_OK; }
+
+protected:
+    virtual ~nsDeviceContextSpecQt();
+
+    nsCOMPtr<nsIPrintSettings> mPrintSettings;
+    bool mToPrinter : 1;      /* If true, print to printer */
+    bool mIsPPreview : 1;     /* If true, is print preview */
+    char   mPath[PATH_MAX];     /* If toPrinter = false, dest file */
+    char   mPrinter[256];       /* Printer name */
+    nsCString         mSpoolName;
+    nsCOMPtr<nsIFile> mSpoolFile;
+};
+
+class nsPrinterEnumeratorQt : public nsIPrinterEnumerator {
+public:
+    nsPrinterEnumeratorQt();
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIPRINTERENUMERATOR
+
+protected:
+    virtual ~nsPrinterEnumeratorQt();
+
+};
+
+#endif /* !nsDeviceContextSpecQt_h___ */
diff --git a/widget/qt/nsIdleServiceQt.cpp b/widget/qt/nsIdleServiceQt.cpp
new file mode 100644
index 000000000000..5bcc0ae2c27b
--- /dev/null
+++ b/widget/qt/nsIdleServiceQt.cpp
@@ -0,0 +1,123 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifdef MOZ_X11
+#include "mozilla/X11Util.h"
+#endif
+#include "nsIdleServiceQt.h"
+#include "nsIServiceManager.h"
+#include "nsDebug.h"
+#include "prlink.h"
+
+#if defined(MOZ_X11)
+typedef bool (*_XScreenSaverQueryExtension_fn)(Display* dpy, int* event_base,
+                                                 int* error_base);
+
+typedef XScreenSaverInfo* (*_XScreenSaverAllocInfo_fn)(void);
+
+typedef void (*_XScreenSaverQueryInfo_fn)(Display* dpy, Drawable drw,
+                                          XScreenSaverInfo *info);
+
+static _XScreenSaverQueryExtension_fn _XSSQueryExtension = nullptr;
+static _XScreenSaverAllocInfo_fn _XSSAllocInfo = nullptr;
+static _XScreenSaverQueryInfo_fn _XSSQueryInfo = nullptr;
+
+static bool sInitialized = false;
+#endif
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsIdleServiceQt, nsIdleService)
+
+nsIdleServiceQt::nsIdleServiceQt()
+#if defined(MOZ_X11)
+    : mXssInfo(nullptr)
+#endif
+{
+}
+
+#if defined(MOZ_X11)
+static void Initialize()
+{
+    sInitialized = true;
+
+    // This will leak - See comments in ~nsIdleServiceQt().
+    PRLibrary* xsslib = PR_LoadLibrary("libXss.so.1");
+    if (!xsslib) {
+        return;
+    }
+
+    _XSSQueryExtension = (_XScreenSaverQueryExtension_fn)
+        PR_FindFunctionSymbol(xsslib, "XScreenSaverQueryExtension");
+    _XSSAllocInfo = (_XScreenSaverAllocInfo_fn)
+        PR_FindFunctionSymbol(xsslib, "XScreenSaverAllocInfo");
+    _XSSQueryInfo = (_XScreenSaverQueryInfo_fn)
+        PR_FindFunctionSymbol(xsslib, "XScreenSaverQueryInfo");
+}
+#endif
+
+nsIdleServiceQt::~nsIdleServiceQt()
+{
+#if defined(MOZ_X11)
+    if (mXssInfo)
+        XFree(mXssInfo);
+
+// It is not safe to unload libXScrnSaver until each display is closed because
+// the library registers callbacks through XESetCloseDisplay (Bug 397607).
+// (Also the library and its functions are scoped for the file not the object.)
+#if 0
+    if (xsslib) {
+        PR_UnloadLibrary(xsslib);
+        xsslib = nullptr;
+    }
+#endif
+#endif
+}
+
+bool
+nsIdleServiceQt::PollIdleTime(uint32_t *aIdleTime)
+{
+#if defined(MOZ_X11)
+    // Ask xscreensaver about idle time:
+    *aIdleTime = 0;
+
+    // We might not have a display (cf. in xpcshell)
+    Display *dplay = mozilla::DefaultXDisplay();
+    if (!dplay) {
+        return false;
+    }
+
+    if (!sInitialized) {
+        Initialize();
+    }
+    if (!_XSSQueryExtension || !_XSSAllocInfo || !_XSSQueryInfo) {
+        return false;
+    }
+
+    int event_base, error_base;
+    if (_XSSQueryExtension(dplay, &event_base, &error_base)) {
+        if (!mXssInfo)
+            mXssInfo = _XSSAllocInfo();
+        if (!mXssInfo)
+            return false;
+
+        _XSSQueryInfo(dplay, RootWindowOfScreen(DefaultScreenOfDisplay(mozilla::DefaultXDisplay())), mXssInfo);
+        *aIdleTime = mXssInfo->idle;
+        return true;
+    }
+#endif
+
+    return false;
+}
+
+bool
+nsIdleServiceQt::UsePollMode()
+{
+#if defined(MOZ_X11)
+    return false;
+#endif
+    return true;
+}
+
diff --git a/widget/qt/nsIdleServiceQt.h b/widget/qt/nsIdleServiceQt.h
new file mode 100644
index 000000000000..f947b56e02e0
--- /dev/null
+++ b/widget/qt/nsIdleServiceQt.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsIdleServiceQt_h__
+#define nsIdleServiceQt_h__
+
+#include "nsIdleService.h"
+
+#if defined(MOZ_X11)
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+typedef struct {
+    Window window;              // Screen saver window
+    int state;                  // ScreenSaver(Off,On,Disabled)
+    int kind;                   // ScreenSaver(Blanked,Internal,External)
+    unsigned long til_or_since; // milliseconds since/til screensaver kicks in
+    unsigned long idle;         // milliseconds idle
+    unsigned long event_mask;   // event stuff
+} XScreenSaverInfo;
+#endif
+
+class nsIdleServiceQt : public nsIdleService
+{
+public:
+    NS_DECL_ISUPPORTS_INHERITED
+
+    bool PollIdleTime(uint32_t* aIdleTime);
+
+    static already_AddRefed<nsIdleServiceQt> GetInstance()
+    {
+        RefPtr<nsIdleServiceQt> idleService =
+            nsIdleService::GetInstance().downcast<nsIdleServiceQt>();
+        if (!idleService) {
+            idleService = new nsIdleServiceQt();
+        }
+        
+        return idleService.forget();
+    }
+
+private:
+#if defined(MOZ_X11)
+    XScreenSaverInfo* mXssInfo;
+#endif
+
+protected:
+    nsIdleServiceQt();
+    virtual ~nsIdleServiceQt();
+    bool UsePollMode();
+};
+
+#endif // nsIdleServiceQt_h__
diff --git a/widget/qt/nsLookAndFeel.cpp b/widget/qt/nsLookAndFeel.cpp
new file mode 100644
index 000000000000..e2f8ade5e6d8
--- /dev/null
+++ b/widget/qt/nsLookAndFeel.cpp
@@ -0,0 +1,459 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* Copyright 2012 Mozilla Foundation and Mozilla contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <QGuiApplication>
+#include <QFont>
+#include <QScreen>
+#include <QPalette>
+
+#include "nsLookAndFeel.h"
+#include "nsStyleConsts.h"
+#include "gfxFont.h"
+#include "gfxFontConstants.h"
+#include "mozilla/gfx/2D.h"
+
+static const char16_t UNICODE_BULLET = 0x2022;
+
+#define QCOLOR_TO_NS_RGB(c)                     \
+  ((nscolor)NS_RGB(c.red(),c.green(),c.blue()))
+
+nsLookAndFeel::nsLookAndFeel()
+    : nsXPLookAndFeel()
+{
+}
+
+nsLookAndFeel::~nsLookAndFeel()
+{
+}
+
+void nsLookAndFeel::NativeInit() { }
+
+nsresult
+nsLookAndFeel::NativeGetColor(ColorID aID, nscolor &aColor)
+{
+    nsresult rv = NS_OK;
+
+#define BG_PRELIGHT_COLOR     NS_RGB(0xee,0xee,0xee)
+#define FG_PRELIGHT_COLOR     NS_RGB(0x77,0x77,0x77)
+#define RED_COLOR             NS_RGB(0xff,0x00,0x00)
+
+    QPalette palette = QGuiApplication::palette();
+
+    switch (aID) {
+        // These colors don't seem to be used for anything anymore in Mozilla
+        // (except here at least TextSelectBackground and TextSelectForeground)
+        // The CSS2 colors below are used.
+    case eColorID_WindowBackground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_WindowForeground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::WindowText));
+        break;
+    case eColorID_WidgetBackground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_WidgetForeground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::WindowText));
+        break;
+    case eColorID_WidgetSelectBackground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_WidgetSelectForeground:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::WindowText));
+        break;
+    case eColorID_Widget3DHighlight:
+        aColor = NS_RGB(0xa0,0xa0,0xa0);
+        break;
+    case eColorID_Widget3DShadow:
+        aColor = NS_RGB(0x40,0x40,0x40);
+        break;
+    case eColorID_TextBackground:
+        // not used?
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_TextForeground:
+        // not used?
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::WindowText));
+        break;
+    case eColorID_TextSelectBackground:
+    case eColorID_IMESelectedRawTextBackground:
+    case eColorID_IMESelectedConvertedTextBackground:
+        // still used
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Highlight));
+        break;
+    case eColorID_TextSelectForeground:
+    case eColorID_IMESelectedRawTextForeground:
+    case eColorID_IMESelectedConvertedTextForeground:
+        // still used
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::HighlightedText));
+        break;
+    case eColorID_IMERawInputBackground:
+    case eColorID_IMEConvertedTextBackground:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColorID_IMERawInputForeground:
+    case eColorID_IMEConvertedTextForeground:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColorID_IMERawInputUnderline:
+    case eColorID_IMEConvertedTextUnderline:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColorID_IMESelectedRawTextUnderline:
+    case eColorID_IMESelectedConvertedTextUnderline:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColorID_SpellCheckerUnderline:
+        aColor = RED_COLOR;
+        break;
+
+        // css2  http://www.w3.org/TR/REC-CSS2/ui.html#system-colors
+    case eColorID_activeborder:
+        // active window border
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_activecaption:
+        // active window caption background
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_appworkspace:
+        // MDI background color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_background:
+        // desktop background
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_captiontext:
+        // text in active window caption, size box, and scrollbar arrow box (!)
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID_graytext:
+        // disabled text in windows, menus, etc.
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Disabled, QPalette::Text));
+        break;
+    case eColorID_highlight:
+        // background of selected item
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Highlight));
+        break;
+    case eColorID_highlighttext:
+        // text of selected item
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::HighlightedText));
+        break;
+    case eColorID_inactiveborder:
+        // inactive window border
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Disabled, QPalette::Window));
+        break;
+    case eColorID_inactivecaption:
+        // inactive window caption
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Disabled, QPalette::Window));
+        break;
+    case eColorID_inactivecaptiontext:
+        // text in inactive window caption
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Disabled, QPalette::Text));
+        break;
+    case eColorID_infobackground:
+        // tooltip background color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::ToolTipBase));
+        break;
+    case eColorID_infotext:
+        // tooltip text color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::ToolTipText));
+        break;
+    case eColorID_menu:
+        // menu background
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID_menutext:
+        // menu text
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID_scrollbar:
+        // scrollbar gray area
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Mid));
+        break;
+
+    case eColorID_threedface:
+    case eColorID_buttonface:
+        // 3-D face color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Button));
+        break;
+
+    case eColorID_buttontext:
+        // text on push buttons
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::ButtonText));
+        break;
+
+    case eColorID_buttonhighlight:
+        // 3-D highlighted edge color
+    case eColorID_threedhighlight:
+        // 3-D highlighted outer edge color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Dark));
+        break;
+
+    case eColorID_threedlightshadow:
+        // 3-D highlighted inner edge color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Light));
+        break;
+
+    case eColorID_buttonshadow:
+        // 3-D shadow edge color
+    case eColorID_threedshadow:
+        // 3-D shadow inner edge color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Dark));
+        break;
+
+    case eColorID_threeddarkshadow:
+        // 3-D shadow outer edge color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Shadow));
+        break;
+
+    case eColorID_window:
+    case eColorID_windowframe:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+
+    case eColorID_windowtext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+
+    case eColorID__moz_eventreerow:
+    case eColorID__moz_field:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Base));
+        break;
+    case eColorID__moz_fieldtext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID__moz_dialog:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID__moz_dialogtext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::WindowText));
+        break;
+    case eColorID__moz_dragtargetzone:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Window));
+        break;
+    case eColorID__moz_buttondefault:
+        // default button border color
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Button));
+        break;
+    case eColorID__moz_buttonhoverface:
+        aColor = BG_PRELIGHT_COLOR;
+        break;
+    case eColorID__moz_buttonhovertext:
+        aColor = FG_PRELIGHT_COLOR;
+        break;
+    case eColorID__moz_cellhighlight:
+    case eColorID__moz_html_cellhighlight:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Highlight));
+        break;
+    case eColorID__moz_cellhighlighttext:
+    case eColorID__moz_html_cellhighlighttext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::HighlightedText));
+        break;
+    case eColorID__moz_menuhover:
+        aColor = BG_PRELIGHT_COLOR;
+        break;
+    case eColorID__moz_menuhovertext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID__moz_oddtreerow:
+        aColor = NS_TRANSPARENT;
+        break;
+    case eColorID__moz_nativehyperlinktext:
+        aColor = NS_SAME_AS_FOREGROUND_COLOR;
+        break;
+    case eColorID__moz_comboboxtext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID__moz_combobox:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Base));
+        break;
+    case eColorID__moz_menubartext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    case eColorID__moz_menubarhovertext:
+        aColor = QCOLOR_TO_NS_RGB(palette.color(QPalette::Normal, QPalette::Text));
+        break;
+    default:
+        /* default color is BLACK */
+        aColor = 0;
+        rv = NS_ERROR_FAILURE;
+        break;
+    }
+
+    return rv;
+}
+
+nsresult
+nsLookAndFeel::GetIntImpl(IntID aID, int32_t &aResult)
+{
+    nsresult rv = nsXPLookAndFeel::GetIntImpl(aID, aResult);
+    if (NS_SUCCEEDED(rv))
+        return rv;
+
+    rv = NS_OK;
+
+    switch (aID) {
+        case eIntID_CaretBlinkTime:
+            aResult = 500;
+            break;
+
+        case eIntID_CaretWidth:
+            aResult = 1;
+            break;
+
+        case eIntID_ShowCaretDuringSelection:
+            aResult = 0;
+            break;
+
+        case eIntID_SelectTextfieldsOnKeyFocus:
+            // Select textfield content when focused by kbd
+            // used by EventStateManager::sTextfieldSelectModel
+            aResult = 1;
+            break;
+
+        case eIntID_SubmenuDelay:
+            aResult = 200;
+            break;
+
+        case eIntID_TooltipDelay:
+            aResult = 500;
+            break;
+
+        case eIntID_MenusCanOverlapOSBar:
+            // we want XUL popups to be able to overlap the task bar.
+            aResult = 1;
+            break;
+
+        case eIntID_ScrollArrowStyle:
+            aResult = eScrollArrowStyle_Single;
+            break;
+
+        case eIntID_ScrollSliderStyle:
+            aResult = eScrollThumbStyle_Proportional;
+            break;
+
+        case eIntID_TouchEnabled:
+            aResult = 1;
+            break;
+
+        case eIntID_WindowsDefaultTheme:
+        case eIntID_WindowsThemeIdentifier:
+        case eIntID_OperatingSystemVersionIdentifier:
+            aResult = 0;
+            rv = NS_ERROR_NOT_IMPLEMENTED;
+            break;
+
+        case eIntID_IMERawInputUnderlineStyle:
+        case eIntID_IMEConvertedTextUnderlineStyle:
+            aResult = NS_STYLE_TEXT_DECORATION_STYLE_SOLID;
+            break;
+
+        case eIntID_IMESelectedRawTextUnderlineStyle:
+        case eIntID_IMESelectedConvertedTextUnderline:
+            aResult = NS_STYLE_TEXT_DECORATION_STYLE_NONE;
+            break;
+
+        case eIntID_SpellCheckerUnderlineStyle:
+            aResult = NS_STYLE_TEXT_DECORATION_STYLE_WAVY;
+            break;
+
+        case eIntID_ScrollbarButtonAutoRepeatBehavior:
+            aResult = 0;
+            break;
+        
+        case eIntID_ContextMenuOffsetVertical:
+        case eIntID_ContextMenuOffsetHorizontal:
+            aResult = 2;
+            break;
+
+        default:
+            aResult = 0;
+            rv = NS_ERROR_FAILURE;
+    }
+
+    return rv;
+}
+
+nsresult
+nsLookAndFeel::GetFloatImpl(FloatID aID, float &aResult)
+{
+  nsresult res = nsXPLookAndFeel::GetFloatImpl(aID, aResult);
+  if (NS_SUCCEEDED(res))
+    return res;
+  res = NS_OK;
+
+  switch (aID) {
+    case eFloatID_IMEUnderlineRelativeSize:
+        aResult = 1.0f;
+        break;
+    case eFloatID_SpellCheckerUnderlineRelativeSize:
+        aResult = 1.0f;
+        break;
+    default:
+        aResult = -1.0;
+        res = NS_ERROR_FAILURE;
+    }
+  return res;
+}
+
+/*virtual*/
+bool
+nsLookAndFeel::GetFontImpl(FontID aID, nsString& aFontName,
+                           gfxFontStyle& aFontStyle,
+                           float aDevPixPerCSSPixel)
+{
+  QFont qFont = QGuiApplication::font();
+
+  NS_NAMED_LITERAL_STRING(quote, "\"");
+  nsString family((char16_t*)qFont.family().data());
+  aFontName = quote + family + quote;
+
+  aFontStyle.systemFont = true;
+  aFontStyle.style = qFont.style();
+  aFontStyle.weight = qFont.weight();
+  aFontStyle.stretch = qFont.stretch();
+  // use pixel size directly if it is set, otherwise compute from point size
+  if (qFont.pixelSize() != -1) {
+    aFontStyle.size = qFont.pixelSize();
+  } else {
+    aFontStyle.size = qFont.pointSizeF() * qApp->primaryScreen()->logicalDotsPerInch() / 72.0f;
+  }
+
+  return true;
+}
+
+/*virtual*/
+bool
+nsLookAndFeel::GetEchoPasswordImpl() {
+    return true;
+}
+
+/*virtual*/
+uint32_t
+nsLookAndFeel::GetPasswordMaskDelayImpl()
+{
+    // Same value on Android framework
+    return 1500;
+}
+
+/* virtual */
+char16_t
+nsLookAndFeel::GetPasswordCharacterImpl()
+{
+    return UNICODE_BULLET;
+}
diff --git a/widget/qt/nsLookAndFeel.h b/widget/qt/nsLookAndFeel.h
new file mode 100644
index 000000000000..323addfe1942
--- /dev/null
+++ b/widget/qt/nsLookAndFeel.h
@@ -0,0 +1,42 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* Copyright 2012 Mozilla Foundation and Mozilla contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __nsLookAndFeel
+#define __nsLookAndFeel
+
+#include "nsXPLookAndFeel.h"
+
+class nsLookAndFeel : public nsXPLookAndFeel
+{
+public:
+    nsLookAndFeel();
+    virtual ~nsLookAndFeel();
+
+    void NativeInit() final;
+
+    virtual bool GetFontImpl(FontID aID, nsString& aName, gfxFontStyle& aStyle,
+                             float aDevPixPerCSSPixel);
+    virtual nsresult GetIntImpl(IntID aID, int32_t &aResult);
+    virtual nsresult GetFloatImpl(FloatID aID, float &aResult);
+    virtual bool GetEchoPasswordImpl();
+    virtual uint32_t GetPasswordMaskDelayImpl();
+    virtual char16_t GetPasswordCharacterImpl();
+
+protected:
+    virtual nsresult NativeGetColor(ColorID aID, nscolor &aColor);
+};
+
+#endif
diff --git a/widget/qt/nsPrintDialogQt.cpp b/widget/qt/nsPrintDialogQt.cpp
new file mode 100644
index 000000000000..979c48c04862
--- /dev/null
+++ b/widget/qt/nsPrintDialogQt.cpp
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsPrintSettingsQt.h"
+#include "nsPrintDialogQt.h"
+
+// For Qt, we only support printing to PDF, and that doesn't need a
+// print dialog at this point.  So, this class's methods are left
+// un-implemented for now.
+
+NS_IMPL_ISUPPORTS(nsPrintDialogServiceQt, nsIPrintDialogService)
+
+nsPrintDialogServiceQt::nsPrintDialogServiceQt()
+{
+}
+
+nsPrintDialogServiceQt::~nsPrintDialogServiceQt()
+{
+}
+
+NS_IMETHODIMP
+nsPrintDialogServiceQt::Init()
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsPrintDialogServiceQt::Show(nsPIDOMWindowOuter *aParent,
+                             nsIPrintSettings* aSettings,
+                             nsIWebBrowserPrint* aWebBrowserPrint)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsPrintDialogServiceQt::ShowPageSetup(nsPIDOMWindowOuter* aParent,
+                                      nsIPrintSettings* aNSSettings)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/widget/qt/nsPrintDialogQt.h b/widget/qt/nsPrintDialogQt.h
new file mode 100644
index 000000000000..9c35fa2683fa
--- /dev/null
+++ b/widget/qt/nsPrintDialogQt.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsPrintDialogQt_h__
+#define nsPrintDialogQt_h__
+
+#include "nsIPrintDialogService.h"
+
+class nsIPrintSettings;
+
+class nsPrintDialogServiceQt : public nsIPrintDialogService
+{
+public:
+    nsPrintDialogServiceQt();
+
+    NS_DECL_ISUPPORTS
+
+    NS_IMETHODIMP Init() override;
+    NS_IMETHODIMP Show(nsPIDOMWindowOuter* aParent,
+                       nsIPrintSettings* aSettings,
+                       nsIWebBrowserPrint* aWebBrowserPrint) override;
+    NS_IMETHODIMP ShowPageSetup(nsPIDOMWindowOuter *aParent,
+                                nsIPrintSettings* aSettings) override;
+
+protected:
+    virtual ~nsPrintDialogServiceQt();
+};
+
+#endif
diff --git a/widget/qt/nsPrintOptionsQt.cpp b/widget/qt/nsPrintOptionsQt.cpp
new file mode 100644
index 000000000000..89673dd74d79
--- /dev/null
+++ b/widget/qt/nsPrintOptionsQt.cpp
@@ -0,0 +1,23 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#include "nsPrintSettingsQt.h"
+#include "nsPrintOptionsQt.h"
+
+nsPrintOptionsQt::nsPrintOptionsQt()
+{
+}
+
+nsPrintOptionsQt::~nsPrintOptionsQt()
+{
+}
+
+nsresult nsPrintOptionsQt::_CreatePrintSettings(nsIPrintSettings** _retval)
+{
+    nsPrintSettingsQt* printSettings =
+        new nsPrintSettingsQt(); // does not initially ref count
+    NS_ADDREF(*_retval = printSettings); // ref count
+    return NS_OK;
+}
diff --git a/widget/qt/nsPrintOptionsQt.h b/widget/qt/nsPrintOptionsQt.h
new file mode 100644
index 000000000000..72e189567039
--- /dev/null
+++ b/widget/qt/nsPrintOptionsQt.h
@@ -0,0 +1,20 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsPrintOptionsQt_h__
+#define nsPrintOptionsQt_h__
+
+#include "nsPrintSettingsService.h"
+
+class nsPrintOptionsQt : public nsPrintSettingsService
+{
+public:
+    nsPrintOptionsQt();
+    virtual ~nsPrintOptionsQt();
+    virtual nsresult _CreatePrintSettings(nsIPrintSettings** _retval);
+};
+
+#endif /* nsPrintOptionsQt_h__ */
diff --git a/widget/qt/nsPrintSettingsQt.cpp b/widget/qt/nsPrintSettingsQt.cpp
new file mode 100644
index 000000000000..7ab665bb1f54
--- /dev/null
+++ b/widget/qt/nsPrintSettingsQt.cpp
@@ -0,0 +1,411 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QPageLayout>
+#include <QRectF>
+#include <QDebug>
+#include "nsPrintSettingsQt.h"
+#include "nsIFile.h"
+#include "nsCRTGlue.h"
+
+NS_IMPL_ISUPPORTS_INHERITED(nsPrintSettingsQt,
+                            nsPrintSettings,
+                            nsPrintSettingsQt)
+
+nsPrintSettingsQt::nsPrintSettingsQt():
+    mPageLayout(new QPageLayout(QPageSize(QPageSize::A4), QPageLayout::Portrait, QMarginsF()))
+{
+}
+
+nsPrintSettingsQt::~nsPrintSettingsQt()
+{
+    //smart pointer should take care of cleanup
+}
+
+nsPrintSettingsQt::nsPrintSettingsQt(const nsPrintSettingsQt& aPS):
+    mPageLayout(aPS.mPageLayout),
+    mFilename(aPS.mFilename),
+    mPrinterName(aPS.mPrinterName),
+    mNumCopies(aPS.mNumCopies),
+    mStartPageRange(aPS.mStartPageRange),
+    mEndPageRange(aPS.mEndPageRange),
+    mPrintRange(aPS.mPrintRange),
+    mPrintInColor(aPS.mPrintInColor),
+    mPrintReversed(aPS.mPrintReversed)
+{
+}
+
+nsPrintSettingsQt& 
+nsPrintSettingsQt::operator=(const nsPrintSettingsQt& rhs)
+{
+    if (this == &rhs) {
+        return *this;
+    }
+
+    nsPrintSettings::operator=(rhs);
+    mPageLayout = rhs.mPageLayout;
+    mFilename = rhs.mFilename;
+    mPrinterName = rhs.mPrinterName;
+    mNumCopies = rhs.mNumCopies;
+    mStartPageRange = rhs.mStartPageRange;
+    mEndPageRange = rhs.mEndPageRange;
+    mPrintRange = rhs.mPrintRange;
+    mPrintInColor = rhs.mPrintInColor;
+    mPrintReversed = rhs.mPrintReversed;
+    return *this;
+}
+
+nsresult 
+nsPrintSettingsQt::_Clone(nsIPrintSettings** _retval)
+{
+    NS_ENSURE_ARG_POINTER(_retval);
+
+    nsPrintSettingsQt* newSettings = new nsPrintSettingsQt(*this);
+    *_retval = newSettings;
+    NS_ADDREF(*_retval);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::_Assign(nsIPrintSettings* aPS)
+{
+    nsPrintSettingsQt* printSettingsQt = static_cast<nsPrintSettingsQt*>(aPS);
+    if (!printSettingsQt)
+        return NS_ERROR_UNEXPECTED;
+    *this = *printSettingsQt;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPrintRange(int16_t* aPrintRange)
+{
+    NS_ENSURE_ARG_POINTER(aPrintRange);
+    *aPrintRange = mPrintRange;
+    return NS_OK;
+}
+
+NS_IMETHODIMP 
+nsPrintSettingsQt::SetPrintRange(int16_t aPrintRange)
+{
+    mPrintRange = aPrintRange;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetStartPageRange(int32_t* aStartPageRange)
+{
+    NS_ENSURE_ARG_POINTER(aStartPageRange);
+    *aStartPageRange = mStartPageRange;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetStartPageRange(int32_t aStartPageRange)
+{
+    mStartPageRange = aStartPageRange;
+    if (mStartPageRange > mEndPageRange) {
+        qWarning() << "nsPrintSettingsQt::SetStartPageRange: 'StartPageRange' must be less than or equal to 'EndPageRange'";
+        mEndPageRange = mStartPageRange;
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetEndPageRange(int32_t* aEndPageRange)
+{
+    NS_ENSURE_ARG_POINTER(aEndPageRange);
+    *aEndPageRange = mEndPageRange;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetEndPageRange(int32_t aEndPageRange)
+{
+    mEndPageRange = aEndPageRange;
+    if (mStartPageRange > mEndPageRange) {
+        qWarning() << "nsPrintSettingsQt::SetEndPageRange: 'EndPageRange' must be more than or equal to 'mStartPageRange'";
+        mStartPageRange = mEndPageRange;
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPrintReversed(bool* aPrintReversed)
+{
+    NS_ENSURE_ARG_POINTER(aPrintReversed);
+    *aPrintReversed = mPrintReversed;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPrintReversed(bool aPrintReversed)
+{
+    mPrintReversed = aPrintReversed;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPrintInColor(bool* aPrintInColor)
+{
+    NS_ENSURE_ARG_POINTER(aPrintInColor);
+    *aPrintInColor = mPrintInColor;
+    return NS_OK;
+}
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPrintInColor(bool aPrintInColor)
+{
+    mPrintInColor = aPrintInColor;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetOrientation(int32_t* aOrientation)
+{
+    NS_ENSURE_ARG_POINTER(aOrientation);
+    *aOrientation = (mPageLayout->orientation() == QPageLayout::Landscape) ?
+                kLandscapeOrientation :
+                kPortraitOrientation;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetOrientation(int32_t aOrientation)
+{
+    if (aOrientation == kLandscapeOrientation) {
+        mPageLayout->setOrientation(QPageLayout::Landscape);
+    } else {
+        mPageLayout->setOrientation(QPageLayout::Portrait);
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetToFileName(nsAString &aToFileName)
+{
+    aToFileName = nsDependentString((char16_t*)mFilename.data());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetToFileName(const nsAString &aToFileName)
+{
+    nsCOMPtr<nsIFile> file;
+    nsresult rv = NS_NewLocalFile(aToFileName, true,
+                                getter_AddRefs(file));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    NS_ConvertUTF16toUTF8 fileNameCStr(aToFileName);
+    mFilename = QString(fileNameCStr.get());
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPrinterName(nsAString &aPrinter)
+{
+    aPrinter = nsDependentString((const char16_t*)mPrinterName.constData());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPrinterName(const nsAString &aPrinter)
+{
+    NS_ConvertUTF16toUTF8 printer(aPrinter);
+    mPrinterName = QString(printer.get());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetNumCopies(int32_t* aNumCopies)
+{
+    NS_ENSURE_ARG_POINTER(aNumCopies);
+    *aNumCopies = mNumCopies;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetNumCopies(int32_t aNumCopies)
+{
+    mNumCopies = aNumCopies;
+    if (mNumCopies < 1) {
+        qWarning() << "nsPrintSettingsQt::SetNumCopies: 'NumCopies' must be greater than 0";
+        mNumCopies = 1;
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetScaling(double* aScaling)
+{
+    NS_ENSURE_ARG_POINTER(aScaling);
+    qDebug() << Q_FUNC_INFO;
+    qDebug() << "Scaling not implemented in Qt port";
+    *aScaling = 1.0; //FIXME
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetScaling(double aScaling)
+{
+    qDebug() << Q_FUNC_INFO;
+    qDebug() << "Scaling not implemented in Qt port"; //FIXME
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static const char* const indexToPaperName[] =
+{ "A4", "B5", "Letter", "Legal", "Executive",
+  "A0", "A1", "A2", "A3", "A5", "A6", "A7", "A8", "A9",
+  "B0", "B1", "B10", "B2", "B3", "B4", "B6", "B7", "B8", "B9",
+  "C5E", "Comm10E", "DLE", "Folio", "Ledger", "Tabloid"
+};
+
+static const QPageSize::PageSizeId indexToQtPaperEnum[] =
+{
+    QPageSize::A4, QPageSize::B5, QPageSize::Letter, QPageSize::Legal,
+    QPageSize::Executive, QPageSize::A0, QPageSize::A1, QPageSize::A2, QPageSize::A3,
+    QPageSize::A5, QPageSize::A6, QPageSize::A7, QPageSize::A8, QPageSize::A9,
+    QPageSize::B0, QPageSize::B1, QPageSize::B10, QPageSize::B2, QPageSize::B3,
+    QPageSize::B4, QPageSize::B6, QPageSize::B7, QPageSize::B8, QPageSize::B9,
+    QPageSize::C5E, QPageSize::Comm10E, QPageSize::DLE, QPageSize::Folio,
+    QPageSize::Ledger, QPageSize::Tabloid
+};
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPaperName(nsAString &aPaperName)
+{
+    QPageSize::PageSizeId size = mPageLayout->pageSize().id();
+    QString name(indexToPaperName[size]);
+    aPaperName = nsDependentString((const char16_t*)name.constData());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPaperName(const nsAString &aPaperName)
+{
+    NS_ConvertUTF16toUTF8 paperName(aPaperName);
+    QString ref(paperName.get());
+    for (uint32_t i = 0; i < sizeof(indexToPaperName)/sizeof(char*); i++)
+    {
+        if (ref == QString(indexToPaperName[i])) {
+            mPageLayout->setPageSize(QPageSize(indexToQtPaperEnum[i]));
+            return NS_OK;
+        }
+    }
+    return NS_ERROR_FAILURE;
+}
+
+QPageLayout::Unit GetQtUnit(int16_t aGeckoUnit)
+{
+    if (aGeckoUnit == nsIPrintSettings::kPaperSizeMillimeters) {
+        return QPageLayout::Millimeter;
+    } else {
+        return QPageLayout::Inch;
+    }
+}
+
+#define SETUNWRITEABLEMARGIN\
+    mPageLayout->setUnits(QPageLayout::Inch);\
+    mPageLayout->setMargins(QMarginsF(\
+            NS_TWIPS_TO_INCHES(mUnwriteableMargin.left),\
+            NS_TWIPS_TO_INCHES(mUnwriteableMargin.top),\
+            NS_TWIPS_TO_INCHES(mUnwriteableMargin.right),\
+            NS_TWIPS_TO_INCHES(mUnwriteableMargin.bottom)));
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetUnwriteableMarginInTwips(nsIntMargin& aUnwriteableMargin)
+{
+    nsPrintSettings::SetUnwriteableMarginInTwips(aUnwriteableMargin);
+    SETUNWRITEABLEMARGIN
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetUnwriteableMarginTop(double aUnwriteableMarginTop)
+{
+    nsPrintSettings::SetUnwriteableMarginTop(aUnwriteableMarginTop);
+    SETUNWRITEABLEMARGIN
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetUnwriteableMarginLeft(double aUnwriteableMarginLeft)
+{
+    nsPrintSettings::SetUnwriteableMarginLeft(aUnwriteableMarginLeft);
+    SETUNWRITEABLEMARGIN
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetUnwriteableMarginBottom(double aUnwriteableMarginBottom)
+{
+    nsPrintSettings::SetUnwriteableMarginBottom(aUnwriteableMarginBottom);
+    SETUNWRITEABLEMARGIN
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetUnwriteableMarginRight(double aUnwriteableMarginRight)
+{
+    nsPrintSettings::SetUnwriteableMarginRight(aUnwriteableMarginRight);
+    SETUNWRITEABLEMARGIN
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPaperWidth(double* aPaperWidth)
+{
+    NS_ENSURE_ARG_POINTER(aPaperWidth);
+    *aPaperWidth = mPageLayout->fullRect(GetQtUnit(mPaperSizeUnit)).width();
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPaperWidth(double aPaperWidth)
+{
+    QSizeF papersize = mPageLayout->fullRect(GetQtUnit(mPaperSizeUnit)).size();
+    papersize.setWidth(aPaperWidth);
+    mPageLayout->setPageSize(QPageSize(papersize, (QPageSize::Unit)GetQtUnit(mPaperSizeUnit)));
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetPaperHeight(double* aPaperHeight)
+{
+    NS_ENSURE_ARG_POINTER(aPaperHeight);
+    *aPaperHeight = mPageLayout->fullRect(GetQtUnit(mPaperSizeUnit)).height();
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPaperHeight(double aPaperHeight)
+{
+    QSizeF papersize = mPageLayout->fullRect(GetQtUnit(mPaperSizeUnit)).size();
+    papersize.setHeight(aPaperHeight);
+    mPageLayout->setPageSize(QPageSize(papersize, (QPageSize::Unit)GetQtUnit(mPaperSizeUnit)));
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::SetPaperSizeUnit(int16_t aPaperSizeUnit)
+{
+    mPaperSizeUnit = aPaperSizeUnit;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPrintSettingsQt::GetEffectivePageSize(double* aWidth, double* aHeight)
+{
+    QSizeF papersize = mPageLayout->fullRect(QPageLayout::Inch).size();
+    if (mPageLayout->orientation() == QPageLayout::Landscape) {
+        *aWidth  = NS_INCHES_TO_INT_TWIPS(papersize.height());
+        *aHeight = NS_INCHES_TO_INT_TWIPS(papersize.width());
+    } else {
+        *aWidth  = NS_INCHES_TO_INT_TWIPS(papersize.width());
+        *aHeight = NS_INCHES_TO_INT_TWIPS(papersize.height());
+    }
+    return NS_OK;
+}
+
diff --git a/widget/qt/nsPrintSettingsQt.h b/widget/qt/nsPrintSettingsQt.h
new file mode 100644
index 000000000000..bc6c6791b1a3
--- /dev/null
+++ b/widget/qt/nsPrintSettingsQt.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsPrintSettingsQt_h_
+#define nsPrintSettingsQt_h_
+
+#include <QSharedPointer>
+#include "nsPrintSettingsImpl.h"
+#define NS_PRINTSETTINGSQT_IID \
+{0x5bc4c746, 0x8970, 0x43a3, {0xbf, 0xb1, 0x5d, 0xe1, 0x74, 0xaf, 0x7c, 0xea}}
+
+class QPageLayout;
+class nsPrintSettingsQt : public nsPrintSettings
+{
+public:
+    NS_DECL_ISUPPORTS_INHERITED
+    NS_DECLARE_STATIC_IID_ACCESSOR(NS_PRINTSETTINGSQT_IID)
+
+    nsPrintSettingsQt();
+
+    NS_IMETHOD GetPrintRange(int16_t* aPrintRange) override;
+    NS_IMETHOD SetPrintRange(int16_t aPrintRange) override;
+
+    NS_IMETHOD GetStartPageRange(int32_t* aStartPageRange) override;
+    NS_IMETHOD SetStartPageRange(int32_t aStartPageRange) override;
+    NS_IMETHOD GetEndPageRange(int32_t* aEndPageRange) override;
+    NS_IMETHOD SetEndPageRange(int32_t aEndPageRange) override;
+
+    NS_IMETHOD GetPrintReversed(bool* aPrintReversed) override;
+    NS_IMETHOD SetPrintReversed(bool aPrintReversed) override;
+
+    NS_IMETHOD GetPrintInColor(bool* aPrintInColor) override;
+    NS_IMETHOD SetPrintInColor(bool aPrintInColor) override;
+
+    NS_IMETHOD GetOrientation(int32_t* aOrientation) override;
+    NS_IMETHOD SetOrientation(int32_t aOrientation) override;
+
+    NS_IMETHOD GetToFileName(nsAString &aToFileName) override;
+    NS_IMETHOD SetToFileName(const nsAString &aToFileName) override;
+
+    NS_IMETHOD GetPrinterName(nsAString &aPrinter) override;
+    NS_IMETHOD SetPrinterName(const nsAString &aPrinter) override;
+
+    NS_IMETHOD GetNumCopies(int32_t* aNumCopies) override;
+    NS_IMETHOD SetNumCopies(int32_t aNumCopies) override;
+
+    NS_IMETHOD GetScaling(double* aScaling) override;
+    NS_IMETHOD SetScaling(double aScaling) override;
+
+    NS_IMETHOD GetPaperName(nsAString &aPaperName) override;
+    NS_IMETHOD SetPaperName(const nsAString &aPaperName) override;
+
+    NS_IMETHOD SetUnwriteableMarginInTwips(nsIntMargin& aUnwriteableMargin) override;
+    NS_IMETHOD SetUnwriteableMarginTop(double aUnwriteableMarginTop) override;
+    NS_IMETHOD SetUnwriteableMarginLeft(double aUnwriteableMarginLeft) override;
+    NS_IMETHOD SetUnwriteableMarginBottom(double aUnwriteableMarginBottom) override;
+    NS_IMETHOD SetUnwriteableMarginRight(double aUnwriteableMarginRight) override;
+
+    NS_IMETHOD GetPaperWidth(double* aPaperWidth) override;
+    NS_IMETHOD SetPaperWidth(double aPaperWidth) override;
+
+    NS_IMETHOD GetPaperHeight(double* aPaperHeight) override;
+    NS_IMETHOD SetPaperHeight(double aPaperHeight) override;
+
+    NS_IMETHOD SetPaperSizeUnit(int16_t aPaperSizeUnit) override;
+
+    NS_IMETHOD GetEffectivePageSize(double* aWidth, double* aHeight) override;
+
+protected:
+    virtual ~nsPrintSettingsQt();
+
+    nsPrintSettingsQt(const nsPrintSettingsQt& src);
+    nsPrintSettingsQt& operator=(const nsPrintSettingsQt& rhs);
+
+    virtual nsresult _Clone(nsIPrintSettings** _retval) override;
+    virtual nsresult _Assign(nsIPrintSettings* aPS) override;
+
+    QSharedPointer<QPageLayout> mPageLayout;
+    QString mFilename;
+    QString mPrinterName;
+    int32_t mNumCopies = 1;
+    int32_t mStartPageRange = 0;
+    int32_t mEndPageRange = 0;
+    int16_t mPrintRange = 0;
+    bool mPrintInColor = true;
+    bool mPrintReversed = false;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsPrintSettingsQt, NS_PRINTSETTINGSQT_IID)
+#endif // nsPrintSettingsQt_h_
diff --git a/widget/qt/nsQtKeyUtils.cpp b/widget/qt/nsQtKeyUtils.cpp
new file mode 100644
index 000000000000..931075f5a12f
--- /dev/null
+++ b/widget/qt/nsQtKeyUtils.cpp
@@ -0,0 +1,480 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <qnamespace.h>
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/TextEvents.h"
+
+#include "nsWindow.h"
+#include "nsQtKeyUtils.h"
+
+using namespace mozilla;
+using namespace mozilla::widget;
+
+struct nsKeyConverter
+{
+    int vkCode; // Platform independent key code
+    int keysym; // Qt key code
+};
+
+static struct nsKeyConverter nsKeycodes[] =
+{
+//  { NS_VK_CANCEL,        Qt::Key_Cancel },
+    { NS_VK_BACK,          Qt::Key_Backspace },
+    { NS_VK_TAB,           Qt::Key_Tab },
+    { NS_VK_TAB,           Qt::Key_Backtab },
+//  { NS_VK_CLEAR,         Qt::Key_Clear },
+    { NS_VK_RETURN,        Qt::Key_Return },
+    { NS_VK_RETURN,        Qt::Key_Enter },
+    { NS_VK_SHIFT,         Qt::Key_Shift },
+    { NS_VK_CONTROL,       Qt::Key_Control },
+    { NS_VK_ALT,           Qt::Key_Alt },
+    { NS_VK_PAUSE,         Qt::Key_Pause },
+    { NS_VK_CAPS_LOCK,     Qt::Key_CapsLock },
+    { NS_VK_ESCAPE,        Qt::Key_Escape },
+    { NS_VK_SPACE,         Qt::Key_Space },
+    { NS_VK_PAGE_UP,       Qt::Key_PageUp },
+    { NS_VK_PAGE_DOWN,     Qt::Key_PageDown },
+    { NS_VK_END,           Qt::Key_End },
+    { NS_VK_HOME,          Qt::Key_Home },
+    { NS_VK_LEFT,          Qt::Key_Left },
+    { NS_VK_UP,            Qt::Key_Up },
+    { NS_VK_RIGHT,         Qt::Key_Right },
+    { NS_VK_DOWN,          Qt::Key_Down },
+    { NS_VK_PRINTSCREEN,   Qt::Key_Print },
+    { NS_VK_INSERT,        Qt::Key_Insert },
+    { NS_VK_DELETE,        Qt::Key_Delete },
+    { NS_VK_HELP,          Qt::Key_Help },
+
+    { NS_VK_0,             Qt::Key_0 },
+    { NS_VK_1,             Qt::Key_1 },
+    { NS_VK_2,             Qt::Key_2 },
+    { NS_VK_3,             Qt::Key_3 },
+    { NS_VK_4,             Qt::Key_4 },
+    { NS_VK_5,             Qt::Key_5 },
+    { NS_VK_6,             Qt::Key_6 },
+    { NS_VK_7,             Qt::Key_7 },
+    { NS_VK_8,             Qt::Key_8 },
+    { NS_VK_9,             Qt::Key_9 },
+
+    { NS_VK_SEMICOLON,     Qt::Key_Semicolon },
+    { NS_VK_EQUALS,        Qt::Key_Equal },
+
+    { NS_VK_A,             Qt::Key_A },
+    { NS_VK_B,             Qt::Key_B },
+    { NS_VK_C,             Qt::Key_C },
+    { NS_VK_D,             Qt::Key_D },
+    { NS_VK_E,             Qt::Key_E },
+    { NS_VK_F,             Qt::Key_F },
+    { NS_VK_G,             Qt::Key_G },
+    { NS_VK_H,             Qt::Key_H },
+    { NS_VK_I,             Qt::Key_I },
+    { NS_VK_J,             Qt::Key_J },
+    { NS_VK_K,             Qt::Key_K },
+    { NS_VK_L,             Qt::Key_L },
+    { NS_VK_M,             Qt::Key_M },
+    { NS_VK_N,             Qt::Key_N },
+    { NS_VK_O,             Qt::Key_O },
+    { NS_VK_P,             Qt::Key_P },
+    { NS_VK_Q,             Qt::Key_Q },
+    { NS_VK_R,             Qt::Key_R },
+    { NS_VK_S,             Qt::Key_S },
+    { NS_VK_T,             Qt::Key_T },
+    { NS_VK_U,             Qt::Key_U },
+    { NS_VK_V,             Qt::Key_V },
+    { NS_VK_W,             Qt::Key_W },
+    { NS_VK_X,             Qt::Key_X },
+    { NS_VK_Y,             Qt::Key_Y },
+    { NS_VK_Z,             Qt::Key_Z },
+
+    { NS_VK_NUMPAD0,       Qt::Key_0 },
+    { NS_VK_NUMPAD1,       Qt::Key_1 },
+    { NS_VK_NUMPAD2,       Qt::Key_2 },
+    { NS_VK_NUMPAD3,       Qt::Key_3 },
+    { NS_VK_NUMPAD4,       Qt::Key_4 },
+    { NS_VK_NUMPAD5,       Qt::Key_5 },
+    { NS_VK_NUMPAD6,       Qt::Key_6 },
+    { NS_VK_NUMPAD7,       Qt::Key_7 },
+    { NS_VK_NUMPAD8,       Qt::Key_8 },
+    { NS_VK_NUMPAD9,       Qt::Key_9 },
+    { NS_VK_MULTIPLY,      Qt::Key_Asterisk },
+    { NS_VK_ADD,           Qt::Key_Plus },
+//  { NS_VK_SEPARATOR,     Qt::Key_Separator },
+    { NS_VK_SUBTRACT,      Qt::Key_Minus },
+    { NS_VK_DECIMAL,       Qt::Key_Period },
+    { NS_VK_DIVIDE,        Qt::Key_Slash },
+    { NS_VK_F1,            Qt::Key_F1 },
+    { NS_VK_F2,            Qt::Key_F2 },
+    { NS_VK_F3,            Qt::Key_F3 },
+    { NS_VK_F4,            Qt::Key_F4 },
+    { NS_VK_F5,            Qt::Key_F5 },
+    { NS_VK_F6,            Qt::Key_F6 },
+    { NS_VK_F7,            Qt::Key_F7 },
+    { NS_VK_F8,            Qt::Key_F8 },
+    { NS_VK_F9,            Qt::Key_F9 },
+    { NS_VK_F10,           Qt::Key_F10 },
+    { NS_VK_F11,           Qt::Key_F11 },
+    { NS_VK_F12,           Qt::Key_F12 },
+    { NS_VK_F13,           Qt::Key_F13 },
+    { NS_VK_F14,           Qt::Key_F14 },
+    { NS_VK_F15,           Qt::Key_F15 },
+    { NS_VK_F16,           Qt::Key_F16 },
+    { NS_VK_F17,           Qt::Key_F17 },
+    { NS_VK_F18,           Qt::Key_F18 },
+    { NS_VK_F19,           Qt::Key_F19 },
+    { NS_VK_F20,           Qt::Key_F20 },
+    { NS_VK_F21,           Qt::Key_F21 },
+    { NS_VK_F22,           Qt::Key_F22 },
+    { NS_VK_F23,           Qt::Key_F23 },
+    { NS_VK_F24,           Qt::Key_F24 },
+
+    { NS_VK_NUM_LOCK,      Qt::Key_NumLock },
+    { NS_VK_SCROLL_LOCK,   Qt::Key_ScrollLock },
+
+    { NS_VK_COMMA,         Qt::Key_Comma },
+    { NS_VK_PERIOD,        Qt::Key_Period },
+    { NS_VK_SLASH,         Qt::Key_Slash },
+    { NS_VK_BACK_QUOTE,    Qt::Key_QuoteLeft },
+    { NS_VK_OPEN_BRACKET,  Qt::Key_ParenLeft },
+    { NS_VK_CLOSE_BRACKET, Qt::Key_ParenRight },
+    { NS_VK_QUOTE,         Qt::Key_QuoteDbl },
+
+    { NS_VK_META,          Qt::Key_Meta }
+};
+
+int
+QtKeyCodeToDOMKeyCode(int aKeysym)
+{
+    unsigned int i;
+
+    // First, try to handle alphanumeric input, not listed in nsKeycodes:
+    // most likely, more letters will be getting typed in than things in
+    // the key list, so we will look through these first.
+
+    // since X has different key symbols for upper and lowercase letters and
+    // mozilla does not, convert gdk's to mozilla's
+    if (aKeysym >= Qt::Key_A && aKeysym <= Qt::Key_Z)
+        return aKeysym - Qt::Key_A + NS_VK_A;
+
+    // numbers
+    if (aKeysym >= Qt::Key_0 && aKeysym <= Qt::Key_9)
+        return aKeysym - Qt::Key_0 + NS_VK_0;
+
+    // keypad numbers
+//    if (aKeysym >= Qt::Key_KP_0 && aKeysym <= Qt::Key_KP_9)
+//        return aKeysym - Qt::Key_KP_0 + NS_VK_NUMPAD0;
+
+    // misc other things
+    for (i = 0; i < ArrayLength(nsKeycodes); i++) {
+        if (nsKeycodes[i].keysym == aKeysym)
+            return(nsKeycodes[i].vkCode);
+    }
+
+    // function keys
+    if (aKeysym >= Qt::Key_F1 && aKeysym <= Qt::Key_F24)
+        return aKeysym - Qt::Key_F1 + NS_VK_F1;
+
+    return((int)0);
+}
+
+int
+DOMKeyCodeToQtKeyCode(int aKeysym)
+{
+    unsigned int i;
+
+    // First, try to handle alphanumeric input, not listed in nsKeycodes:
+    // most likely, more letters will be getting typed in than things in
+    // the key list, so we will look through these first.
+
+    if (aKeysym >= NS_VK_A && aKeysym <= NS_VK_Z)
+      // gdk and DOM both use the ASCII codes for these keys.
+      return aKeysym;
+
+    // numbers
+    if (aKeysym >= NS_VK_0 && aKeysym <= NS_VK_9)
+      // gdk and DOM both use the ASCII codes for these keys.
+      return aKeysym - Qt::Key_0 + NS_VK_0;
+
+    // keypad numbers
+    if (aKeysym >= NS_VK_NUMPAD0 && aKeysym <= NS_VK_NUMPAD9) {
+      NS_ERROR("keypad numbers conversion not implemented");
+      //return aKeysym - NS_VK_NUMPAD0 + Qt::Key_KP_0;
+      return 0;
+    }
+
+    // misc other things
+    for (i = 0; i < ArrayLength(nsKeycodes); ++i) {
+      if (nsKeycodes[i].vkCode == aKeysym) {
+        return nsKeycodes[i].keysym;
+      }
+    }
+
+    // function keys
+    if (aKeysym >= NS_VK_F1 && aKeysym <= NS_VK_F9)
+      return aKeysym - NS_VK_F1 + Qt::Key_F1;
+
+    return 0;
+}
+
+KeyNameIndex
+QtKeyCodeToDOMKeyNameIndex(int aKeysym)
+{
+    switch (aKeysym) {
+
+#define NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX(aNativeKey, aKeyNameIndex) \
+        case aNativeKey: return aKeyNameIndex;
+
+#include "NativeKeyToDOMKeyName.h"
+
+#undef NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
+
+        case Qt::Key_Exclam:
+        case Qt::Key_QuoteDbl:
+        case Qt::Key_NumberSign:
+        case Qt::Key_Dollar:
+        case Qt::Key_Percent:
+        case Qt::Key_Ampersand:
+        case Qt::Key_Apostrophe:
+        case Qt::Key_ParenLeft:
+        case Qt::Key_ParenRight:
+        case Qt::Key_Asterisk:
+        case Qt::Key_Plus:
+        case Qt::Key_Comma:
+        case Qt::Key_Minus:
+        case Qt::Key_Period:
+        case Qt::Key_Slash:
+        case Qt::Key_0:
+        case Qt::Key_1:
+        case Qt::Key_2:
+        case Qt::Key_3:
+        case Qt::Key_4:
+        case Qt::Key_5:
+        case Qt::Key_6:
+        case Qt::Key_7:
+        case Qt::Key_8:
+        case Qt::Key_9:
+        case Qt::Key_Colon:
+        case Qt::Key_Semicolon:
+        case Qt::Key_Less:
+        case Qt::Key_Equal:
+        case Qt::Key_Greater:
+        case Qt::Key_Question:
+        case Qt::Key_At:
+        case Qt::Key_A:
+        case Qt::Key_B:
+        case Qt::Key_C:
+        case Qt::Key_D:
+        case Qt::Key_E:
+        case Qt::Key_F:
+        case Qt::Key_G:
+        case Qt::Key_H:
+        case Qt::Key_I:
+        case Qt::Key_J:
+        case Qt::Key_K:
+        case Qt::Key_L:
+        case Qt::Key_M:
+        case Qt::Key_N:
+        case Qt::Key_O:
+        case Qt::Key_P:
+        case Qt::Key_Q:
+        case Qt::Key_R:
+        case Qt::Key_S:
+        case Qt::Key_T:
+        case Qt::Key_U:
+        case Qt::Key_V:
+        case Qt::Key_W:
+        case Qt::Key_X:
+        case Qt::Key_Y:
+        case Qt::Key_Z:
+        case Qt::Key_BracketLeft:
+        case Qt::Key_Backslash:
+        case Qt::Key_BracketRight:
+        case Qt::Key_AsciiCircum:
+        case Qt::Key_Underscore:
+        case Qt::Key_QuoteLeft:
+        case Qt::Key_BraceLeft:
+        case Qt::Key_Bar:
+        case Qt::Key_BraceRight:
+        case Qt::Key_AsciiTilde:
+        case Qt::Key_exclamdown:
+        case Qt::Key_cent:
+        case Qt::Key_sterling:
+        case Qt::Key_currency:
+        case Qt::Key_yen:
+        case Qt::Key_brokenbar:
+        case Qt::Key_section:
+        case Qt::Key_diaeresis:
+        case Qt::Key_copyright:
+        case Qt::Key_ordfeminine:
+        case Qt::Key_guillemotleft:
+        case Qt::Key_notsign:
+        case Qt::Key_hyphen:
+        case Qt::Key_registered:
+        case Qt::Key_macron:
+        case Qt::Key_degree:
+        case Qt::Key_plusminus:
+        case Qt::Key_twosuperior:
+        case Qt::Key_threesuperior:
+        case Qt::Key_acute:
+        case Qt::Key_mu:
+        case Qt::Key_paragraph:
+        case Qt::Key_periodcentered:
+        case Qt::Key_cedilla:
+        case Qt::Key_onesuperior:
+        case Qt::Key_masculine:
+        case Qt::Key_guillemotright:
+        case Qt::Key_onequarter:
+        case Qt::Key_onehalf:
+        case Qt::Key_threequarters:
+        case Qt::Key_questiondown:
+        case Qt::Key_Agrave:
+        case Qt::Key_Aacute:
+        case Qt::Key_Acircumflex:
+        case Qt::Key_Atilde:
+        case Qt::Key_Adiaeresis:
+        case Qt::Key_Aring:
+        case Qt::Key_AE:
+        case Qt::Key_Ccedilla:
+        case Qt::Key_Egrave:
+        case Qt::Key_Eacute:
+        case Qt::Key_Ecircumflex:
+        case Qt::Key_Ediaeresis:
+        case Qt::Key_Igrave:
+        case Qt::Key_Iacute:
+        case Qt::Key_Icircumflex:
+        case Qt::Key_Idiaeresis:
+        case Qt::Key_ETH:
+        case Qt::Key_Ntilde:
+        case Qt::Key_Ograve:
+        case Qt::Key_Oacute:
+        case Qt::Key_Ocircumflex:
+        case Qt::Key_Otilde:
+        case Qt::Key_Odiaeresis:
+        case Qt::Key_multiply:
+        case Qt::Key_Ooblique:
+        case Qt::Key_Ugrave:
+        case Qt::Key_Uacute:
+        case Qt::Key_Ucircumflex:
+        case Qt::Key_Udiaeresis:
+        case Qt::Key_Yacute:
+        case Qt::Key_THORN:
+        case Qt::Key_ssharp:
+        case Qt::Key_division:
+        case Qt::Key_ydiaeresis:
+            return KEY_NAME_INDEX_PrintableKey;
+
+        case Qt::Key_Backtab:
+        case Qt::Key_Direction_L:
+        case Qt::Key_Direction_R:
+        case Qt::Key_Touroku:
+        case Qt::Key_Massyo:
+        case Qt::Key_Hangul:
+        case Qt::Key_Hangul_Start:
+        case Qt::Key_Hangul_End:
+        case Qt::Key_Hangul_Hanja:
+        case Qt::Key_Hangul_Jamo:
+        case Qt::Key_Hangul_Romaja:
+        case Qt::Key_Hangul_Jeonja:
+        case Qt::Key_Hangul_Banja:
+        case Qt::Key_Hangul_PreHanja:
+        case Qt::Key_Hangul_PostHanja:
+        case Qt::Key_Hangul_Special:
+        case Qt::Key_TrebleUp:
+        case Qt::Key_TrebleDown:
+        case Qt::Key_OpenUrl:
+        case Qt::Key_KeyboardLightOnOff:
+        case Qt::Key_KeyboardBrightnessUp:
+        case Qt::Key_KeyboardBrightnessDown:
+        case Qt::Key_Memo:
+        case Qt::Key_LightBulb:
+        case Qt::Key_Shop:
+        case Qt::Key_History:
+        case Qt::Key_AddFavorite:
+        case Qt::Key_HotLinks:
+        case Qt::Key_Finance:
+        case Qt::Key_Community:
+        case Qt::Key_BackForward:
+        case Qt::Key_ApplicationLeft:
+        case Qt::Key_ApplicationRight:
+        case Qt::Key_Book:
+        case Qt::Key_ToDoList:
+        case Qt::Key_ClearGrab:
+        case Qt::Key_Display:
+        case Qt::Key_DOS:
+        case Qt::Key_Documents:
+        case Qt::Key_Game:
+        case Qt::Key_Go:
+        case Qt::Key_iTouch:
+        case Qt::Key_Market:
+        case Qt::Key_Meeting:
+        case Qt::Key_MenuKB:
+        case Qt::Key_MenuPB:
+        case Qt::Key_MySites:
+        case Qt::Key_News:
+        case Qt::Key_OfficeHome:
+        case Qt::Key_Option:
+        case Qt::Key_Phone:
+        case Qt::Key_RotateWindows:
+        case Qt::Key_RotationPB:
+        case Qt::Key_RotationKB:
+        case Qt::Key_SplitScreen:
+        case Qt::Key_Support:
+        case Qt::Key_TaskPane:
+        case Qt::Key_Terminal:
+        case Qt::Key_Tools:
+        case Qt::Key_Travel:
+        case Qt::Key_Xfer:
+        case Qt::Key_Away:
+        case Qt::Key_Messenger:
+        case Qt::Key_Pictures:
+        case Qt::Key_Battery:
+        case Qt::Key_Bluetooth:
+        case Qt::Key_WLAN:
+        case Qt::Key_UWB:
+        case Qt::Key_AudioRepeat:
+        case Qt::Key_AudioCycleTrack:
+        case Qt::Key_Time:
+        case Qt::Key_View:
+        case Qt::Key_TopMenu:
+        case Qt::Key_ContrastAdjust:
+        case Qt::Key_TouchpadToggle:
+        case Qt::Key_TouchpadOn:
+        case Qt::Key_TouchpadOff:
+        case Qt::Key_unknown:
+        case Qt::Key_Call:
+        case Qt::Key_Context1:
+        case Qt::Key_Context2:
+        case Qt::Key_Context3:
+        case Qt::Key_Context4:
+        case Qt::Key_Flip:
+        case Qt::Key_Hangup:
+        case Qt::Key_No:
+        case Qt::Key_Select:
+        case Qt::Key_Yes:
+        case Qt::Key_ToggleCallHangup:
+        case Qt::Key_VoiceDial:
+        case Qt::Key_LastNumberRedial:
+        default:
+            return KEY_NAME_INDEX_Unidentified;
+    }
+}
+
+CodeNameIndex
+ScanCodeToDOMCodeNameIndex(int32_t aScanCode)
+{
+    switch (aScanCode) {
+
+#define NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX(aNativeKey, aCodeNameIndex) \
+        case aNativeKey: return aCodeNameIndex;
+
+#include "NativeKeyToDOMCodeName.h"
+
+#undef NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
+
+        default:
+            return CODE_NAME_INDEX_UNKNOWN;
+    }
+}
diff --git a/widget/qt/nsQtKeyUtils.h b/widget/qt/nsQtKeyUtils.h
new file mode 100644
index 000000000000..8fdeed975011
--- /dev/null
+++ b/widget/qt/nsQtKeyUtils.h
@@ -0,0 +1,19 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsQtKeyUtils_h__
+#define __nsQtKeyUtils_h__
+
+#include "mozilla/EventForwards.h"
+
+int      QtKeyCodeToDOMKeyCode     (int aKeysym);
+int      DOMKeyCodeToQtKeyCode     (int aKeysym);
+
+mozilla::KeyNameIndex QtKeyCodeToDOMKeyNameIndex(int aKeysym);
+mozilla::CodeNameIndex ScanCodeToDOMCodeNameIndex(int32_t aScanCode);
+
+#endif /* __nsQtKeyUtils_h__ */
diff --git a/widget/qt/nsScreenManagerQt.cpp b/widget/qt/nsScreenManagerQt.cpp
new file mode 100644
index 000000000000..25d2c510e1f1
--- /dev/null
+++ b/widget/qt/nsScreenManagerQt.cpp
@@ -0,0 +1,86 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QGuiApplication>
+#include <QScreen>
+
+#include "nsScreenManagerQt.h"
+#include "nsScreenQt.h"
+
+nsScreenManagerQt::nsScreenManagerQt()
+{
+    mInitialized = false;
+    desktop = 0;
+    screens = 0;
+}
+
+nsScreenManagerQt::~nsScreenManagerQt()
+{
+    delete [] screens;
+}
+
+// addref, release, QI
+NS_IMPL_ISUPPORTS(nsScreenManagerQt, nsIScreenManager)
+
+void nsScreenManagerQt::init()
+{
+    if (mInitialized)
+        return;
+
+    nScreens = QGuiApplication::screens().size();
+    screens = new nsCOMPtr<nsIScreen>[nScreens];
+
+    for (uint32_t i = 0; i < nScreens; ++i)
+        screens[i] = new nsScreenQt(i);
+    mInitialized = true;
+}
+
+//
+// ScreenForRect
+//
+// Returns the screen that contains the rectangle. If the rect overlaps
+// multiple screens, it picks the screen with the greatest area of intersection.
+//
+// The coordinates are in pixels (not twips) and in screen coordinates.
+//
+NS_IMETHODIMP
+nsScreenManagerQt::ScreenForRect(int32_t inLeft, int32_t inTop,
+                                 int32_t inWidth, int32_t inHeight,
+                                 nsIScreen **outScreen)
+{
+    if (!mInitialized)
+        init();
+
+    QRect r(inLeft, inTop, inWidth, inHeight);
+    int best = 0;
+    int area = 0;
+    for (uint32_t i = 0; i < nScreens; ++i) {
+        const QRect& rect = QGuiApplication::screens()[i]->geometry();
+        QRect intersection = r&rect;
+        int a = intersection.width()*intersection.height();
+        if (a > area) {
+            best = i;
+            area = a;
+        }
+    }
+
+    NS_IF_ADDREF(*outScreen = screens[best]);
+    return NS_OK;
+}
+
+//
+// GetPrimaryScreen
+//
+// The screen with the menubar/taskbar. This shouldn't be needed very
+// often.
+//
+NS_IMETHODIMP
+nsScreenManagerQt::GetPrimaryScreen(nsIScreen **aPrimaryScreen)
+{
+    if (!desktop)
+        init();
+
+    NS_IF_ADDREF(*aPrimaryScreen = screens[0]);
+    return NS_OK;
+}
diff --git a/widget/qt/nsScreenManagerQt.h b/widget/qt/nsScreenManagerQt.h
new file mode 100644
index 000000000000..4fe1fe367665
--- /dev/null
+++ b/widget/qt/nsScreenManagerQt.h
@@ -0,0 +1,34 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsScreenManagerQt_h___
+#define nsScreenManagerQt_h___
+
+#include "nsIScreenManager.h"
+#include "nsIScreen.h"
+#include "nsCOMPtr.h"
+
+//------------------------------------------------------------------------
+class QDesktopWidget;
+
+class nsScreenManagerQt : public nsIScreenManager
+{
+public:
+  nsScreenManagerQt ( );
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISCREENMANAGER
+
+private:
+  virtual ~nsScreenManagerQt();
+  void init ();
+
+  nsCOMPtr<nsIScreen> *screens;
+  QDesktopWidget *desktop;
+  uint32_t nScreens;
+  bool mInitialized;
+};
+
+#endif  // nsScreenManagerQt_h___
diff --git a/widget/qt/nsScreenQt.cpp b/widget/qt/nsScreenQt.cpp
new file mode 100644
index 000000000000..095238f24ad2
--- /dev/null
+++ b/widget/qt/nsScreenQt.cpp
@@ -0,0 +1,74 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <QColor>
+#include <QRect>
+#include <QGuiApplication>
+#include <QTransform>
+#include <QScreen>
+
+#include "nsScreenQt.h"
+#include "nsXULAppAPI.h"
+
+nsScreenQt::nsScreenQt(int aScreen)
+    : mScreen(aScreen)
+{
+    // nothing else to do. I guess we could cache a bunch of information
+    // here, but we want to ask the device at runtime in case anything
+    // has changed.
+}
+
+nsScreenQt::~nsScreenQt()
+{
+}
+
+NS_IMETHODIMP
+nsScreenQt::GetId(uint32_t* aId)
+{
+    *aId = mScreen;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenQt::GetRect(int32_t *outLeft,int32_t *outTop,
+                    int32_t *outWidth,int32_t *outHeight)
+{
+    QRect r = QGuiApplication::screens()[mScreen]->geometry();
+
+    *outTop = r.x();
+    *outLeft = r.y();
+    *outWidth = r.width();
+    *outHeight = r.height();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenQt::GetAvailRect(int32_t *outLeft,int32_t *outTop,
+                         int32_t *outWidth,int32_t *outHeight)
+{
+    QRect r = QGuiApplication::screens()[mScreen]->geometry();
+
+    *outTop = r.x();
+    *outLeft = r.y();
+    *outWidth = r.width();
+    *outHeight = r.height();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenQt::GetPixelDepth(int32_t *aPixelDepth)
+{
+    // #############
+    *aPixelDepth = QGuiApplication::primaryScreen()->depth();
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScreenQt::GetColorDepth(int32_t *aColorDepth)
+{
+    // ###############
+    return GetPixelDepth(aColorDepth);
+}
diff --git a/widget/qt/nsScreenQt.h b/widget/qt/nsScreenQt.h
new file mode 100644
index 000000000000..ad3a0ef9af3b
--- /dev/null
+++ b/widget/qt/nsScreenQt.h
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef nsScreenQt_h___
+#define nsScreenQt_h___
+
+#include "nsBaseScreen.h"
+
+//------------------------------------------------------------------------
+
+class nsScreenQt : public nsBaseScreen
+{
+public:
+  nsScreenQt (int aScreen);
+  virtual ~nsScreenQt();
+
+  NS_IMETHOD GetId(uint32_t* aId);
+  NS_IMETHOD GetRect(int32_t* aLeft, int32_t* aTop, int32_t* aWidth, int32_t* aHeight);
+  NS_IMETHOD GetAvailRect(int32_t* aLeft, int32_t* aTop, int32_t* aWidth, int32_t* aHeight);
+  NS_IMETHOD GetPixelDepth(int32_t* aPixelDepth);
+  NS_IMETHOD GetColorDepth(int32_t* aColorDepth);
+
+private:
+  int mScreen;
+};
+
+#endif  // nsScreenQt_h___
diff --git a/widget/qt/nsWidgetFactory.cpp b/widget/qt/nsWidgetFactory.cpp
new file mode 100644
index 000000000000..87817a0b4a5f
--- /dev/null
+++ b/widget/qt/nsWidgetFactory.cpp
@@ -0,0 +1,162 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* Copyright 2012 Mozilla Foundation and Mozilla contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "base/basictypes.h"
+
+#include "mozilla/ModuleUtils.h"
+#include "mozilla/WidgetUtils.h"
+
+#include "nsCOMPtr.h"
+#include "nsWidgetsCID.h"
+#include "nsAppShell.h"
+
+#include "nsWindow.h"
+#include "nsLookAndFeel.h"
+#include "nsAppShellSingleton.h"
+#include "nsScreenManagerQt.h"
+#include "nsIdleServiceQt.h"
+#include "nsTransferable.h"
+#include "nsBidiKeyboard.h"
+
+#include "nsHTMLFormatConverter.h"
+#include "nsXULAppAPI.h"
+
+#ifdef NS_PRINTING
+#include "nsDeviceContextSpecQt.h"
+#include "nsPrintSession.h"
+#include "nsPrintOptionsQt.h"
+#include "nsPrintDialogQt.h"
+#endif
+
+#include "nsClipboard.h"
+#include "nsClipboardHelper.h"
+
+#if defined(MOZ_X11)
+#include "GfxInfoX11.h"
+#else
+#include "GfxInfo.h"
+#endif
+
+using namespace mozilla::widget;
+
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsWindow)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsBidiKeyboard)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsScreenManagerQt)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsHTMLFormatConverter)
+NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsIdleServiceQt, nsIdleServiceQt::GetInstance)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsTransferable)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsClipboard)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsClipboardHelper)
+#ifdef NS_PRINTING
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsDeviceContextSpecQt)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsPrintOptionsQt, Init)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsPrinterEnumeratorQt)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsPrintSession, Init)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsPrintDialogServiceQt, Init)
+#endif
+
+namespace mozilla {
+namespace widget {
+// This constructor should really be shared with all platforms.
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(GfxInfo, Init)
+}
+}
+
+
+NS_DEFINE_NAMED_CID(NS_APPSHELL_CID);
+NS_DEFINE_NAMED_CID(NS_BIDIKEYBOARD_CID);
+NS_DEFINE_NAMED_CID(NS_WINDOW_CID);
+NS_DEFINE_NAMED_CID(NS_CHILD_CID);
+NS_DEFINE_NAMED_CID(NS_SCREENMANAGER_CID);
+NS_DEFINE_NAMED_CID(NS_HTMLFORMATCONVERTER_CID);
+NS_DEFINE_NAMED_CID(NS_IDLE_SERVICE_CID);
+NS_DEFINE_NAMED_CID(NS_TRANSFERABLE_CID);
+NS_DEFINE_NAMED_CID(NS_CLIPBOARD_CID);
+NS_DEFINE_NAMED_CID(NS_CLIPBOARDHELPER_CID);
+NS_DEFINE_NAMED_CID(NS_GFXINFO_CID);
+#ifdef NS_PRINTING
+NS_DEFINE_NAMED_CID(NS_PRINTSETTINGSSERVICE_CID);
+NS_DEFINE_NAMED_CID(NS_PRINTER_ENUMERATOR_CID);
+NS_DEFINE_NAMED_CID(NS_PRINTSESSION_CID);
+NS_DEFINE_NAMED_CID(NS_DEVICE_CONTEXT_SPEC_CID);
+NS_DEFINE_NAMED_CID(NS_PRINTDIALOGSERVICE_CID);
+#endif
+
+static const mozilla::Module::CIDEntry kWidgetCIDs[] = {
+    { &kNS_APPSHELL_CID, false, nullptr, nsAppShellConstructor },
+    { &kNS_BIDIKEYBOARD_CID, false, nullptr, nsBidiKeyboardConstructor },
+    { &kNS_CHILD_CID, false, nullptr, nsWindowConstructor },
+    { &kNS_CLIPBOARD_CID, false, nullptr, nsClipboardConstructor },
+    { &kNS_CLIPBOARDHELPER_CID, false, nullptr, nsClipboardHelperConstructor },
+    { &kNS_HTMLFORMATCONVERTER_CID, false, nullptr, nsHTMLFormatConverterConstructor },
+    { &kNS_IDLE_SERVICE_CID, false, nullptr, nsIdleServiceQtConstructor },
+    { &kNS_SCREENMANAGER_CID, false, nullptr, nsScreenManagerQtConstructor },
+    { &kNS_TRANSFERABLE_CID, false, nullptr, nsTransferableConstructor },
+    { &kNS_WINDOW_CID, false, nullptr, nsWindowConstructor },
+    { &kNS_GFXINFO_CID, false, nullptr, mozilla::widget::GfxInfoConstructor },
+#ifdef NS_PRINTING
+    { &kNS_DEVICE_CONTEXT_SPEC_CID, false, nullptr, nsDeviceContextSpecQtConstructor },
+    { &kNS_PRINTDIALOGSERVICE_CID, false, nullptr, nsPrintDialogServiceQtConstructor },
+    { &kNS_PRINTER_ENUMERATOR_CID, false, nullptr, nsPrinterEnumeratorQtConstructor },
+    { &kNS_PRINTSESSION_CID, false, nullptr, nsPrintSessionConstructor },
+    { &kNS_PRINTSETTINGSSERVICE_CID, false, nullptr, nsPrintOptionsQtConstructor },
+#endif
+    { nullptr }
+};
+
+static const mozilla::Module::ContractIDEntry kWidgetContracts[] = {
+    { "@mozilla.org/gfx/screenmanager;1", &kNS_SCREENMANAGER_CID },
+    { "@mozilla.org/widget/appshell/qt;1", &kNS_APPSHELL_CID },
+    { "@mozilla.org/widget/bidikeyboard;1", &kNS_BIDIKEYBOARD_CID },
+    { "@mozilla.org/widget/clipboard;1", &kNS_CLIPBOARD_CID },
+    { "@mozilla.org/widget/clipboardhelper;1", &kNS_CLIPBOARDHELPER_CID },
+    { "@mozilla.org/widget/htmlformatconverter;1", &kNS_HTMLFORMATCONVERTER_CID },
+    { "@mozilla.org/widget/idleservice;1", &kNS_IDLE_SERVICE_CID },
+    { "@mozilla.org/widgets/child_window/qt;1", &kNS_CHILD_CID },
+    { "@mozilla.org/widgets/window/qt;1", &kNS_WINDOW_CID },
+    { "@mozilla.org/widget/transferable;1", &kNS_TRANSFERABLE_CID },
+    { "@mozilla.org/gfx/info;1", &kNS_GFXINFO_CID },
+#ifdef NS_PRINTING
+    { "@mozilla.org/gfx/devicecontextspec;1", &kNS_DEVICE_CONTEXT_SPEC_CID },
+    { "@mozilla.org/gfx/printerenumerator;1", &kNS_PRINTER_ENUMERATOR_CID },
+    { "@mozilla.org/gfx/printsession;1", &kNS_PRINTSESSION_CID },
+    { "@mozilla.org/gfx/printsettings-service;1", &kNS_PRINTSETTINGSSERVICE_CID },
+    { NS_PRINTDIALOGSERVICE_CONTRACTID, &kNS_PRINTDIALOGSERVICE_CID },
+#endif
+    { nullptr }
+};
+
+static void
+nsWidgetQtModuleDtor()
+{
+    // Shutdown all XP level widget classes.
+    WidgetUtils::Shutdown();
+
+    nsLookAndFeel::Shutdown();
+    nsAppShellShutdown();
+}
+
+static const mozilla::Module kWidgetModule = {
+    mozilla::Module::kVersion,
+    kWidgetCIDs,
+    kWidgetContracts,
+    nullptr,
+    nullptr,
+    nsAppShellInit,
+    nsWidgetQtModuleDtor
+};
+
+NSMODULE_DEFN(nsWidgetQtModule) = &kWidgetModule;
diff --git a/widget/qt/nsWindow.cpp b/widget/qt/nsWindow.cpp
new file mode 100644
index 000000000000..e1a4d6caf591
--- /dev/null
+++ b/widget/qt/nsWindow.cpp
@@ -0,0 +1,1684 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/MiscEvents.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/TextEvents.h"
+#include "mozilla/TouchEvents.h"
+
+#include <QGuiApplication>
+#include <QtGui/QCursor>
+#include <QIcon>
+#include <QMouseEvent>
+#include <QWheelEvent>
+#include <QResizeEvent>
+#include <QPaintEngine>
+#include <QMimeData>
+#include <QScreen>
+
+#include <QtCore/QDebug>
+#include <QtCore/QEvent>
+#include <QtCore/QVariant>
+#include <algorithm>
+
+#include "nsXULAppAPI.h"
+
+#include "prlink.h"
+
+#include "nsWindow.h"
+#include "mozqwidget.h"
+
+#include "nsIdleService.h"
+#include "nsIRollupListener.h"
+#include "nsWidgetsCID.h"
+#include "nsQtKeyUtils.h"
+#include "mozilla/Services.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/Likely.h"
+#include "mozilla/layers/LayersTypes.h"
+#include "nsIWidgetListener.h"
+#include "ClientLayerManager.h"
+#include "BasicLayers.h"
+
+#include "nsIStringBundle.h"
+#include "nsGfxCIID.h"
+
+#include "imgIContainer.h"
+#include "nsGfxCIID.h"
+#include "nsIInterfaceRequestorUtils.h"
+
+#include "gfxQtPlatform.h"
+
+#include "nsIDOMWheelEvent.h"
+
+#include "GLContext.h"
+
+#include "Layers.h"
+#include "GLContextProvider.h"
+
+using namespace mozilla;
+using namespace mozilla::gl;
+using namespace mozilla::widget;
+using namespace mozilla::gfx;
+using namespace mozilla::layers;
+using mozilla::gl::GLContext;
+
+#define kWindowPositionSlop 20
+
+// Qt
+static const int WHEEL_DELTA = 120;
+static bool gGlobalsInitialized = false;
+static bool sAltGrModifier = false;
+
+static void find_first_visible_parent(QWindow* aItem, QWindow*& aVisibleItem);
+static bool is_mouse_in_window (MozQWidget* aWindow, double aMouseX, double aMouseY);
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
+
+nsWindow::nsWindow() {
+    LOG(("%s [%p]\n", __PRETTY_FUNCTION__, (void *)this));
+
+    mIsTopLevel       = false;
+    mIsDestroyed      = false;
+    mIsShown          = false;
+    mEnabled          = true;
+    mWidget              = nullptr;
+    mVisible           = false;
+    mActivatePending     = false;
+    mWindowType          = eWindowType_child;
+    mSizeState           = nsSizeMode_Normal;
+    mLastSizeMode        = nsSizeMode_Normal;
+    mQCursor             = Qt::ArrowCursor;
+    mNeedsResize         = false;
+    mNeedsMove           = false;
+    mListenForResizes    = false;
+    mNeedsShow           = false;
+    mTimerStarted        = false;
+    mMoveEvent.needDispatch = false;
+
+    if (!gGlobalsInitialized) {
+        gfxPlatform::GetPlatform();
+        gGlobalsInitialized = true;
+    }
+
+    memset(mKeyDownFlags, 0, sizeof(mKeyDownFlags));
+
+    mCursor = eCursor_standard;
+}
+
+nsWindow::~nsWindow() {
+    LOG(("%s [%p]\n", __PRETTY_FUNCTION__, (void *)this));
+
+    Destroy();
+}
+
+nsresult nsWindow::Create(nsIWidget* aParent,
+                          nsNativeWidget aNativeParent,
+                          const LayoutDeviceIntRect& aRect,
+                          nsWidgetInitData* aInitData) {
+    // only set the base parent if we're not going to be a dialog or a
+    // toplevel
+    nsIWidget *baseParent = aParent;
+
+    // initialize all the common bits of this class
+    BaseCreate(baseParent, aInitData);
+
+    mVisible = true;
+
+    // and do our common creation
+    mParent = (nsWindow *)aParent;
+
+    // save our bounds
+    mBounds = aRect;
+
+    // find native parent
+    MozQWidget *parent = nullptr;
+
+    if (aParent != nullptr) {
+        parent = static_cast<MozQWidget*>(aParent->GetNativeData(NS_NATIVE_WIDGET));
+    } else if (aNativeParent != nullptr) {
+        parent = static_cast<MozQWidget*>(aNativeParent);
+        if (parent && mParent == nullptr) {
+            mParent = parent->getReceiver();
+        }
+    }
+
+    LOG(("Create: nsWindow [%p] mWidget:[%p] parent:[%p], natPar:[%p] mParent:%p\n", (void *)this, (void*)mWidget, parent, aNativeParent, mParent));
+
+    // ok, create our QGraphicsWidget
+    mWidget = createQWidget(parent, aInitData);
+
+    if (!mWidget) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+
+    // resize so that everything is set to the right dimensions
+    Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
+
+    // check if we should listen for resizes
+    mListenForResizes = (aNativeParent ||
+                         (aInitData && aInitData->mListenForResizes));
+
+    return NS_OK;
+}
+
+MozQWidget* nsWindow::createQWidget(MozQWidget* parent,
+                        nsWidgetInitData* aInitData) {
+    const char *windowName = nullptr;
+    Qt::WindowFlags flags = Qt::Widget;
+
+    // ok, create our windows
+    switch (mWindowType) {
+    case eWindowType_dialog:
+        windowName = "topLevelDialog";
+        flags = Qt::Dialog;
+        break;
+    case eWindowType_popup:
+        windowName = "topLevelPopup";
+        flags = Qt::Popup;
+        break;
+    case eWindowType_toplevel:
+        windowName = "topLevelWindow";
+        flags = Qt::Window;
+        break;
+    case eWindowType_invisible:
+        windowName = "topLevelInvisible";
+        break;
+    case eWindowType_child:
+    case eWindowType_plugin:
+    default: // sheet
+        windowName = "paintArea";
+        break;
+    }
+
+    MozQWidget* widget = new MozQWidget(this, parent);
+    if (!widget) {
+        return nullptr;
+    }
+
+    widget->setObjectName(QString(windowName));
+    if (mWindowType == eWindowType_invisible) {
+        widget->setVisibility(QWindow::Hidden);
+    }
+    if (mWindowType == eWindowType_dialog) {
+        widget->setModality(Qt::WindowModal);
+    }
+
+    widget->create();
+
+    // create a QGraphicsView if this is a new toplevel window
+    LOG(("nsWindow::%s [%p] Created Window: %s, widget:%p, par:%p\n", __FUNCTION__, (void *)this, windowName, widget, parent));
+
+    return widget;
+}
+
+void nsWindow::Destroy() {
+    if (mIsDestroyed || !mWidget) {
+        return;
+    }
+
+    LOG(("nsWindow::Destroy [%p]\n", (void *)this));
+    mIsDestroyed = true;
+
+    /** Need to clean our LayerManager up while still alive */
+    if (mLayerManager) {
+        mLayerManager->Destroy();
+    }
+    mLayerManager = nullptr;
+
+    // It is safe to call DestroyeCompositor several times (here and 
+    // in the parent class) since it will take effect only once.
+    // The reason we call it here is because on gtk platforms we need 
+    // to destroy the compositor before we destroy the gdk window (which
+    // destroys the the gl context attached to it).
+    DestroyCompositor();
+
+    ClearCachedResources();
+
+    nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
+    if (rollupListener) {
+        nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
+        if (static_cast<nsIWidget *>(this) == rollupWidget) {
+            rollupListener->Rollup(0, false, nullptr, nullptr);
+        }
+    }
+
+    Show(false);
+
+    // walk the list of children and call destroy on them.  Have to be
+    // careful, though -- calling destroy on a kid may actually remove
+    // it from our child list, losing its sibling links.
+    for (nsIWidget* kid = mFirstChild; kid; ) {
+        nsIWidget* next = kid->GetNextSibling();
+        kid->Destroy();
+        kid = next;
+    }
+
+    // Destroy thebes surface now. Badness can happen if we destroy
+    // the surface after its X Window.
+    if (mWidget) {
+        mWidget->dropReceiver();
+
+        // Call deleteLater instead of delete; Qt still needs the object
+        // to be valid even after sending it a Close event.  We could
+        // also set WA_DeleteOnClose, but this gives us more control.
+        mWidget->deleteLater();
+    }
+    mWidget = nullptr;
+
+    OnDestroy();
+}
+
+void nsWindow::Show(bool aState) {
+    LOG(("nsWindow::Show [%p] state %d\n", (void *)this, aState));
+    if (aState == mIsShown) {
+        return;
+    }
+
+    // Clear our cached resources when the window is hidden.
+    if (mIsShown && !aState) {
+        ClearCachedResources();
+    }
+
+    mIsShown = aState;
+
+    if ((aState && !AreBoundsSane()) || !mWidget) {
+        LOG(("\tbounds are insane or window hasn't been created yet\n"));
+        mNeedsShow = true;
+        return;
+    }
+
+    if (aState) {
+        if (mNeedsMove) {
+            NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
+                         false);
+        } else if (mNeedsResize) {
+            NativeResize(mBounds.width, mBounds.height, false);
+        }
+    }
+    else {
+        // If someone is hiding this widget, clear any needing show flag.
+        mNeedsShow = false;
+    }
+
+    NativeShow(aState);
+}
+
+bool nsWindow::IsVisible() const {
+    return mIsShown;
+}
+
+void nsWindow::ConstrainPosition(bool aAllowSlop, int32_t *aX, int32_t *aY) {
+    if (!mWidget) {
+        return;
+    }
+
+    int32_t screenWidth  = qApp->primaryScreen()->size().width();
+    int32_t screenHeight = qApp->primaryScreen()->size().height();
+
+    if (aAllowSlop) {
+        if (*aX < (kWindowPositionSlop - mBounds.width))
+            *aX = kWindowPositionSlop - mBounds.width;
+        if (*aX > (screenWidth - kWindowPositionSlop))
+            *aX = screenWidth - kWindowPositionSlop;
+        if (*aY < (kWindowPositionSlop - mBounds.height))
+            *aY = kWindowPositionSlop - mBounds.height;
+        if (*aY > (screenHeight - kWindowPositionSlop))
+            *aY = screenHeight - kWindowPositionSlop;
+    } else {
+        if (*aX < 0)
+            *aX = 0;
+        if (*aX > (screenWidth - mBounds.width))
+            *aX = screenWidth - mBounds.width;
+        if (*aY < 0)
+            *aY = 0;
+        if (*aY > (screenHeight - mBounds.height))
+            *aY = screenHeight - mBounds.height;
+    }
+}
+
+void nsWindow::Move(double aX, double aY) {
+    LOG(("nsWindow::Move [%p] %f %f\n", (void *)this,
+         aX, aY));
+
+    int32_t x = NSToIntRound(aX);
+    int32_t y = NSToIntRound(aY);
+
+    if (mIsTopLevel) {
+        SetSizeMode(nsSizeMode_Normal);
+    }
+
+    if (x == mBounds.x && y == mBounds.y) {
+        return;
+    }
+
+    mNeedsMove = false;
+
+    // update the bounds
+    QPoint pos(x, y);
+    if (mIsTopLevel) {
+        mWidget->setPosition(x, y);
+    }
+    else if (mWidget) {
+        // the position of the widget is set relative to the parent
+        // so we map the coordinates accordingly
+        pos = mWidget->mapToGlobal(pos);
+        mWidget->setPosition(pos);
+    }
+
+    mBounds.x = pos.x();
+    mBounds.y = pos.y();
+
+    NotifyRollupGeometryChange();
+}
+
+void nsWindow::Resize(double aWidth, double aHeight, bool aRepaint) {
+    mBounds.width = NSToIntRound(aWidth);
+    mBounds.height = NSToIntRound(aHeight);
+
+    if (!mWidget)
+        return;
+
+    if (mIsShown) {
+        if (AreBoundsSane()) {
+            if (mIsTopLevel || mNeedsShow)
+                NativeResize(mBounds.x, mBounds.y,
+                             mBounds.width, mBounds.height, aRepaint);
+            else
+                NativeResize(mBounds.width, mBounds.height, aRepaint);
+
+            // Does it need to be shown because it was previously insane?
+            if (mNeedsShow) {
+                NativeShow(true);
+            }
+        }
+        else {
+            // If someone has set this so that the needs show flag is false
+            // and it needs to be hidden, update the flag and hide the
+            // window.  This flag will be cleared the next time someone
+            // hides the window or shows it.  It also prevents us from
+            // calling NativeShow(false) excessively on the window which
+            // causes unneeded X traffic.
+            if (!mNeedsShow) {
+                mNeedsShow = true;
+                NativeShow(false);
+            }
+        }
+    }
+    else if (AreBoundsSane() && mListenForResizes) {
+        // For widgets that we listen for resizes for (widgets created
+        // with native parents) we apparently _always_ have to resize.  I
+        // dunno why, but apparently we're lame like that.
+        NativeResize(mBounds.width, mBounds.height, aRepaint);
+    }
+    else {
+        mNeedsResize = true;
+    }
+
+    // synthesize a resize event if this isn't a toplevel
+    if (mIsTopLevel || mListenForResizes) {
+        nsEventStatus status;
+        DispatchResizeEvent(mBounds, status);
+    }
+
+    NotifyRollupGeometryChange();
+}
+
+void nsWindow::Resize(double aX, double aY, double aWidth, double aHeight,
+                      bool aRepaint) {
+    mBounds.x = NSToIntRound(aX);
+    mBounds.y = NSToIntRound(aY);
+    mBounds.width = NSToIntRound(aWidth);
+    mBounds.height = NSToIntRound(aHeight);
+
+    mPlaced = true;
+
+    if (!mWidget) {
+        return;
+    }
+
+    // Has this widget been set to visible?
+    if (mIsShown) {
+        // Are the bounds sane?
+        if (AreBoundsSane()) {
+            // Yep?  Resize the window
+            NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
+                         aRepaint);
+            // Does it need to be shown because it was previously insane?
+            if (mNeedsShow)
+                NativeShow(true);
+        }
+        else {
+            // If someone has set this so that the needs show flag is false
+            // and it needs to be hidden, update the flag and hide the
+            // window.  This flag will be cleared the next time someone
+            // hides the window or shows it.  It also prevents us from
+            // calling NativeShow(false) excessively on the window which
+            // causes unneeded X traffic.
+            if (!mNeedsShow) {
+                mNeedsShow = true;
+                NativeShow(false);
+            }
+        }
+    }
+    // If the widget hasn't been shown, mark the widget as needing to be
+    // resized before it is shown
+    else if (AreBoundsSane() && mListenForResizes) {
+        // For widgets that we listen for resizes for (widgets created
+        // with native parents) we apparently _always_ have to resize.  I
+        // dunno why, but apparently we're lame like that.
+        NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
+                     aRepaint);
+    }
+    else {
+        mNeedsResize = true;
+        mNeedsMove = true;
+    }
+
+    if (mIsTopLevel || mListenForResizes) {
+        // synthesize a resize event
+        nsEventStatus status;
+        DispatchResizeEvent(mBounds, status);
+    }
+
+    if (aRepaint) {
+        mWidget->renderLater();
+    }
+
+    NotifyRollupGeometryChange();
+}
+
+void nsWindow::Enable(bool aState) { mEnabled = aState; }
+
+bool nsWindow::IsEnabled() const { return mEnabled; }
+
+nsresult nsWindow::SetFocus(bool aRaise) {
+    // Make sure that our owning widget has focus.  If it doesn't try to
+    // grab it.  Note that we don't set our focus flag in this case.
+    LOGFOCUS(("  SetFocus [%p]\n", (void *)this));
+
+    if (!mWidget) {
+        return NS_ERROR_FAILURE;
+    }
+
+    if (mWidget->focusObject()) {
+        return NS_OK;
+    }
+
+    // Because QGraphicsItem cannot get the focus if they are
+    // invisible, we look up the chain, for the lowest visible
+    // parent and focus that one
+    QWindow* realFocusItem = nullptr;
+    find_first_visible_parent(mWidget, realFocusItem);
+
+    if (!realFocusItem || realFocusItem->focusObject()) {
+        return NS_OK;
+    }
+
+    if (aRaise && mWidget) {
+        // the raising has to happen on the view widget
+        mWidget->raise();
+    }
+
+    // XXXndeakin why is this here? It should dispatch only when the OS
+    // notifies us.
+    DispatchActivateEvent();
+
+    return NS_OK;
+}
+
+nsresult nsWindow::ConfigureChildren(
+    const nsTArray<nsIWidget::Configuration>& aConfigurations) {
+    for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
+        const Configuration& configuration = aConfigurations[i];
+
+        nsWindow* w = static_cast<nsWindow*>(configuration.mChild.get());
+        NS_ASSERTION(w->GetParent() == this,
+                     "Configured widget is not a child");
+
+        if (w->mBounds.Size() != configuration.mBounds.Size()) {
+            w->Resize(configuration.mBounds.x, configuration.mBounds.y,
+                      configuration.mBounds.width, configuration.mBounds.height,
+                      true);
+        } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
+            w->Move(configuration.mBounds.x, configuration.mBounds.y);
+        }
+    }
+    return NS_OK;
+}
+
+void nsWindow::Invalidate(const LayoutDeviceIntRect& aRect) {
+    LOGDRAW(("Invalidate (rect) [%p,%p]: %d %d %d %d\n", (void *)this,
+             (void*)mWidget, aRect.x, aRect.y, aRect.width, aRect.height));
+
+    if (!mWidget) {
+        return;
+    }
+
+    mWidget->renderLater();
+}
+
+LayoutDeviceIntPoint nsWindow::WidgetToScreenOffset() {
+    NS_ENSURE_TRUE(mWidget, LayoutDeviceIntPoint(0,0));
+
+    QPoint origin(0, 0);
+    origin = mWidget->mapToGlobal(origin);
+
+    return LayoutDeviceIntPoint(origin.x(), origin.y());
+}
+
+void* nsWindow::GetNativeData(uint32_t aDataType) {
+    switch (aDataType) {
+    case NS_NATIVE_WINDOW:
+    case NS_NATIVE_WIDGET: {
+        return mWidget;
+    }
+    case NS_NATIVE_SHAREABLE_WINDOW: {
+        return mWidget ? (void*)mWidget->winId() : nullptr;
+    }
+    case NS_NATIVE_DISPLAY: {
+        break;
+    }
+    case NS_NATIVE_PLUGIN_PORT:
+    case NS_NATIVE_GRAPHIC:
+    case NS_NATIVE_SHELLWIDGET: {
+        break;
+    }
+    case NS_RAW_NATIVE_IME_CONTEXT: {
+        void* pseudoIMEContext = GetPseudoIMEContext();
+        if (pseudoIMEContext) {
+            return pseudoIMEContext;
+        }
+        // Our qt widget looks like using only one context per process.
+        // However, it's better to set the context's pointer.
+        return qApp->inputMethod();
+    }
+    default:
+        NS_WARNING("nsWindow::GetNativeData called with bad value");
+        return nullptr;
+    }
+    LOG(("nsWindow::%s [%p] aDataType:%i\n", __FUNCTION__, (void *)this, aDataType));
+    return nullptr;
+}
+
+nsresult nsWindow::DispatchEvent(WidgetGUIEvent* aEvent,
+                                 nsEventStatus& aStatus) {
+#ifdef DEBUG
+    debug_DumpEvent(stdout, aEvent->mWidget, aEvent,
+                    "something", 0);
+#endif
+
+    aStatus = nsEventStatus_eIgnore;
+
+    // send it to the standard callback
+    if (mWidgetListener) {
+        aStatus = mWidgetListener->HandleEvent(aEvent, mUseAttachedEvents);
+    }
+
+    return NS_OK;
+}
+
+void nsWindow::SetInputContext(const InputContext& aContext,
+                          const InputContextAction& aAction) {
+    NS_ENSURE_TRUE_VOID(mWidget);
+
+    // SetSoftwareKeyboardState uses mInputContext,
+    // so, before calling that, record aContext in mInputContext.
+    mInputContext = aContext;
+
+    switch (mInputContext.mIMEState.mEnabled) {
+        case IMEState::ENABLED:
+        case IMEState::PASSWORD:
+        case IMEState::PLUGIN:
+            SetSoftwareKeyboardState(true, aAction);
+            break;
+        default:
+            SetSoftwareKeyboardState(false, aAction);
+            break;
+    }
+}
+
+InputContext nsWindow::GetInputContext() {
+    mInputContext.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
+    return mInputContext;
+}
+
+void nsWindow::ReparentNativeWidget(nsIWidget *aNewParent) {
+    NS_PRECONDITION(aNewParent, "");
+    NS_ASSERTION(!mIsDestroyed, "");
+    NS_ASSERTION(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
+
+    MozQWidget* newParent = static_cast<MozQWidget*>(aNewParent->GetNativeData(NS_NATIVE_WINDOW));
+    NS_ASSERTION(newParent, "Parent widget has a null native window handle");
+    if (mWidget) {
+        mWidget->setParent(newParent);
+    }
+}
+
+nsresult nsWindow::MakeFullScreen(bool aFullScreen, nsIScreen*) {
+    NS_ENSURE_TRUE(mWidget, NS_ERROR_FAILURE);
+
+    if (aFullScreen) {
+        if (mSizeMode != nsSizeMode_Fullscreen) {
+            mLastSizeMode = mSizeMode;
+        }
+
+        mSizeMode = nsSizeMode_Fullscreen;
+        mWidget->showFullScreen();
+    }
+    else {
+        mSizeMode = mLastSizeMode;
+
+        switch (mSizeMode) {
+        case nsSizeMode_Maximized:
+            mWidget->showMaximized();
+            break;
+        case nsSizeMode_Minimized:
+            mWidget->showMinimized();
+            break;
+        case nsSizeMode_Normal:
+            mWidget->showNormal();
+            break;
+        default:
+            mWidget->showNormal();
+            break;
+        }
+    }
+
+    NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
+                 "mLastSizeMode should never be fullscreen");
+    return nsBaseWidget::MakeFullScreen(aFullScreen);
+}
+
+LayerManager *nsWindow::GetLayerManager(
+    PLayerTransactionChild* aShadowManager,
+    LayersBackend aBackendHint,
+    LayerManagerPersistence aPersistence) {
+    if (!mLayerManager && eTransparencyTransparent == GetTransparencyMode()) {
+        mLayerManager = CreateBasicLayerManager();
+    }
+
+    return nsBaseWidget::GetLayerManager(aShadowManager, aBackendHint,
+                                         aPersistence);
+}
+
+void nsWindow::UserActivity() {
+    if (!mIdleService) {
+        mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
+    }
+
+    if (mIdleService) {
+        mIdleService->ResetIdleTimeOut(0);
+    }
+}
+
+uint32_t nsWindow::GetGLFrameBufferFormat() {
+    if (mLayerManager &&
+        mLayerManager->GetBackendType() == mozilla::layers::LayersBackend::LAYERS_OPENGL) {
+        return LOCAL_GL_RGB;
+    }
+    return LOCAL_GL_NONE;
+}
+
+already_AddRefed<DrawTarget> nsWindow::StartRemoteDrawing() {
+    if (!mWidget) {
+        return nullptr;
+    }
+    return nullptr;
+}
+
+void nsWindow::SetCursor(nsCursor aCursor) {
+    if (mCursor == aCursor && !mUpdateCursor) {
+        return;
+    }
+    mUpdateCursor = false;
+    mCursor = aCursor;
+    if (mWidget) {
+        mWidget->SetCursor(mCursor);
+    }
+}
+
+nsresult nsWindow::SetTitle(const nsAString &aTitle) {
+    QString qStr(QString::fromUtf16((const ushort*)aTitle.BeginReading(), aTitle.Length()));
+    mWidget->setTitle(qStr);
+    return NS_OK;
+}
+
+// EVENTS
+
+nsIWidgetListener* nsWindow::GetPaintListener() {
+    return mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
+}
+
+void nsWindow::OnPaint() {
+    LOGDRAW(("nsWindow::%s [%p]\n", __FUNCTION__, (void *)this));
+    nsIWidgetListener* listener = GetPaintListener();
+    if (!listener) {
+        return;
+    }
+
+    listener->WillPaintWindow(this);
+
+    switch (GetLayerManager()->GetBackendType()) {
+        case mozilla::layers::LayersBackend::LAYERS_CLIENT: {
+            LayoutDeviceIntRegion region(
+              LayoutDeviceIntRect(0, 0, mWidget->width(), mWidget->height()));
+            listener->PaintWindow(this, region);
+            break;
+        }
+        default:
+            NS_ERROR("Invalid layer manager");
+    }
+
+    listener->DidPaintWindow();
+}
+
+nsEventStatus nsWindow::moveEvent(QMoveEvent* aEvent) {
+    LOG(("configure event [%p] %d %d\n", (void *)this,
+        aEvent->pos().x(),  aEvent->pos().y()));
+
+    // can we shortcut?
+    if (!mWidget || !mWidgetListener)
+        return nsEventStatus_eIgnore;
+
+    if ((mBounds.x == aEvent->pos().x() &&
+         mBounds.y == aEvent->pos().y()))
+    {
+        return nsEventStatus_eIgnore;
+    }
+
+    NotifyWindowMoved(aEvent->pos().x(), aEvent->pos().y());
+    return nsEventStatus_eConsumeNoDefault;
+}
+
+nsEventStatus nsWindow::resizeEvent(QResizeEvent* aEvent) {
+    LayoutDeviceIntRect rect = GetBounds();
+
+    rect.width = aEvent->size().width();
+    rect.height = aEvent->size().height();
+
+    mBounds.width = rect.width;
+    mBounds.height = rect.height;
+
+    nsEventStatus status;
+    DispatchResizeEvent(rect, status);
+    return status;
+}
+
+nsEventStatus nsWindow::mouseMoveEvent(QMouseEvent* aEvent) {
+    UserActivity();
+
+    mMoveEvent.pos = aEvent->pos();
+    mMoveEvent.modifiers = aEvent->modifiers();
+    mMoveEvent.needDispatch = true;
+    DispatchMotionToMainThread();
+
+    return nsEventStatus_eIgnore;
+}
+
+static void InitMouseEvent(WidgetMouseEvent& aMouseEvent, QMouseEvent* aEvent,
+                           int aClickCount) {
+    aMouseEvent.mRefPoint.x = nscoord(aEvent->pos().x());
+    aMouseEvent.mRefPoint.y = nscoord(aEvent->pos().y());
+
+    aMouseEvent.InitBasicModifiers(aEvent->modifiers() & Qt::ControlModifier,
+                                   aEvent->modifiers() & Qt::AltModifier,
+                                   aEvent->modifiers() & Qt::ShiftModifier,
+                                   aEvent->modifiers() & Qt::MetaModifier);
+    aMouseEvent.mClickCount = aClickCount;
+
+    switch (aEvent->button()) {
+    case Qt::LeftButton:
+        aMouseEvent.button = WidgetMouseEvent::eLeftButton;
+        break;
+    case Qt::RightButton:
+        aMouseEvent.button = WidgetMouseEvent::eRightButton;
+        break;
+    case Qt::MiddleButton:
+        aMouseEvent.button = WidgetMouseEvent::eMiddleButton;
+        break;
+    default:
+        break;
+    }
+}
+
+static bool IsAcceptedButton(Qt::MouseButton button) {
+    switch (button) {
+    case Qt::LeftButton:
+    case Qt::RightButton:
+    case Qt::MiddleButton:
+        return true;
+    default:
+        return false;
+    }
+}
+
+nsEventStatus nsWindow::mousePressEvent(QMouseEvent* aEvent) {
+    // The user has done something.
+    UserActivity();
+
+    QPoint pos = aEvent->pos();
+
+    // we check against the widgets geometry, so use parent coordinates
+    // for the check
+    if (mWidget)
+        pos = mWidget->mapToGlobal(pos);
+
+    if (CheckForRollup(pos.x(), pos.y(), false))
+        return nsEventStatus_eIgnore;
+
+    if (!IsAcceptedButton(aEvent->button())) {
+        if (aEvent->button() == Qt::BackButton)
+            return DispatchCommandEvent(nsGkAtoms::Back);
+        if (aEvent->button() == Qt::ForwardButton)
+            return DispatchCommandEvent(nsGkAtoms::Forward);
+        return nsEventStatus_eIgnore;
+    }
+
+    WidgetMouseEvent event(true, eMouseDown, this, WidgetMouseEvent::eReal);
+    InitMouseEvent(event, aEvent, 1);
+    nsEventStatus status = DispatchEvent(&event);
+
+    // Right click on linux should also pop up a context menu.
+    if (event.button == WidgetMouseEvent::eRightButton &&
+        MOZ_LIKELY(!mIsDestroyed)) {
+        WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                          WidgetMouseEvent::eReal);
+        InitMouseEvent(contextMenuEvent, aEvent, 1);
+        DispatchEvent(&contextMenuEvent, status);
+    }
+
+    return status;
+}
+
+nsEventStatus nsWindow::mouseReleaseEvent(QMouseEvent* aEvent) {
+    // The user has done something.
+    UserActivity();
+
+    if (!IsAcceptedButton(aEvent->button()))
+        return nsEventStatus_eIgnore;
+
+    WidgetMouseEvent event(true, eMouseUp, this, WidgetMouseEvent::eReal);
+    InitMouseEvent(event, aEvent, 1);
+    return DispatchEvent(&event);
+}
+
+nsEventStatus nsWindow::mouseDoubleClickEvent(QMouseEvent* aEvent) {
+    // The user has done something.
+    UserActivity();
+
+    if (!IsAcceptedButton(aEvent->button()))
+        return nsEventStatus_eIgnore;
+
+    WidgetMouseEvent event(true, eMouseDoubleClick, this,
+                           WidgetMouseEvent::eReal);
+    InitMouseEvent(event, aEvent, 2);
+    return DispatchEvent(&event);
+}
+
+nsEventStatus nsWindow::focusInEvent(QFocusEvent* aEvent) {
+    LOGFOCUS(("OnFocusInEvent [%p]\n", (void *)this));
+
+    if (!mWidget) {
+        return nsEventStatus_eIgnore;
+    }
+
+    DispatchActivateEventOnTopLevelWindow();
+
+    LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
+    return nsEventStatus_eIgnore;
+}
+
+nsEventStatus nsWindow::focusOutEvent(QFocusEvent* aEvent) {
+    LOGFOCUS(("OnFocusOutEvent [%p]\n", (void *)this));
+
+    if (!mWidget) {
+        return nsEventStatus_eIgnore;
+    }
+
+    DispatchDeactivateEventOnTopLevelWindow();
+
+    LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
+    return nsEventStatus_eIgnore;
+}
+
+static bool IsContextMenuKeyEvent(const QKeyEvent* aQEvent) {
+    if (aQEvent->modifiers() & (Qt::ControlModifier |
+                                Qt::AltModifier |
+                                Qt::MetaModifier)) {
+        return false;
+    }
+
+    bool isShift = aQEvent->modifiers() & Qt::ShiftModifier;
+    uint32_t keyCode = QtKeyCodeToDOMKeyCode(aQEvent->key());
+    return (keyCode == NS_VK_F10 && isShift) ||
+           (keyCode == NS_VK_CONTEXT_MENU && !isShift);
+}
+
+static void InitKeyEvent(WidgetKeyboardEvent& aEvent, QKeyEvent* aQEvent) {
+    aEvent.InitBasicModifiers(aQEvent->modifiers() & Qt::ControlModifier,
+                              aQEvent->modifiers() & Qt::AltModifier,
+                              aQEvent->modifiers() & Qt::ShiftModifier,
+                              aQEvent->modifiers() & Qt::MetaModifier);
+
+    aEvent.mIsRepeat =
+        (aEvent.mMessage == eKeyDown || aEvent.mMessage == eKeyPress) &&
+        aQEvent->isAutoRepeat();
+    aEvent.mTime = 0;
+
+    if (sAltGrModifier) {
+        aEvent.mModifiers |= (MODIFIER_CONTROL | MODIFIER_ALT);
+    }
+
+    if (aQEvent->text().length() && aQEvent->text()[0].isPrint()) {
+        aEvent.mCharCode = static_cast<uint32_t>(aQEvent->text()[0].unicode());
+        aEvent.mKeyCode = 0;
+        aEvent.mKeyNameIndex = KEY_NAME_INDEX_PrintableKey;
+    } else {
+        aEvent.mCharCode = 0;
+        aEvent.mKeyCode = QtKeyCodeToDOMKeyCode(aQEvent->key());
+        aEvent.mKeyNameIndex = QtKeyCodeToDOMKeyNameIndex(aQEvent->key());
+    }
+
+    aEvent.mCodeNameIndex = ScanCodeToDOMCodeNameIndex(aQEvent->nativeScanCode());
+
+    // The transformations above and in qt for the keyval are not invertible
+    // so link to the QKeyEvent (which will vanish soon after return from the
+    // event callback) to give plugins access to hardware_keycode and state.
+    // (An XEvent would be nice but the QKeyEvent is good enough.)
+    aEvent.mPluginEvent.Copy(*aQEvent);
+}
+
+nsEventStatus nsWindow::keyPressEvent(QKeyEvent* aEvent) {
+    LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
+
+    // The user has done something.
+    UserActivity();
+
+    if (aEvent->key() == Qt::Key_AltGr) {
+        sAltGrModifier = true;
+    }
+
+    // Before we dispatch a key, check if it's the context menu key.
+    // If so, send a context menu key event instead.
+    if (IsContextMenuKeyEvent(aEvent)) {
+        WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                          WidgetMouseEvent::eReal,
+                                          WidgetMouseEvent::eContextMenuKey);
+        return DispatchEvent(&contextMenuEvent);
+    }
+
+    //:TODO: fix shortcuts hebrew for non X11,
+    //see Bug 562195##51
+
+    uint32_t domKeyCode = QtKeyCodeToDOMKeyCode(aEvent->key());
+
+    if (!aEvent->isAutoRepeat() && !IsKeyDown(domKeyCode)) {
+        SetKeyDownFlag(domKeyCode);
+
+        WidgetKeyboardEvent downEvent(true, eKeyDown, this);
+        InitKeyEvent(downEvent, aEvent);
+
+        nsEventStatus status = DispatchEvent(&downEvent);
+
+        // DispatchEvent can Destroy us (bug 378273)
+        if (MOZ_UNLIKELY(mIsDestroyed)) {
+            qWarning() << "Returning[" << __LINE__ << "]: " << "Window destroyed";
+            return status;
+        }
+
+        // If prevent default on keydown, don't dispatch keypress event
+        if (status == nsEventStatus_eConsumeNoDefault) {
+            return nsEventStatus_eConsumeNoDefault;
+        }
+    }
+
+    // Don't pass modifiers as eKeyPress events.
+    // Instead of selectively excluding some keys from eKeyPress events,
+    // we instead selectively include (as per MSDN spec
+    // ( http://msdn.microsoft.com/en-us/library/system.windows.forms.control.keypress%28VS.71%29.aspx );
+    // no official spec covers KeyPress events).
+    if (aEvent->key() == Qt::Key_Shift   ||
+        aEvent->key() == Qt::Key_Control ||
+        aEvent->key() == Qt::Key_Meta    ||
+        aEvent->key() == Qt::Key_Alt     ||
+        aEvent->key() == Qt::Key_AltGr) {
+        return nsEventStatus_eIgnore;
+    }
+
+    // Look for specialized app-command keys
+    switch (aEvent->key()) {
+        case Qt::Key_Back:
+            return DispatchCommandEvent(nsGkAtoms::Back);
+        case Qt::Key_Forward:
+            return DispatchCommandEvent(nsGkAtoms::Forward);
+        case Qt::Key_Refresh:
+            return DispatchCommandEvent(nsGkAtoms::Reload);
+        case Qt::Key_Stop:
+            return DispatchCommandEvent(nsGkAtoms::Stop);
+        case Qt::Key_Search:
+            return DispatchCommandEvent(nsGkAtoms::Search);
+        case Qt::Key_Favorites:
+            return DispatchCommandEvent(nsGkAtoms::Bookmarks);
+        case Qt::Key_HomePage:
+            return DispatchCommandEvent(nsGkAtoms::Home);
+        case Qt::Key_Copy:
+        case Qt::Key_F16: // F16, F20, F18, F14 are old keysyms for Copy Cut Paste Undo
+            return DispatchContentCommandEvent(eContentCommandCopy);
+        case Qt::Key_Cut:
+        case Qt::Key_F20:
+            return DispatchContentCommandEvent(eContentCommandCut);
+        case Qt::Key_Paste:
+        case Qt::Key_F18:
+        case Qt::Key_F9:
+            return DispatchContentCommandEvent(eContentCommandPaste);
+        case Qt::Key_F14:
+            return DispatchContentCommandEvent(eContentCommandUndo);
+    }
+
+    // Qt::Key_Redo and Qt::Key_Undo are not available yet.
+    if (aEvent->nativeVirtualKey() == 0xff66) {
+        return DispatchContentCommandEvent(eContentCommandRedo);
+    }
+    if (aEvent->nativeVirtualKey() == 0xff65) {
+        return DispatchContentCommandEvent(eContentCommandUndo);
+    }
+
+    WidgetKeyboardEvent event(true, eKeyPress, this);
+    InitKeyEvent(event, aEvent);
+    // Seend the key press event
+    return DispatchEvent(&event);
+}
+
+nsEventStatus nsWindow::keyReleaseEvent(QKeyEvent* aEvent) {
+    LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
+
+    // The user has done something.
+    UserActivity();
+
+    if (IsContextMenuKeyEvent(aEvent)) {
+        // er, what do we do here? DoDefault or NoDefault?
+        return nsEventStatus_eConsumeDoDefault;
+    }
+
+    // send the key event as a key up event
+    WidgetKeyboardEvent event(true, eKeyUp, this);
+    InitKeyEvent(event, aEvent);
+
+    if (aEvent->key() == Qt::Key_AltGr) {
+        sAltGrModifier = false;
+    }
+
+    // unset the key down flag
+    ClearKeyDownFlag(event.mKeyCode);
+
+    return DispatchEvent(&event);
+}
+
+nsEventStatus nsWindow::wheelEvent(QWheelEvent* aEvent) {
+    // check to see if we should rollup
+    WidgetWheelEvent wheelEvent(true, eWheel, this);
+    wheelEvent.mDeltaMode = nsIDOMWheelEvent::DOM_DELTA_LINE;
+
+    // negative values for aEvent->delta indicate downward scrolling;
+    // this is opposite Gecko usage.
+    // TODO: Store the unused delta values due to fraction round and add it
+    //       to next event.  The stored values should be reset by other
+    //       direction scroll event.
+    int32_t delta = (int)(aEvent->delta() / WHEEL_DELTA) * -3;
+
+    switch (aEvent->orientation()) {
+    case Qt::Vertical:
+        wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = delta;
+        break;
+    case Qt::Horizontal:
+        wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = delta;
+        break;
+    default:
+        Q_ASSERT(0);
+        break;
+    }
+
+    wheelEvent.mRefPoint.x = nscoord(aEvent->pos().x());
+    wheelEvent.mRefPoint.y = nscoord(aEvent->pos().y());
+
+    wheelEvent.InitBasicModifiers(aEvent->modifiers() & Qt::ControlModifier,
+                                  aEvent->modifiers() & Qt::AltModifier,
+                                  aEvent->modifiers() & Qt::ShiftModifier,
+                                  aEvent->modifiers() & Qt::MetaModifier);
+    wheelEvent.mTime = 0;
+
+    return DispatchEvent(&wheelEvent);
+}
+
+nsEventStatus nsWindow::showEvent(QShowEvent *) {
+    LOG(("%s [%p]\n", __PRETTY_FUNCTION__,(void *)this));
+    mVisible = true;
+    return nsEventStatus_eConsumeDoDefault;
+}
+
+nsEventStatus nsWindow::hideEvent(QHideEvent *) {
+    LOG(("%s [%p]\n", __PRETTY_FUNCTION__,(void *)this));
+    mVisible = false;
+    return nsEventStatus_eConsumeDoDefault;
+}
+
+nsEventStatus nsWindow::touchEvent(QTouchEvent* aEvent) {
+    return nsEventStatus_eIgnore;
+}
+
+nsEventStatus nsWindow::tabletEvent(QTabletEvent* aEvent) {
+    LOGFOCUS(("nsWindow::%s [%p]\n", __FUNCTION__, (void *)this));
+    return nsEventStatus_eIgnore;
+}
+
+//  Helpers
+
+nsEventStatus nsWindow::DispatchEvent(WidgetGUIEvent* aEvent) {
+    nsEventStatus status;
+    DispatchEvent(aEvent, status);
+    return status;
+}
+
+void nsWindow::DispatchActivateEvent(void) {
+    if (mWidgetListener) {
+        mWidgetListener->WindowActivated();
+    }
+}
+
+void nsWindow::DispatchDeactivateEvent(void) {
+    if (mWidgetListener) {
+        mWidgetListener->WindowDeactivated();
+    }
+}
+
+void nsWindow::DispatchActivateEventOnTopLevelWindow(void) {
+    nsWindow* topLevelWindow = static_cast<nsWindow*>(GetTopLevelWidget());
+    if (topLevelWindow != nullptr) {
+        topLevelWindow->DispatchActivateEvent();
+    }
+}
+
+void nsWindow::DispatchDeactivateEventOnTopLevelWindow(void) {
+    nsWindow* topLevelWindow = static_cast<nsWindow*>(GetTopLevelWidget());
+    if (topLevelWindow != nullptr) {
+        topLevelWindow->DispatchDeactivateEvent();
+    }
+}
+
+void nsWindow::DispatchResizeEvent(LayoutDeviceIntRect& aRect,
+                                   nsEventStatus& aStatus) {
+    aStatus = nsEventStatus_eIgnore;
+    if (mWidgetListener &&
+        mWidgetListener->WindowResized(this, aRect.width, aRect.height)) {
+        aStatus = nsEventStatus_eConsumeNoDefault;
+    }
+}
+
+///////////////////////////////////// OLD GECKO ECENTS need to Sort ///////////////////
+
+void nsWindow::ClearCachedResources() {
+    if (mLayerManager &&
+        mLayerManager->GetBackendType() == mozilla::layers::LayersBackend::LAYERS_BASIC) {
+        mLayerManager->ClearCachedResources();
+    }
+    for (nsIWidget* kid = mFirstChild; kid; ) {
+        nsIWidget* next = kid->GetNextSibling();
+        static_cast<nsWindow*>(kid)->ClearCachedResources();
+        kid = next;
+    }
+}
+
+void nsWindow::SetParent(nsIWidget *aNewParent) {
+    nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+    nsIWidget* parent = GetParent();
+    if (parent) {
+        parent->RemoveChild(this);
+    }
+    ReparentNativeWidget(aNewParent);
+    aNewParent->AddChild(this);
+}
+
+void nsWindow::SetModal(bool aModal) {
+    LOG(("nsWindow::SetModal [%p] %d, widget[%p]\n", (void *)this, aModal, mWidget));
+    if (mWidget) {
+        mWidget->setModality(aModal ? Qt::WindowModal : Qt::NonModal);
+    }
+}
+
+void nsWindow::SetSizeMode(nsSizeMode aMode) {
+    LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
+    if (aMode != nsSizeMode_Minimized) {
+        mWidget->requestActivate();
+    }
+
+    // Save the requested state.
+    nsBaseWidget::SetSizeMode(aMode);
+
+    // return if there's no shell or our current state is the same as
+    // the mode we were just set to.
+    if (!mWidget || mSizeState == mSizeMode) {
+        return;
+    }
+
+    switch (aMode) {
+    case nsSizeMode_Maximized:
+        mWidget->showMaximized();
+        break;
+    case nsSizeMode_Minimized:
+        mWidget->showMinimized();
+        break;
+    case nsSizeMode_Fullscreen:
+        mWidget->showFullScreen();
+        break;
+
+    default:
+        // nsSizeMode_Normal, really.
+        mWidget->show();
+        break;
+    }
+
+    mSizeState = mSizeMode;
+}
+
+// Helper function to recursively find the first parent item that
+// is still visible (QGraphicsItem can be hidden even if they are
+// set to visible if one of their ancestors is invisible)
+/* static */
+void find_first_visible_parent(QWindow* aItem, QWindow*& aVisibleItem) {
+    NS_ENSURE_TRUE_VOID(aItem);
+
+    aVisibleItem = nullptr;
+    QWindow* parItem = nullptr;
+    while (!aVisibleItem) {
+        if (aItem->isVisible()) {
+            aVisibleItem = aItem;
+        }
+        else {
+            parItem = aItem->parent();
+            if (parItem) {
+                aItem = parItem;
+            }
+            else {
+                aItem->setVisible(true);
+                aVisibleItem = aItem;
+            }
+        }
+    }
+}
+
+LayoutDeviceIntRect nsWindow::GetScreenBounds() {
+    LayoutDeviceIntRect rect;
+    if (mIsTopLevel) {
+        QPoint pos = mWidget->position();
+        rect.MoveTo(pos.x(), pos.y());
+    } else {
+        rect.MoveTo(WidgetToScreenOffset());
+    }
+    // mBounds.Size() is the window bounds, not the window-manager frame
+    // bounds (bug 581863).  gdk_window_get_frame_extents would give the
+    // frame bounds, but mBounds.Size() is returned here for consistency
+    // with Resize.
+    rect.SizeTo(mBounds.Size());
+    LOG(("GetScreenBounds %d,%d | %dx%d\n",
+         rect.x, rect.y, rect.width, rect.height));
+    return rect;
+}
+
+void nsWindow::SetIcon(const nsAString& aIconSpec) {
+    if (!mWidget)
+        return;
+
+    nsCOMPtr<nsIFile> iconFile;
+    nsAutoCString path;
+    nsTArray<nsCString> iconList;
+
+    // Look for icons with the following suffixes appended to the base name.
+    // The last two entries (for the old XPM format) will be ignored unless
+    // no icons are found using the other suffixes. XPM icons are depricated.
+
+    const char extensions[6][7] = { ".png", "16.png", "32.png", "48.png",
+                                    ".xpm", "16.xpm" };
+
+    for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
+        // Don't bother looking for XPM versions if we found a PNG.
+        if (i == ArrayLength(extensions) - 2 && iconList.Length())
+            break;
+
+        nsAutoString extension;
+        extension.AppendASCII(extensions[i]);
+
+        ResolveIconName(aIconSpec, extension, getter_AddRefs(iconFile));
+        if (iconFile) {
+            iconFile->GetNativePath(path);
+            iconList.AppendElement(path);
+        }
+    }
+
+    // leave the default icon intact if no matching icons were found
+    if (iconList.Length() == 0)
+        return;
+
+    SetWindowIconList(iconList);
+}
+
+void nsWindow::CaptureMouse(bool aCapture) {
+    LOG(("CaptureMouse %p\n", (void *)this));
+
+    if (!mWidget)
+        return;
+
+    mWidget->setMouseGrabEnabled(aCapture);
+}
+
+bool nsWindow::CheckForRollup(double aMouseX, double aMouseY,
+                              bool aIsWheel) {
+    nsIRollupListener* rollupListener = GetActiveRollupListener();
+    nsCOMPtr<nsIWidget> rollupWidget;
+    if (rollupListener) {
+        rollupWidget = rollupListener->GetRollupWidget();
+    }
+    if (!rollupWidget) {
+        nsBaseWidget::gRollupListener = nullptr;
+        return false;
+    }
+
+    bool retVal = false;
+    MozQWidget *currentPopup =
+        (MozQWidget *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
+    if (!is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
+        bool rollup = true;
+        if (aIsWheel) {
+            rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
+            retVal = rollupListener->ShouldConsumeOnMouseWheelEvent();
+        }
+        // if we're dealing with menus, we probably have submenus and
+        // we don't want to rollup if the clickis in a parent menu of
+        // the current submenu
+        uint32_t popupsToRollup = UINT32_MAX;
+        if (rollupListener) {
+            AutoTArray<nsIWidget*, 5> widgetChain;
+            uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
+            for (uint32_t i=0; i<widgetChain.Length(); ++i) {
+                nsIWidget* widget =  widgetChain[i];
+                MozQWidget* currWindow =
+                    (MozQWidget*) widget->GetNativeData(NS_NATIVE_WINDOW);
+                if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
+                  if (i < sameTypeCount) {
+                    rollup = false;
+                  }
+                  else {
+                    popupsToRollup = sameTypeCount;
+                  }
+                  break;
+                }
+            } // foreach parent menu widget
+        } // if rollup listener knows about menus
+
+        // if we've determined that we should still rollup, do it.
+        bool usePoint = !aIsWheel;
+        IntPoint point = IntPoint::Truncate(aMouseX, aMouseY);
+        if (rollup && rollupListener->Rollup(popupsToRollup, true, usePoint ? &point : nullptr, nullptr)) {
+            retVal = true;
+        }
+    }
+
+    return retVal;
+}
+
+/* static */
+bool is_mouse_in_window (MozQWidget* aWindow, double aMouseX, double aMouseY) {
+    return aWindow->geometry().contains(aMouseX, aMouseY);
+}
+
+nsresult nsWindow::GetAttention(int32_t aCycleCount) {
+    LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsEventStatus nsWindow::OnCloseEvent(QCloseEvent *aEvent) {
+    if (!mWidgetListener)
+        return nsEventStatus_eIgnore;
+    mWidgetListener->RequestWindowClose(this);
+    return nsEventStatus_eConsumeNoDefault;
+}
+
+
+inline bool is_latin_shortcut_key(quint32 aKeyval) {
+    return ((Qt::Key_0 <= aKeyval && aKeyval <= Qt::Key_9) ||
+            (Qt::Key_A <= aKeyval && aKeyval <= Qt::Key_Z));
+}
+
+nsEventStatus nsWindow::DispatchCommandEvent(nsAtom *aCommand) {
+    WidgetCommandEvent event(true, nsGkAtoms::onAppCommand, aCommand, this);
+
+    nsEventStatus status;
+    DispatchEvent(&event, status);
+
+    return status;
+}
+
+nsEventStatus nsWindow::DispatchContentCommandEvent(EventMessage aMsg) {
+    WidgetContentCommandEvent event(true, aMsg, this);
+
+    nsEventStatus status;
+    DispatchEvent(&event, status);
+
+    return status;
+}
+
+
+static void GetBrandName(nsAutoString &brandName) {
+    nsCOMPtr<nsIStringBundleService> bundleService =
+        do_GetService(NS_STRINGBUNDLE_CONTRACTID);
+
+    nsCOMPtr<nsIStringBundle> bundle;
+    if (bundleService)
+        bundleService->CreateBundle(
+            "chrome://branding/locale/brand.properties",
+            getter_AddRefs(bundle));
+
+    if (bundle)
+        bundle->GetStringFromName("brandShortName", brandName);
+
+    if (brandName.IsEmpty())
+        brandName = (u"Mozilla");
+}
+
+void nsWindow::SetWindowClass(const nsAString &xulWinType) {
+    if (!mWidget) {
+        return;
+    }
+
+    (void)xulWinType;
+
+    nsAutoString brandName;
+    GetBrandName(brandName);
+}
+
+void nsWindow::NativeResize(int32_t aWidth, int32_t aHeight, bool aRepaint) {
+    LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
+         aWidth, aHeight));
+
+    mNeedsResize = false;
+
+    mWidget->resize(aWidth, aHeight);
+
+    if (aRepaint) {
+        mWidget->renderLater();
+    }
+}
+
+void nsWindow::NativeResize(int32_t aX, int32_t aY,
+                            int32_t aWidth, int32_t aHeight,
+                            bool aRepaint) {
+    LOG(("nsWindow::NativeResize [%p] %d %d %d %d\n", (void *)this,
+         aX, aY, aWidth, aHeight));
+
+    mNeedsResize = false;
+    mNeedsMove = false;
+
+    mWidget->setGeometry(aX, aY, aWidth, aHeight);
+
+    if (aRepaint) {
+        mWidget->renderLater();
+    }
+}
+
+void nsWindow::NativeShow(bool aAction) {
+    if (aAction) {
+        // On e10s, we never want the child process or plugin process
+        // to go fullscreen because if we do the window because visible
+        // do to disabled Qt-Xembed
+        mWidget->show();
+        // unset our flag now that our window has been shown
+        mNeedsShow = false;
+    }
+    else {
+        mWidget->hide();
+    }
+}
+
+void *nsWindow::SetupPluginPort(void) {
+    NS_WARNING("Not implemented");
+    return nullptr;
+}
+
+nsresult nsWindow::SetWindowIconList(const nsTArray<nsCString> &aIconList) {
+    QIcon icon;
+
+    for (uint32_t i = 0; i < aIconList.Length(); ++i) {
+        const char *path = aIconList[i].get();
+        LOG(("window [%p] Loading icon from %s\n", (void *)this, path));
+        icon.addFile(path);
+    }
+
+    mWidget->setIcon(icon);
+
+    return NS_OK;
+}
+
+void nsWindow::SetDefaultIcon(void) {
+    SetIcon(NS_LITERAL_STRING("default"));
+}
+
+void nsWindow::QWidgetDestroyed() {
+    mWidget = nullptr;
+}
+
+
+void nsWindow::HideWindowChrome(bool aShouldHide) {
+    if (!mWidget) {
+        // Nothing to hide
+        return;
+    }
+
+    // Sawfish, metacity, and presumably other window managers get
+    // confused if we change the window decorations while the window
+    // is visible.
+    bool wasVisible = false;
+    if (mWidget->isVisible()) {
+        NativeShow(false);
+        wasVisible = true;
+    }
+
+    if (wasVisible) {
+        NativeShow(true);
+    }
+}
+
+//////////////////////////////////////////////////////////////////////
+
+nsIWidget *nsWindow::GetParent(void) { return mParent; }
+
+float nsWindow::GetDPI() {
+    return qApp->primaryScreen()->logicalDotsPerInch();
+}
+
+void nsWindow::OnDestroy(void) {
+    if (mOnDestroyCalled) {
+        return;
+    }
+
+    mOnDestroyCalled = true;
+
+    // release references to children and device context
+    nsBaseWidget::OnDestroy();
+
+    // let go of our parent
+    mParent = nullptr;
+
+    nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+    NotifyWindowDestroyed();
+}
+
+bool nsWindow::AreBoundsSane(void) {
+    if (mBounds.width > 0 && mBounds.height > 0) {
+        return true;
+    }
+
+    return false;
+}
+
+void nsWindow::SetSoftwareKeyboardState(bool aOpen,
+                                        const InputContextAction& aAction) {
+    if (aOpen) {
+        NS_ENSURE_TRUE_VOID(mInputContext.mIMEState.mEnabled !=
+                            IMEState::DISABLED);
+
+        // Ensure that opening the virtual keyboard is allowed for this specific
+        // InputContext depending on the content.ime.strict.policy pref
+        if (mInputContext.mIMEState.mEnabled != IMEState::PLUGIN &&
+            Preferences::GetBool("content.ime.strict_policy", false) &&
+            !aAction.ContentGotFocusByTrustedCause() &&
+            !aAction.UserMightRequestOpenVKB()) {
+            return;
+        }
+    }
+
+    if (aOpen) {
+        qApp->inputMethod()->show();
+    } else {
+        qApp->inputMethod()->hide();
+    }
+
+    return;
+}
+
+
+void nsWindow::ProcessMotionEvent() {
+    if (mMoveEvent.needDispatch) {
+        WidgetMouseEvent event(true, eMouseMove, this, WidgetMouseEvent::eReal);
+
+        event.mRefPoint.x = nscoord(mMoveEvent.pos.x());
+        event.mRefPoint.y = nscoord(mMoveEvent.pos.y());
+
+        event.InitBasicModifiers(mMoveEvent.modifiers & Qt::ControlModifier,
+                                 mMoveEvent.modifiers & Qt::AltModifier,
+                                 mMoveEvent.modifiers & Qt::ShiftModifier,
+                                 mMoveEvent.modifiers & Qt::MetaModifier);
+        event.mClickCount = 0;
+
+        DispatchEvent(&event);
+        mMoveEvent.needDispatch = false;
+    }
+
+    mTimerStarted = false;
+}
+
+void nsWindow::DispatchMotionToMainThread() {
+    if (!mTimerStarted) {
+        nsCOMPtr<nsIRunnable> event =
+                mozilla::NewRunnableMethod("mozilla::widget::nsWindow::ProcessMotionEvent",
+                                           this, &nsWindow::ProcessMotionEvent);
+        NS_DispatchToMainThread(event);
+        mTimerStarted = true;
+    }
+}
+
diff --git a/widget/qt/nsWindow.h b/widget/qt/nsWindow.h
new file mode 100644
index 000000000000..3bf6f80f3916
--- /dev/null
+++ b/widget/qt/nsWindow.h
@@ -0,0 +1,316 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsWindow_h__
+#define __nsWindow_h__
+
+#include <QPointF>
+
+#include "nsBaseWidget.h"
+#include "mozilla/EventForwards.h"
+
+#include "nsGkAtoms.h"
+#include "nsIIdleServiceInternal.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+#ifdef MOZ_LOGGING
+
+#include "mozilla/Logging.h"
+#include "nsTArray.h"
+
+extern mozilla::LazyLogModule gWidgetLog;
+extern mozilla::LazyLogModule gWidgetFocusLog;
+extern mozilla::LazyLogModule gWidgetIMLog;
+extern mozilla::LazyLogModule gWidgetDrawLog;
+
+#define LOG(args) MOZ_LOG(gWidgetLog, mozilla::LogLevel::Debug, args)
+#define LOGFOCUS(args) MOZ_LOG(gWidgetFocusLog, mozilla::LogLevel::Debug, args)
+#define LOGIM(args) MOZ_LOG(gWidgetIMLog, mozilla::LogLevel::Debug, args)
+#define LOGDRAW(args) MOZ_LOG(gWidgetDrawLog, mozilla::LogLevel::Debug, args)
+
+#else
+
+#ifdef DEBUG_WIDGETS
+
+#define PR_LOG2(_args)         \
+    PR_BEGIN_MACRO             \
+      qDebug _args;            \
+    PR_END_MACRO
+
+#define LOG(args) PR_LOG2(args)
+#define LOGFOCUS(args) PR_LOG2(args)
+#define LOGIM(args) PR_LOG2(args)
+#define LOGDRAW(args) PR_LOG2(args)
+
+#else
+
+#define LOG(args)
+#define LOGFOCUS(args)
+#define LOGIM(args)
+#define LOGDRAW(args)
+
+#endif
+
+#endif /* MOZ_LOGGING */
+
+class QCloseEvent;
+class QFocusEvent;
+class QHideEvent;
+class QKeyEvent;
+class QMouseEvent;
+class QMoveEvent;
+class QResizeEvent;
+class QShowEvent;
+class QTabletEvent;
+class QTouchEvent;
+class QWheelEvent;
+
+namespace mozilla {
+namespace widget {
+class MozQWidget;
+class nsWindow : public nsBaseWidget
+{
+public:
+    nsWindow();
+
+    NS_DECL_ISUPPORTS_INHERITED
+
+    // nsIWidget
+    using nsBaseWidget::Create; // for Create signature not overridden here
+    virtual MOZ_MUST_USE nsresult Create(nsIWidget* aParent,
+                                         nsNativeWidget aNativeParent,
+                                         const LayoutDeviceIntRect& aRect,
+                                         nsWidgetInitData* aInitData) override;
+    virtual void Destroy() override;
+
+    virtual void Show(bool aState) override;
+    virtual bool IsVisible() const;
+    virtual void ConstrainPosition(bool aAllowSlop,
+                                 int32_t *aX,
+                                 int32_t *aY) override;
+    virtual void Move(double aX, double aY) override;
+    virtual void Resize(double aWidth,
+                        double aHeight,
+                        bool   aRepaint) override;
+    virtual void Resize(double aX, double aY, double aWidth, double aHeight,
+                        bool aRepaint) override;
+    virtual void Enable(bool aState) override;
+    // Some of the nsIWidget methods
+    virtual bool IsEnabled() const override;
+    virtual nsresult SetFocus(bool aRaise = false) override;
+    virtual nsresult ConfigureChildren(
+        const nsTArray<nsIWidget::Configuration>&) override;
+    virtual void Invalidate(const LayoutDeviceIntRect& aRect) override;
+    virtual void* GetNativeData(uint32_t aDataType) override;
+    virtual nsresult SetTitle(const nsAString &aTitle) override;
+    virtual void SetCursor(nsCursor aCursor) override;
+    virtual nsresult SetCursor(imgIContainer* aCursor, uint32_t aHotspotX,
+                               uint32_t aHotspotY) override
+    {
+        return NS_OK;
+    }
+    virtual LayoutDeviceIntPoint WidgetToScreenOffset();
+    virtual nsresult DispatchEvent(mozilla::WidgetGUIEvent* aEvent,
+                                   nsEventStatus& aStatus) override;
+    virtual void CaptureRollupEvents(nsIRollupListener *aListener,
+                                   bool aDoCapture) override
+    {
+      (void)aListener;
+      (void)aDoCapture;
+    }
+
+    virtual void ReparentNativeWidget(nsIWidget* aNewParent) override;
+
+    virtual nsresult MakeFullScreen(bool aFullScreen,
+                                    nsIScreen* aTargetScreen = nullptr) override;
+    virtual mozilla::layers::LayerManager*
+        GetLayerManager(PLayerTransactionChild* aShadowManager = nullptr,
+                        LayersBackend aBackendHint = mozilla::layers::LayersBackend::LAYERS_NONE,
+                        LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT);
+
+    virtual void SetInputContext(const InputContext& aContext,
+                                 const InputContextAction& aAction) override;
+    virtual InputContext GetInputContext() override;
+
+    virtual uint32_t GetGLFrameBufferFormat() override;
+
+    already_AddRefed<mozilla::gfx::DrawTarget> StartRemoteDrawing() override;
+
+    // Widget notifications
+    virtual void OnPaint();
+    virtual nsEventStatus focusInEvent(QFocusEvent* aEvent);
+    virtual nsEventStatus focusOutEvent(QFocusEvent* aEvent);
+    virtual nsEventStatus hideEvent(QHideEvent* aEvent);
+    virtual nsEventStatus showEvent(QShowEvent* aEvent);
+    virtual nsEventStatus keyPressEvent(QKeyEvent* aEvent);
+    virtual nsEventStatus keyReleaseEvent(QKeyEvent* aEvent);
+    virtual nsEventStatus mouseDoubleClickEvent(QMouseEvent* aEvent);
+    virtual nsEventStatus mouseMoveEvent(QMouseEvent* aEvent);
+    virtual nsEventStatus mousePressEvent(QMouseEvent* aEvent);
+    virtual nsEventStatus mouseReleaseEvent(QMouseEvent* aEvent);
+    virtual nsEventStatus moveEvent(QMoveEvent* aEvent);
+    virtual nsEventStatus resizeEvent(QResizeEvent* aEvent);
+    virtual nsEventStatus touchEvent(QTouchEvent* aEvent);
+    virtual nsEventStatus wheelEvent(QWheelEvent* aEvent);
+    virtual nsEventStatus tabletEvent(QTabletEvent* event);
+
+protected:
+    virtual ~nsWindow();
+
+    nsWindow* mParent;
+    bool  mVisible;
+    InputContext mInputContext;
+    nsCOMPtr<nsIIdleServiceInternal> mIdleService;
+    MozQWidget* mWidget;
+
+private:
+    // event handling code
+    nsEventStatus DispatchEvent(mozilla::WidgetGUIEvent* aEvent);
+    void DispatchActivateEvent(void);
+    void DispatchDeactivateEvent(void);
+    void DispatchActivateEventOnTopLevelWindow(void);
+    void DispatchDeactivateEventOnTopLevelWindow(void);
+    void DispatchResizeEvent(LayoutDeviceIntRect &aRect,
+                             nsEventStatus &aStatus);
+
+    // Remember the last sizemode so that we can restore it when
+    // leaving fullscreen
+    nsSizeMode mLastSizeMode;
+    // is this widget enabled?
+    bool mEnabled;
+
+    // Call this function when the users activity is the direct cause of an
+    // event (like a keypress or mouse click).
+    void UserActivity();
+    MozQWidget* createQWidget(MozQWidget* parent,
+                              nsWidgetInitData* aInitData);
+
+public:
+    // Old QtWidget only
+    virtual void SetParent(nsIWidget* aNewParent) override;
+    virtual nsIWidget *GetParent() override;
+    virtual float GetDPI() override;
+    virtual void SetModal(bool aModal) override;
+
+    virtual void SetSizeMode(nsSizeMode aMode) override;
+    virtual LayoutDeviceIntRect GetScreenBounds() override;
+
+    virtual void HideWindowChrome(bool aShouldHide) override;
+    virtual void SetIcon(const nsAString& aIconSpec) override;
+    virtual void CaptureMouse(bool aCapture) override;
+    virtual void SetWindowClass(const nsAString& xulWinType) override;
+    virtual MOZ_MUST_USE nsresult GetAttention(int32_t aCycleCount) override;
+
+    //
+    // utility methods
+    //
+    void QWidgetDestroyed();
+    // called when we are destroyed
+    virtual void OnDestroy(void) override;
+    // called to check and see if a widget's dimensions are sane
+    bool AreBoundsSane(void);
+private:
+    // Is this a toplevel window?
+    bool mIsTopLevel;
+    // Has this widget been destroyed yet?
+    bool mIsDestroyed;
+    // This flag tracks if we're hidden or shown.
+    bool mIsShown;
+    // Has anyone set an x/y location for this widget yet? Toplevels
+    // shouldn't be automatically set to 0,0 for first show.
+    bool mPlaced;
+    /**
+     * Event handlers (proxied from the actual qwidget).
+     * They follow normal Qt widget semantics.
+     */
+    void Initialize(MozQWidget *widget);
+    virtual nsEventStatus OnCloseEvent(QCloseEvent *);
+    void NativeResize(int32_t aWidth,
+                      int32_t aHeight,
+                      bool aRepaint);
+    void NativeResize(int32_t aX,
+                      int32_t aY,
+                      int32_t aWidth,
+                      int32_t aHeight,
+                      bool aRepaint);
+    void NativeShow(bool aAction);
+
+private:
+    typedef struct {
+        QPointF pos;
+        Qt::KeyboardModifiers modifiers;
+        bool needDispatch;
+    } MozCachedMoveEvent;
+
+    nsIWidgetListener* GetPaintListener();
+    bool CheckForRollup(double aMouseX, double aMouseY, bool aIsWheel);
+    void* SetupPluginPort(void);
+    nsresult SetWindowIconList(const nsTArray<nsCString> &aIconList);
+    void SetDefaultIcon(void);
+
+    nsEventStatus DispatchCommandEvent(nsAtom* aCommand);
+    nsEventStatus DispatchContentCommandEvent(mozilla::EventMessage aMsg);
+    void SetSoftwareKeyboardState(bool aOpen, const InputContextAction& aAction);
+    void ClearCachedResources();
+
+    uint32_t mActivatePending : 1;
+    int32_t mSizeState;
+
+    // all of our DND stuff
+    // this is the last window that had a drag event happen on it.
+    void InitDragEvent(mozilla::WidgetMouseEvent& aEvent);
+
+    // this is everything we need to be able to fire motion events
+    // repeatedly
+    uint32_t mKeyDownFlags[8];
+
+    /* Helper methods for DOM Key Down event suppression. */
+    uint32_t* GetFlagWord32(uint32_t aKeyCode, uint32_t* aMask) {
+        /* Mozilla DOM Virtual Key Code is from 0 to 224. */
+        NS_ASSERTION((aKeyCode <= 0xFF), "Invalid DOM Key Code");
+        aKeyCode &= 0xFF;
+
+        /* 32 = 2^5 = 0x20 */
+        *aMask = uint32_t(1) << (aKeyCode & 0x1F);
+        return &mKeyDownFlags[(aKeyCode >> 5)];
+    }
+
+    bool IsKeyDown(uint32_t aKeyCode) {
+        uint32_t mask;
+        uint32_t* flag = GetFlagWord32(aKeyCode, &mask);
+        return ((*flag) & mask) != 0;
+    }
+
+    void SetKeyDownFlag(uint32_t aKeyCode) {
+        uint32_t mask;
+        uint32_t* flag = GetFlagWord32(aKeyCode, &mask);
+        *flag |= mask;
+    }
+
+    void ClearKeyDownFlag(uint32_t aKeyCode) {
+        uint32_t mask;
+        uint32_t* flag = GetFlagWord32(aKeyCode, &mask);
+        *flag &= ~mask;
+    }
+    int32_t mQCursor;
+
+
+    void ProcessMotionEvent();
+    void DispatchMotionToMainThread();
+
+    bool mNeedsResize;
+    bool mNeedsMove;
+    bool mListenForResizes;
+    bool mNeedsShow;
+    MozCachedMoveEvent mMoveEvent;
+    bool mTimerStarted;
+};
+
+}}
+
+#endif /* __nsWindow_h__ */
-- 
2.26.2

