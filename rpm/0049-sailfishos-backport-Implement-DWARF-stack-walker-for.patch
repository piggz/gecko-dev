From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Makoto Kato <m_kato@ga2.so-net.ne.jp>
Date: Thu, 12 Apr 2018 18:22:03 +0900
Subject: [PATCH] Bug 1450185 - Implement DWARF stack walker for aarch64.
 r=jseward

Since aarch64's DWARF doesn't have pc register, I use x29 (link register) if
not first frame.

I test by gtest on Linux/aarch64, and profiler works on Android/aarch64.

EM_AARCH64 might not be defined on our builders since headers are old, so
this define is needed.

MozReview-Commit-ID: 8VDb5i0vwBT

--HG--
extra : rebase_source : abfe58624dabc2551deb03527db4be3b93490206
---
 tools/profiler/core/PlatformMacros.h          | 13 +++-
 .../profiler/core/platform-linux-android.cpp  |  2 +-
 tools/profiler/core/platform.cpp              | 11 ++-
 tools/profiler/lul/LulDwarf.cpp               | 19 +++++
 tools/profiler/lul/LulDwarfExt.h              |  3 +
 tools/profiler/lul/LulDwarfSummariser.cpp     | 74 +++++++++++++++++++
 tools/profiler/lul/LulElf.cpp                 |  9 +++
 tools/profiler/lul/LulMain.cpp                | 70 ++++++++++++++++++
 tools/profiler/lul/LulMain.h                  |  5 ++
 tools/profiler/lul/LulMainInt.h               | 14 ++++
 tools/profiler/moz.build                      |  2 +-
 tools/profiler/tests/gtest/LulTestDwarf.cpp   |  3 +
 tools/profiler/tests/gtest/moz.build          |  2 +-
 13 files changed, 219 insertions(+), 8 deletions(-)

diff --git a/tools/profiler/core/PlatformMacros.h b/tools/profiler/core/PlatformMacros.h
index 2024e2b5d957..5f205a918a47 100644
--- a/tools/profiler/core/PlatformMacros.h
+++ b/tools/profiler/core/PlatformMacros.h
@@ -15,7 +15,7 @@
 
 #undef GP_PLAT_x86_android
 #undef GP_PLAT_arm_android
-#undef GP_PLAT_aarch64_android
+#undef GP_PLAT_arm64_android
 #undef GP_PLAT_x86_linux
 #undef GP_PLAT_amd64_linux
 #undef GP_PLAT_arm_linux
@@ -27,7 +27,7 @@
 #undef GP_ARCH_x86
 #undef GP_ARCH_amd64
 #undef GP_ARCH_arm
-#undef GP_ARCH_aarch64
+#undef GP_ARCH_arm64
 #undef GP_ARCH_mips64
 
 #undef GP_OS_android
@@ -49,8 +49,8 @@
 #define GP_OS_android 1
 
 #elif defined(__ANDROID__) && defined(__aarch64__)
-#define GP_PLAT_aarch64_android 1
-#define GP_ARCH_aarch64 1
+#define GP_PLAT_arm64_android 1
+#define GP_ARCH_arm64 1
 #define GP_OS_android 1
 
 #elif defined(__linux__) && defined(__i386__)
@@ -68,6 +68,11 @@
 #define GP_ARCH_arm 1
 #define GP_OS_linux 1
 
+#elif defined(__linux__) && defined(__aarch64__)
+#define GP_PLAT_arm64_linux 1
+#define GP_ARCH_arm64 1
+#define GP_OS_linux 1
+
 #elif defined(__linux__) && defined(__mips64)
 #define GP_PLAT_mips64_linux 1
 #define GP_ARCH_mips64 1
diff --git a/tools/profiler/core/platform-linux-android.cpp b/tools/profiler/core/platform-linux-android.cpp
index 09eb9437e568..5d9867c99a87 100644
--- a/tools/profiler/core/platform-linux-android.cpp
+++ b/tools/profiler/core/platform-linux-android.cpp
@@ -93,7 +93,7 @@ static void PopulateRegsFromContext(Registers& aRegs, ucontext_t* aContext) {
   aRegs.mSP = reinterpret_cast<Address>(mcontext.arm_sp);
   aRegs.mFP = reinterpret_cast<Address>(mcontext.arm_fp);
   aRegs.mLR = reinterpret_cast<Address>(mcontext.arm_lr);
-#elif defined(GP_ARCH_aarch64)
+#elif defined(GP_ARCH_arm64)
   aRegs.mPC = reinterpret_cast<Address>(mcontext.pc);
   aRegs.mSP = reinterpret_cast<Address>(mcontext.sp);
   aRegs.mFP = reinterpret_cast<Address>(mcontext.regs[29]);
diff --git a/tools/profiler/core/platform.cpp b/tools/profiler/core/platform.cpp
index adb66eb8a44d..4936beba8feb 100644
--- a/tools/profiler/core/platform.cpp
+++ b/tools/profiler/core/platform.cpp
@@ -112,7 +112,8 @@
 
 // Linux builds use LUL, which uses DWARF info to unwind stacks.
 #if defined(GP_PLAT_amd64_linux) || defined(GP_PLAT_x86_linux) || \
-    defined(GP_PLAT_mips64_linux)
+    defined(GP_PLAT_mips64_linux) || defined(GP_PLAT_arm64_linux) || \
+    defined(GP_PLAT_arm64_android)
 #define HAVE_NATIVE_UNWIND
 #define USE_LUL_STACKWALK
 #include "lul/LulMain.h"
@@ -1194,6 +1195,11 @@ static void DoLULBacktrace(PSLockRef aLock,
   startRegs.r12 = lul::TaggedUWord(mc->arm_ip);
   startRegs.r11 = lul::TaggedUWord(mc->arm_fp);
   startRegs.r7 = lul::TaggedUWord(mc->arm_r7);
+#elif defined(GP_PLAT_arm64_linux) || defined(GP_PLAT_arm64_android)
+  startRegs.pc  = lul::TaggedUWord(mc->pc);
+  startRegs.x29 = lul::TaggedUWord(mc->regs[29]);
+  startRegs.x30 = lul::TaggedUWord(mc->regs[30]);
+  startRegs.sp  = lul::TaggedUWord(mc->sp);
 #elif defined(GP_PLAT_x86_linux) || defined(GP_PLAT_x86_android)
   startRegs.xip = lul::TaggedUWord(mc->gregs[REG_EIP]);
   startRegs.xsp = lul::TaggedUWord(mc->gregs[REG_ESP]);
@@ -1246,6 +1252,9 @@ static void DoLULBacktrace(PSLockRef aLock,
 #elif defined(GP_PLAT_arm_linux) || defined(GP_PLAT_arm_android)
     uintptr_t rEDZONE_SIZE = 0;
     uintptr_t start = startRegs.r13.Value() - rEDZONE_SIZE;
+#elif defined(GP_PLAT_arm64_linux) || defined(GP_PLAT_arm64_android)
+    uintptr_t rEDZONE_SIZE = 0;
+    uintptr_t start = startRegs.sp.Value() - rEDZONE_SIZE;
 #elif defined(GP_PLAT_x86_linux) || defined(GP_PLAT_x86_android)
     uintptr_t rEDZONE_SIZE = 0;
     uintptr_t start = startRegs.xsp.Value() - rEDZONE_SIZE;
diff --git a/tools/profiler/lul/LulDwarf.cpp b/tools/profiler/lul/LulDwarf.cpp
index de62af667639..8af1a99fcab4 100644
--- a/tools/profiler/lul/LulDwarf.cpp
+++ b/tools/profiler/lul/LulDwarf.cpp
@@ -1888,6 +1888,25 @@ unsigned int DwarfCFIToModule::RegisterNames::ARM() {
   return 13 * 8;
 }
 
+// Per ARM IHI 0057A, section 3.1
+unsigned int DwarfCFIToModule::RegisterNames::ARM64() {
+  /*
+   8 "x0",  "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+   8 "x8",  "x9",  "x10", "x11", "x12", "x13", "x14", "x15",
+   8 "x16"  "x17", "x18", "x19", "x20", "x21", "x22", "x23",
+   8 "x24", "x25", "x26", "x27", "x28", "x29",  "x30","sp",
+   8 "",    "",    "",    "",    "",    "",    "",    "",
+   8 "",    "",    "",    "",    "",    "",    "",    "",
+   8 "",    "",    "",    "",    "",    "",    "",    "",
+   8 "",    "",    "",    "",    "",    "",    "",    "",
+   8 "v0",  "v1",  "v2",  "v3",  "v4",  "v5",  "v6",  "v7",
+   8 "v8",  "v9",  "v10", "v11", "v12", "v13", "v14", "v15",
+   8 "v16", "v17", "v18", "v19", "v20", "v21", "v22,  "v23",
+   8 "v24", "x25", "x26,  "x27", "v28", "v29", "v30", "v31",
+  */
+  return 12 * 8;
+}
+
 unsigned int DwarfCFIToModule::RegisterNames::MIPS() {
   /*
    8 "$zero", "$at",  "$v0",  "$v1",  "$a0",   "$a1",  "$a2",  "$a3",
diff --git a/tools/profiler/lul/LulDwarfExt.h b/tools/profiler/lul/LulDwarfExt.h
index 24247c49ed10..9055d1b0aef3 100644
--- a/tools/profiler/lul/LulDwarfExt.h
+++ b/tools/profiler/lul/LulDwarfExt.h
@@ -1202,6 +1202,9 @@ class DwarfCFIToModule : public CallFrameInfo::Handler {
     // ARM.
     static unsigned int ARM();
 
+    // AARCH64.
+    static unsigned int ARM64();
+
     // MIPS.
     static unsigned int MIPS();
   };
diff --git a/tools/profiler/lul/LulDwarfSummariser.cpp b/tools/profiler/lul/LulDwarfSummariser.cpp
index 106ee491e235..0d9a41c5b7e8 100644
--- a/tools/profiler/lul/LulDwarfSummariser.cpp
+++ b/tools/profiler/lul/LulDwarfSummariser.cpp
@@ -243,6 +243,80 @@ void Summariser::Rule(uintptr_t aAddress, int aNewReg, LExprHow how,
     mCurrRules.mR15expr = LExpr(NODEREF, DW_REG_ARM_R14, 0);
   }
 
+#elif defined(GP_ARCH_arm64)
+
+  // ----------------- arm64 ----------------- //
+
+  switch (aNewReg) {
+    case DW_REG_CFA:
+      if (how != NODEREF) {
+        reason1 = "rule for DW_REG_CFA: invalid |how|";
+        goto cant_summarise;
+      }
+      switch (oldReg) {
+        case DW_REG_AARCH64_X29:
+        case DW_REG_AARCH64_SP:
+          break;
+        default:
+          reason1 = "rule for DW_REG_CFA: invalid |oldReg|";
+          goto cant_summarise;
+      }
+      mCurrRules.mCfaExpr = LExpr(how, oldReg, offset);
+      break;
+
+    case DW_REG_AARCH64_X29:
+    case DW_REG_AARCH64_X30:
+    case DW_REG_AARCH64_SP: {
+      switch (how) {
+        case NODEREF:
+        case DEREF:
+          // Check the old register is one we're tracking.
+          if (!registerIsTracked((DW_REG_NUMBER)oldReg) &&
+              oldReg != DW_REG_CFA) {
+            reason1 = "rule for X29/X30/SP: uses untracked reg";
+            goto cant_summarise;
+          }
+          break;
+        case PFXEXPR: {
+          // Check that the prefix expression only mentions tracked registers.
+          const vector<PfxInstr>* pfxInstrs = mSecMap->GetPfxInstrs();
+          reason2 = checkPfxExpr(pfxInstrs, offset);
+          if (reason2) {
+            reason1 = "rule for X29/X30/SP: ";
+            goto cant_summarise;
+          }
+          break;
+        }
+        default:
+          goto cant_summarise;
+      }
+      LExpr expr = LExpr(how, oldReg, offset);
+      switch (aNewReg) {
+        case DW_REG_AARCH64_X29: mCurrRules.mX29expr = expr; break;
+        case DW_REG_AARCH64_X30: mCurrRules.mX30expr = expr; break;
+        case DW_REG_AARCH64_SP:  mCurrRules.mSPexpr  = expr; break;
+        default: MOZ_ASSERT(0);
+      }
+      break;
+    }
+    default:
+     // Leave |reason1| and |reason2| unset here, for the reasons explained
+     // in the analogous point
+     goto cant_summarise;
+  }
+
+  if (mCurrRules.mX29expr.mHow == UNKNOWN) {
+    mCurrRules.mX29expr = LExpr(NODEREF, DW_REG_AARCH64_X29, 0);
+  }
+  if (mCurrRules.mX30expr.mHow == UNKNOWN) {
+    mCurrRules.mX30expr = LExpr(NODEREF, DW_REG_AARCH64_X30, 0);
+  }
+  // On aarch64, it seems the old SP value before the call is always the
+  // same as the CFA.  Therefore, in the absence of any other way to
+  // recover the SP, specify that the CFA should be copied.
+  if (mCurrRules.mSPexpr.mHow == UNKNOWN) {
+    mCurrRules.mSPexpr = LExpr(NODEREF, DW_REG_CFA, 0);
+  }
 #elif defined(GP_ARCH_amd64) || defined(GP_ARCH_x86)
 
   // ---------------- x64/x86 ---------------- //
diff --git a/tools/profiler/lul/LulElf.cpp b/tools/profiler/lul/LulElf.cpp
index c4cd7b8e16e5..c8876f3f79e6 100644
--- a/tools/profiler/lul/LulElf.cpp
+++ b/tools/profiler/lul/LulElf.cpp
@@ -72,6 +72,11 @@
 #define SHT_ARM_EXIDX (SHT_LOPROC + 1)
 #endif
 
+// Old Linux header doesn't define EM_AARCH64
+#ifndef EM_AARCH64
+#define EM_AARCH64 183
+#endif
+
 // This namespace contains helper functions.
 namespace {
 
@@ -161,6 +166,9 @@ bool DwarfCFIRegisterNames(const typename ElfClass::Ehdr* elf_header,
     case EM_MIPS:
       *num_dw_regnames = DwarfCFIToModule::RegisterNames::MIPS();
       return true;
+    case EM_AARCH64:
+      *num_dw_regnames = DwarfCFIToModule::RegisterNames::ARM64();
+      return true;
     default:
       MOZ_ASSERT(0);
       return false;
@@ -421,6 +429,7 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
       return "x86";
     case EM_ARM:
       return "arm";
+    case EM_AARCH64:    return "arm64";
     case EM_MIPS:
       return "mips";
     case EM_PPC64:
diff --git a/tools/profiler/lul/LulMain.cpp b/tools/profiler/lul/LulMain.cpp
index ba6f97fd01e5..17a048e45489 100644
--- a/tools/profiler/lul/LulMain.cpp
+++ b/tools/profiler/lul/LulMain.cpp
@@ -82,6 +82,13 @@ static const char* NameOf_DW_REG(int16_t aReg) {
       return "r14";
     case DW_REG_ARM_R15:
       return "r15";
+#elif defined(GP_ARCH_arm64)
+    case DW_REG_AARCH64_X29:
+      return "x29";
+    case DW_REG_AARCH64_X30:
+      return "x30";
+    case DW_REG_AARCH64_SP:
+      return "sp";
 #elif defined(GP_ARCH_mips64)
     case DW_REG_MIPS_SP:
       return "sp";
@@ -142,6 +149,10 @@ void RuleSet::Print(void (*aLog)(const char*)) const {
   res += mR12expr.ShowRule(" R12");
   res += mR13expr.ShowRule(" R13");
   res += mR14expr.ShowRule(" R14");
+#elif defined(GP_ARCH_arm64)
+  res += mX29expr.ShowRule(" X29");
+  res += mX30expr.ShowRule(" X30");
+  res += mSPexpr .ShowRule(" SP");
 #elif defined(GP_ARCH_mips64)
   res += mPCexpr.ShowRule(" PC");
   res += mSPexpr.ShowRule(" SP");
@@ -176,6 +187,13 @@ LExpr* RuleSet::ExprForRegno(DW_REG_NUMBER aRegno) {
       return &mR11expr;
     case DW_REG_ARM_R7:
       return &mR7expr;
+#elif defined(GP_ARCH_arm64)
+    case DW_REG_AARCH64_X29:
+      return &mX29expr;
+    case DW_REG_AARCH64_X30:
+      return &mX30expr;
+    case DW_REG_AARCH64_SP:
+      return &mSPexpr;
 #elif defined(GP_ARCH_mips64)
     case DW_REG_MIPS_SP:
       return &mSPexpr;
@@ -896,6 +914,13 @@ static TaggedUWord EvaluateReg(int16_t aReg, const UnwindRegs* aOldRegs,
       return aOldRegs->r14;
     case DW_REG_ARM_R15:
       return aOldRegs->r15;
+#elif defined(GP_ARCH_arm64)
+    case DW_REG_AARCH64_X29:
+      return aOldRegs->x29;
+    case DW_REG_AARCH64_X30:
+      return aOldRegs->x30;
+    case DW_REG_AARCH64_SP:
+      return aOldRegs->sp;
 #elif defined(GP_ARCH_mips64)
     case DW_REG_MIPS_SP:
       return aOldRegs->sp;
@@ -1097,6 +1122,11 @@ static void UseRuleSet(/*MOD*/ UnwindRegs* aRegs, const StackImage* aStackImg,
   aRegs->r13 = TaggedUWord();
   aRegs->r14 = TaggedUWord();
   aRegs->r15 = TaggedUWord();
+#elif defined(GP_ARCH_arm64)
+  aRegs->x29 = TaggedUWord();
+  aRegs->x30 = TaggedUWord();
+  aRegs->sp  = TaggedUWord();
+  aRegs->pc  = TaggedUWord();
 #elif defined(GP_ARCH_mips64)
   aRegs->sp = TaggedUWord();
   aRegs->fp = TaggedUWord();
@@ -1136,6 +1166,13 @@ static void UseRuleSet(/*MOD*/ UnwindRegs* aRegs, const StackImage* aStackImg,
       aRS->mR14expr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
   aRegs->r15 =
       aRS->mR15expr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
+#elif defined(GP_ARCH_arm64)
+  aRegs->x29 =
+      aRS->mX29expr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
+  aRegs->x30 =
+      aRS->mX30expr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
+  aRegs->sp =
+      aRS->mSPexpr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
 #elif defined(GP_ARCH_mips64)
   aRegs->sp = aRS->mSPexpr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
   aRegs->fp = aRS->mFPexpr.EvaluateExpr(&old_regs, cfa, aStackImg, aPfxInstrs);
@@ -1190,6 +1227,16 @@ void LUL::Unwind(/*OUT*/ uintptr_t* aFramePCs,
           (int)regs.r14.Valid(), (unsigned long long int)regs.r14.Value());
       buf[sizeof(buf) - 1] = 0;
       mLog(buf);
+#elif defined(GP_ARCH_arm64)
+      SprintfLiteral(buf,
+          "LoopTop: pc %d/%llx  x29 %d/%llx  x30 %d/%llx"
+          "  sp %d/%llx\n",
+          (int)regs.pc.Valid(), (unsigned long long int)regs.pc.Value(),
+          (int)regs.x29.Valid(), (unsigned long long int)regs.x29.Value(),
+          (int)regs.x30.Valid(), (unsigned long long int)regs.x30.Value(),
+          (int)regs.sp.Valid(), (unsigned long long int)regs.sp.Value());
+      buf[sizeof(buf)-1] = 0;
+      mLog(buf);
 #elif defined(GP_ARCH_mips64)
       SprintfLiteral(
           buf, "LoopTop: pc %d/%llx  sp %d/%llx  fp %d/%llx\n",
@@ -1209,6 +1256,9 @@ void LUL::Unwind(/*OUT*/ uintptr_t* aFramePCs,
 #elif defined(GP_ARCH_arm)
     TaggedUWord ia = (*aFramesUsed == 0 ? regs.r15 : regs.r14);
     TaggedUWord sp = regs.r13;
+#elif defined(GP_ARCH_arm64)
+    TaggedUWord ia = (*aFramesUsed == 0 ? regs.pc : regs.x30);
+    TaggedUWord sp = regs.sp;
 #elif defined(GP_ARCH_mips64)
     TaggedUWord ia = regs.pc;
     TaggedUWord sp = regs.sp;
@@ -1521,6 +1571,26 @@ static __attribute__((noinline)) bool GetAndCheckStackTrace(
   startRegs.r7 = TaggedUWord(block[5]);
   const uintptr_t REDZONE_SIZE = 0;
   uintptr_t start = block[1] - REDZONE_SIZE;
+#elif defined(GP_ARCH_arm64)
+  volatile uintptr_t block[4];
+  MOZ_ASSERT(sizeof(block) == 32);
+  __asm__ __volatile__(
+    "adr x0, . \n\t"
+    "str x0, [%0, #0] \n\t"
+    "str x29, [%0, #8] \n\t"
+    "str x30, [%0, #16] \n\t"
+    "mov x0, sp \n\t"
+    "str x0, [%0, #24] \n\t"
+    :
+    : "r"(&block[0])
+    : "memory", "x0"
+  );
+  startRegs.pc = TaggedUWord(block[0]);
+  startRegs.x29 = TaggedUWord(block[1]);
+  startRegs.x30 = TaggedUWord(block[2]);
+  startRegs.sp = TaggedUWord(block[3]);
+  const uintptr_t REDZONE_SIZE = 0;
+  uintptr_t start = block[1] - REDZONE_SIZE;
 #elif defined(GP_ARCH_mips64)
   volatile uintptr_t block[3];
   MOZ_ASSERT(sizeof(block) == 24);
diff --git a/tools/profiler/lul/LulMain.h b/tools/profiler/lul/LulMain.h
index b65b45fef709..c53e61a9a040 100644
--- a/tools/profiler/lul/LulMain.h
+++ b/tools/profiler/lul/LulMain.h
@@ -139,6 +139,11 @@ struct UnwindRegs {
   TaggedUWord r13;
   TaggedUWord r14;
   TaggedUWord r15;
+#elif defined(GP_ARCH_arm64)
+  TaggedUWord x29;
+  TaggedUWord x30;
+  TaggedUWord sp;
+  TaggedUWord pc;
 #elif defined(GP_ARCH_amd64) || defined(GP_ARCH_x86)
   TaggedUWord xbp;
   TaggedUWord xsp;
diff --git a/tools/profiler/lul/LulMainInt.h b/tools/profiler/lul/LulMainInt.h
index 92a9017bf29c..c597a5096fa4 100644
--- a/tools/profiler/lul/LulMainInt.h
+++ b/tools/profiler/lul/LulMainInt.h
@@ -42,6 +42,11 @@ enum DW_REG_NUMBER {
   DW_REG_ARM_R13 = 13,
   DW_REG_ARM_R14 = 14,
   DW_REG_ARM_R15 = 15,
+#elif defined(GP_ARCH_arm64)
+  // aarch64 registers
+  DW_REG_AARCH64_X29 = 29,
+  DW_REG_AARCH64_X30 = 30,
+  DW_REG_AARCH64_SP  = 31,
 #elif defined(GP_ARCH_amd64)
   // Because the X86 (32 bit) and AMD64 (64 bit) summarisers are
   // combined, a merged set of register constants is needed.
@@ -271,6 +276,10 @@ class RuleSet {
   LExpr mR12expr;
   LExpr mR11expr;
   LExpr mR7expr;
+#elif defined(GP_ARCH_arm64)
+  LExpr mX29expr; // frame pointer register
+  LExpr mX30expr; // link register
+  LExpr mSPexpr;
 #elif defined(GP_ARCH_mips64)
   LExpr mPCexpr;
   LExpr mFPexpr;
@@ -297,6 +306,11 @@ static inline bool registerIsTracked(DW_REG_NUMBER reg) {
     case DW_REG_ARM_R14:
     case DW_REG_ARM_R15:
       return true;
+#elif defined(GP_ARCH_arm64)
+    case DW_REG_AARCH64_X29:
+    case DW_REG_AARCH64_X30:
+    case DW_REG_AARCH64_SP:
+      return true;
 #elif defined(GP_ARCH_mips64)
     case DW_REG_MIPS_FP:
     case DW_REG_MIPS_SP:
diff --git a/tools/profiler/moz.build b/tools/profiler/moz.build
index 331535dfd26b..87d5577d24f3 100644
--- a/tools/profiler/moz.build
+++ b/tools/profiler/moz.build
@@ -48,7 +48,7 @@ if CONFIG['MOZ_GECKO_PROFILER']:
         ]
 
     if CONFIG['OS_TARGET'] in ('Android', 'Linux'):
-        if CONFIG['CPU_ARCH'] in ('arm', 'x86', 'x86_64', 'mips64'):
+        if CONFIG['CPU_ARCH'] in ('arm', 'aarch64', 'x86', 'x86_64', 'mips64'):
             UNIFIED_SOURCES += [
                 'lul/AutoObjectMapper.cpp',
                 'lul/LulCommon.cpp',
diff --git a/tools/profiler/tests/gtest/LulTestDwarf.cpp b/tools/profiler/tests/gtest/LulTestDwarf.cpp
index 362294434b27..34d378989ace 100644
--- a/tools/profiler/tests/gtest/LulTestDwarf.cpp
+++ b/tools/profiler/tests/gtest/LulTestDwarf.cpp
@@ -2406,6 +2406,9 @@ TEST_F(LulDwarfExpr, ExpressionOverrun) {
 #if defined(GP_ARCH_arm)
 # define TESTED_REG_STRUCT_NAME  r11
 # define TESTED_REG_DWARF_NAME   DW_REG_ARM_R11
+#elif defined(GP_ARCH_arm64)
+# define TESTED_REG_STRUCT_NAME  x29
+# define TESTED_REG_DWARF_NAME   DW_REG_AARCH64_X29
 #elif defined(GP_ARCH_amd64) || defined(GP_ARCH_x86)
 # define TESTED_REG_STRUCT_NAME  xbp
 # define TESTED_REG_DWARF_NAME   DW_REG_INTEL_XBP
diff --git a/tools/profiler/tests/gtest/moz.build b/tools/profiler/tests/gtest/moz.build
index 3a2ff02528c1..230c951ade7a 100644
--- a/tools/profiler/tests/gtest/moz.build
+++ b/tools/profiler/tests/gtest/moz.build
@@ -5,7 +5,7 @@
 # file, you can obtain one at http://mozilla.org/MPL/2.0/.
 
 if (CONFIG['OS_TARGET'] in ('Android', 'Linux') and
-    CONFIG['CPU_ARCH'] in ('arm', 'x86', 'x86_64')):
+    CONFIG['CPU_ARCH'] in ('arm', 'aarch64', 'x86', 'x86_64')):
     UNIFIED_SOURCES += [
         'LulTest.cpp',
         'LulTestDwarf.cpp',
-- 
2.26.2

