From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: David Llewellyn-Jones <david.llewellyn-jones@jolla.com>
Date: Fri, 13 Nov 2020 15:47:02 +0200
Subject: [PATCH] [sailfishos][gecko] Make <button> hit testing similar to
 other elements. Contributes to JB#51683

This is a backported version of the fix for mozilla bug 1089326: "make
<button> hit testing similar to other elements which may have some
content, and for click target find the common (interactive) ancestor,
r=masayuki"

See https://hg.mozilla.org/mozilla-central/rev/36b949bef798

Essentially it makes hit targetting of the <button> element the same as
for other elements. Previously only the button element itself could be
the target, even for hits on its children. This change makes it so that
the children can be targets as well (so select, hover, etc. can be
captured by them as well).

This patch should be removed after the upgrade to ESR68.
---
 dom/base/nsContentUtils.cpp                   |  50 ++++++++
 dom/base/nsContentUtils.h                     |   9 ++
 dom/base/nsINode.h                            |   9 ++
 dom/events/Event.cpp                          |   9 ++
 dom/events/EventStateManager.cpp              |  85 ++++++-------
 dom/events/EventStateManager.h                |   3 -
 dom/events/test/test_bug556493.html           |   2 +-
 ...est_dblclick_explicit_original_target.html |  21 +++-
 dom/html/HTMLButtonElement.cpp                |   7 +-
 dom/html/HTMLInputElement.cpp                 |  33 ++---
 layout/forms/nsHTMLButtonControlFrame.cpp     |   6 +-
 .../the-button-element/button-events.html     | 119 +++++++++++++++++-
 toolkit/content/widgets/datetimebox.xml       |   6 +-
 widget/BasicEvents.h                          |   2 +
 widget/MouseEvents.h                          |   4 +
 15 files changed, 288 insertions(+), 77 deletions(-)

diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
index 4101dd7dac4c..25e657d28df3 100644
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -2703,6 +2703,56 @@ int32_t nsContentUtils::ComparePoints(const RawRangeBoundary& aFirst,
                        aSecond.Offset(), aDisconnected);
 }
 
+// static
+nsINode*
+nsContentUtils::GetCommonAncestorUnderInteractiveContent(nsINode* aNode1,
+                                                         nsINode* aNode2)
+{
+  if (!aNode1 || !aNode2) {
+    return nullptr;
+  }
+
+  if (aNode1 == aNode2) {
+    return aNode1;
+  }
+
+  // Build the chain of parents
+  AutoTArray<nsINode*, 30> parents1;
+  do {
+    parents1.AppendElement(aNode1);
+    if (aNode1->IsElement() &&
+        aNode1->AsElement()->IsInteractiveHTMLContent(true)) {
+      break;
+    }
+    aNode1 = aNode1->GetFlattenedTreeParentNode();
+  } while (aNode1);
+
+  AutoTArray<nsINode*, 30> parents2;
+  do {
+    parents2.AppendElement(aNode2);
+    if (aNode2->IsElement() &&
+        aNode2->AsElement()->IsInteractiveHTMLContent(true)) {
+      break;
+    }
+    aNode2 = aNode2->GetFlattenedTreeParentNode();
+  } while (aNode2);
+
+  // Find where the parent chain differs
+  uint32_t pos1 = parents1.Length();
+  uint32_t pos2 = parents2.Length();
+  nsINode* parent = nullptr;
+  for (uint32_t len = std::min(pos1, pos2); len > 0; --len) {
+    nsINode* child1 = parents1.ElementAt(--pos1);
+    nsINode* child2 = parents2.ElementAt(--pos2);
+    if (child1 != child2) {
+      break;
+    }
+    parent = child1;
+  }
+
+  return parent;
+}
+
 inline bool IsCharInSet(const char* aSet, const char16_t aChar) {
   char16_t ch;
   while ((ch = *aSet)) {
diff --git a/dom/base/nsContentUtils.h b/dom/base/nsContentUtils.h
index 81383ac1ce45..14e7a5216abc 100644
--- a/dom/base/nsContentUtils.h
+++ b/dom/base/nsContentUtils.h
@@ -428,6 +428,15 @@ class nsContentUtils {
   static Element* GetCommonFlattenedTreeAncestorForStyle(Element* aElement1,
                                                          Element* aElement2);
 
+  /**
+   * Returns the common ancestor under interactive content, if any.
+   * If neither one has interactive content as ancestor, common ancestor will be
+   * returned. If only one has interactive content as ancestor, null will be
+   * returned. If the nodes are the same, that node is returned.
+   */
+  static nsINode* GetCommonAncestorUnderInteractiveContent(nsINode* aNode1,
+                                                           nsINode* aNode2);
+
   /**
    * Returns true if aNode1 is before aNode2 in the same connected
    * tree.
diff --git a/dom/base/nsINode.h b/dom/base/nsINode.h
index f166ce97160f..13211cd5bc30 100644
--- a/dom/base/nsINode.h
+++ b/dom/base/nsINode.h
@@ -494,6 +494,15 @@ class nsINode : public mozilla::dom::EventTarget {
     return const_cast<nsINode*>(this)->AsContent();
   }
 
+  /*
+   * Return whether the node is a Text node (which might be an actual
+   * textnode, or might be a CDATA section).
+   */
+  bool IsText() const {
+    uint32_t nodeType = NodeType();
+    return nodeType == TEXT_NODE || nodeType == CDATA_SECTION_NODE;
+  }
+
   /**
    * Return this node as Text if it is one, otherwise null.  This is defined
    * inline in Text.h.
diff --git a/dom/events/Event.cpp b/dom/events/Event.cpp
index 9084515c8748..c24d9a241336 100644
--- a/dom/events/Event.cpp
+++ b/dom/events/Event.cpp
@@ -160,6 +160,10 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Event)
       default:
         break;
     }
+
+    if (WidgetMouseEvent* mouseEvent = tmp->mEvent->AsMouseEvent()) {
+      mouseEvent->mClickTarget = nullptr;
+    }
   }
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPresContext);
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mExplicitOriginalTarget);
@@ -192,6 +196,11 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(Event)
       default:
         break;
     }
+
+    if (WidgetMouseEvent* mouseEvent = tmp->mEvent->AsMouseEvent()) {
+      NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mEvent->mClickTarget");
+      cb.NoteXPCOMChild(mouseEvent->mClickTarget);
+    }
   }
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPresContext)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mExplicitOriginalTarget)
diff --git a/dom/events/EventStateManager.cpp b/dom/events/EventStateManager.cpp
index a5e915ff21ec..d7d830decd10 100644
--- a/dom/events/EventStateManager.cpp
+++ b/dom/events/EventStateManager.cpp
@@ -393,11 +393,9 @@ NS_IMPL_CYCLE_COLLECTING_RELEASE(EventStateManager)
 NS_IMPL_CYCLE_COLLECTION(
     EventStateManager, mCurrentTargetContent, mGestureDownContent,
     mGestureDownFrameOwner, mLastLeftMouseDownContent,
-    mLastLeftMouseDownContentParent, mLastMiddleMouseDownContent,
-    mLastMiddleMouseDownContentParent, mLastRightMouseDownContent,
-    mLastRightMouseDownContentParent, mActiveContent, mHoverContent,
-    mURLTargetContent, mMouseEnterLeaveHelper, mPointersEnterLeaveHelper,
-    mDocument, mIMEContentObserver, mAccessKeys)
+    mLastMiddleMouseDownContent, mLastRightMouseDownContent, mActiveContent,
+    mHoverContent, mURLTargetContent, mMouseEnterLeaveHelper,
+    mPointersEnterLeaveHelper, mDocument, mIMEContentObserver, mAccessKeys)
 
 void EventStateManager::ReleaseCurrentIMEContentObserver() {
   if (mIMEContentObserver) {
@@ -4529,16 +4527,13 @@ nsresult EventStateManager::SetClickCount(WidgetMouseEvent* aEvent,
                                           nsEventStatus* aStatus,
                                           nsIContent* aOverrideClickTarget) {
   nsCOMPtr<nsIContent> mouseContent = aOverrideClickTarget;
-  nsIContent* mouseContentParent = nullptr;
   if (!mouseContent && mCurrentTarget) {
     mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(mouseContent));
   }
-  if (mouseContent) {
-    if (mouseContent->IsNodeOfType(nsINode::eTEXT)) {
-      mouseContent = mouseContent->GetParent();
-    }
-    if (mouseContent && mouseContent->IsRootOfNativeAnonymousSubtree()) {
-      mouseContentParent = mouseContent->GetParent();
+  if (mouseContent && mouseContent->IsText()) {
+    nsINode* parent = mouseContent->GetFlattenedTreeParentNode();
+    if (parent && parent->IsContent()) {
+      mouseContent = parent->AsContent();
     }
   }
 
@@ -4546,54 +4541,51 @@ nsresult EventStateManager::SetClickCount(WidgetMouseEvent* aEvent,
     case WidgetMouseEvent::eLeftButton:
       if (aEvent->mMessage == eMouseDown) {
         mLastLeftMouseDownContent = mouseContent;
-        mLastLeftMouseDownContentParent = mouseContentParent;
       } else if (aEvent->mMessage == eMouseUp) {
-        if (mLastLeftMouseDownContent == mouseContent ||
-            mLastLeftMouseDownContentParent == mouseContent ||
-            mLastLeftMouseDownContent == mouseContentParent) {
+        aEvent->mClickTarget =
+          nsContentUtils::GetCommonAncestorUnderInteractiveContent(
+            mouseContent, mLastLeftMouseDownContent);
+        if (aEvent->mClickTarget) {
           aEvent->mClickCount = mLClickCount;
           mLClickCount = 0;
         } else {
           aEvent->mClickCount = 0;
         }
         mLastLeftMouseDownContent = nullptr;
-        mLastLeftMouseDownContentParent = nullptr;
       }
       break;
 
     case WidgetMouseEvent::eMiddleButton:
       if (aEvent->mMessage == eMouseDown) {
         mLastMiddleMouseDownContent = mouseContent;
-        mLastMiddleMouseDownContentParent = mouseContentParent;
       } else if (aEvent->mMessage == eMouseUp) {
-        if (mLastMiddleMouseDownContent == mouseContent ||
-            mLastMiddleMouseDownContentParent == mouseContent ||
-            mLastMiddleMouseDownContent == mouseContentParent) {
+        aEvent->mClickTarget =
+          nsContentUtils::GetCommonAncestorUnderInteractiveContent(
+            mouseContent, mLastMiddleMouseDownContent);
+        if (aEvent->mClickTarget) {
           aEvent->mClickCount = mMClickCount;
           mMClickCount = 0;
         } else {
           aEvent->mClickCount = 0;
         }
         mLastMiddleMouseDownContent = nullptr;
-        mLastMiddleMouseDownContentParent = nullptr;
       }
       break;
 
     case WidgetMouseEvent::eRightButton:
       if (aEvent->mMessage == eMouseDown) {
         mLastRightMouseDownContent = mouseContent;
-        mLastRightMouseDownContentParent = mouseContentParent;
       } else if (aEvent->mMessage == eMouseUp) {
-        if (mLastRightMouseDownContent == mouseContent ||
-            mLastRightMouseDownContentParent == mouseContent ||
-            mLastRightMouseDownContent == mouseContentParent) {
+        aEvent->mClickTarget =
+          nsContentUtils::GetCommonAncestorUnderInteractiveContent(
+            mouseContent, mLastRightMouseDownContent);
+        if (aEvent->mClickTarget) {
           aEvent->mClickCount = mRClickCount;
           mRClickCount = 0;
         } else {
           aEvent->mClickCount = 0;
         }
         mLastRightMouseDownContent = nullptr;
-        mLastRightMouseDownContentParent = nullptr;
       }
       break;
   }
@@ -4626,6 +4618,10 @@ nsresult EventStateManager::InitAndDispatchClickEvent(
     targetFrame = aOverrideClickTarget->GetPrimaryFrame();
   }
 
+  if (!target->IsInComposedDoc()) {
+    return NS_OK;
+  }
+
   return aPresShell->HandleEventWithTarget(&event, targetFrame, target,
                                            aStatus);
 }
@@ -4635,9 +4631,13 @@ nsresult EventStateManager::CheckForAndDispatchClick(
     nsIContent* aOverrideClickTarget) {
   nsresult ret = NS_OK;
 
+  nsCOMPtr<nsIContent> clickTarget =
+    do_QueryInterface(aEvent->mClickTarget);
+  NS_ENSURE_STATE(clickTarget);
+
   // If mouse is still over same element, clickcount will be > 1.
   // If it has moved it will be zero, so no click.
-  if (aEvent->mClickCount) {
+  if (aEvent->mClickCount && clickTarget) {
     // Check that the window isn't disabled before firing a click
     //(see bug 366544).
     if (aEvent->mWidget && !aEvent->mWidget->IsEnabled()) {
@@ -4652,36 +4652,23 @@ nsresult EventStateManager::CheckForAndDispatchClick(
 
     nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
     if (presShell) {
-      nsCOMPtr<nsIContent> mouseContent = GetEventTargetContent(aEvent);
-      // Click events apply to *elements* not nodes. At this point the target
-      // content may have been reset to some non-element content, and so we need
-      // to walk up the closest ancestor element, just like we do in
-      // nsPresShell::HandleEvent.
-      while (mouseContent && !mouseContent->IsElement()) {
-        mouseContent = mouseContent->GetParent();
-      }
-
-      if (!mouseContent && !mCurrentTarget && !aOverrideClickTarget) {
-        return NS_OK;
-      }
 
-      // HandleEvent clears out mCurrentTarget which we might need again
-      AutoWeakFrame currentTarget = mCurrentTarget;
+      AutoWeakFrame currentTarget = clickTarget->GetPrimaryFrame();
       ret = InitAndDispatchClickEvent(
-          aEvent, aStatus, eMouseClick, presShell, mouseContent, currentTarget,
+          aEvent, aStatus, eMouseClick, presShell, clickTarget, currentTarget,
           notDispatchToContents, aOverrideClickTarget);
 
-      if (NS_SUCCEEDED(ret) && aEvent->mClickCount == 2 && mouseContent &&
-          mouseContent->IsInComposedDoc()) {
+      if (NS_SUCCEEDED(ret) && aEvent->mClickCount == 2 && clickTarget &&
+          clickTarget->IsInComposedDoc()) {
         // fire double click
         ret = InitAndDispatchClickEvent(
-            aEvent, aStatus, eMouseDoubleClick, presShell, mouseContent,
+            aEvent, aStatus, eMouseDoubleClick, presShell, clickTarget,
             currentTarget, notDispatchToContents, aOverrideClickTarget);
       }
-      if (NS_SUCCEEDED(ret) && mouseContent && fireAuxClick &&
-          mouseContent->IsInComposedDoc()) {
+      if (NS_SUCCEEDED(ret) && clickTarget && fireAuxClick &&
+          clickTarget->IsInComposedDoc()) {
         ret = InitAndDispatchClickEvent(aEvent, aStatus, eMouseAuxClick,
-                                        presShell, mouseContent, currentTarget,
+                                        presShell, clickTarget, currentTarget,
                                         false, aOverrideClickTarget);
       }
     }
diff --git a/dom/events/EventStateManager.h b/dom/events/EventStateManager.h
index d698b6c4ee6d..ed5c6e6427e7 100644
--- a/dom/events/EventStateManager.h
+++ b/dom/events/EventStateManager.h
@@ -1014,11 +1014,8 @@ class EventStateManager : public nsSupportsWeakReference, public nsIObserver {
   uint16_t mGestureDownButtons;
 
   nsCOMPtr<nsIContent> mLastLeftMouseDownContent;
-  nsCOMPtr<nsIContent> mLastLeftMouseDownContentParent;
   nsCOMPtr<nsIContent> mLastMiddleMouseDownContent;
-  nsCOMPtr<nsIContent> mLastMiddleMouseDownContentParent;
   nsCOMPtr<nsIContent> mLastRightMouseDownContent;
-  nsCOMPtr<nsIContent> mLastRightMouseDownContentParent;
 
   nsCOMPtr<nsIContent> mActiveContent;
   nsCOMPtr<nsIContent> mHoverContent;
diff --git a/dom/events/test/test_bug556493.html b/dom/events/test/test_bug556493.html
index 3a86ada65fae..6084fccaa1c2 100644
--- a/dom/events/test/test_bug556493.html
+++ b/dom/events/test/test_bug556493.html
@@ -58,7 +58,7 @@ function runTest() {
 
   is(downCount, 3, "Wrong mousedown event count!");
   is(upCount, 3, "Wrong mouseup event count!");
-  is(clickCount, 2, "Wrong click event count!");
+  is(clickCount, 3, "Wrong click event count!");
 
   SimpleTest.finish();
 }
diff --git a/dom/events/test/test_dblclick_explicit_original_target.html b/dom/events/test/test_dblclick_explicit_original_target.html
index 8aa5f5d4c794..65e268cd8fb7 100644
--- a/dom/events/test/test_dblclick_explicit_original_target.html
+++ b/dom/events/test/test_dblclick_explicit_original_target.html
@@ -22,8 +22,27 @@ function runTests()
   synthesizeMouse(document.getElementById("display"), 5, 5, { clickCount: 2 });
 }
 
+window.onmousedown = function(event) {
+  is(event.explicitOriginalTarget.nodeType, Node.TEXT_NODE,
+     "explicitOriginalTarget is a text node");
+  is(event.explicitOriginalTarget, document.getElementById("display").firstChild,
+     "explicitOriginalTarget should point to the child node of the click target");
+}
+
+window.onmouseup = function(event) {
+  is(event.explicitOriginalTarget.nodeType, Node.TEXT_NODE,
+     "explicitOriginalTarget is a text node");
+  is(event.explicitOriginalTarget, document.getElementById("display").firstChild,
+     "explicitOriginalTarget should point to the child node of the click target");
+}
+
+// The old versions of Gecko had explicitOriginalTarget pointing to a Text node
+// when handling *click events, newer versions target Elements.
 window.ondblclick = function(event) {
-  is(event.explicitOriginalTarget.nodeType, Node.TEXT_NODE, "explicitOriginalTarget is a text node");
+  is(event.explicitOriginalTarget.nodeType, Node.ELEMENT_NODE,
+     "explicitOriginalTarget is an element node");
+    is(event.explicitOriginalTarget, document.getElementById("display"),
+     "explicitOriginalTarget should point to the click target");
   SimpleTest.finish();
 }
 
diff --git a/dom/html/HTMLButtonElement.cpp b/dom/html/HTMLButtonElement.cpp
index 95a030a5294f..230e164b2672 100644
--- a/dom/html/HTMLButtonElement.cpp
+++ b/dom/html/HTMLButtonElement.cpp
@@ -170,11 +170,14 @@ nsresult HTMLButtonElement::GetEventTargetParent(
   WidgetMouseEvent* mouseEvent = aVisitor.mEvent->AsMouseEvent();
   bool outerActivateEvent = ((mouseEvent && mouseEvent->IsLeftClickEvent()) ||
                              (aVisitor.mEvent->mMessage == eLegacyDOMActivate &&
-                              !mInInternalActivate));
+                              !mInInternalActivate &&
+                              aVisitor.mEvent->mOriginalTarget == this));
 
   if (outerActivateEvent) {
     aVisitor.mItemFlags |= NS_OUTER_ACTIVATE_EVENT;
-    if (mType == NS_FORM_BUTTON_SUBMIT && mForm) {
+    if (mType == NS_FORM_BUTTON_SUBMIT && mForm &&
+        !aVisitor.mEvent->mFlags.mMultiplePreActionsPrevented) {
+      aVisitor.mEvent->mFlags.mMultiplePreActionsPrevented = true;
       aVisitor.mItemFlags |= NS_IN_SUBMIT_CLICK;
       // tell the form that we are about to enter a click handler.
       // that means that if there are scripted submissions, the
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
index 9d4957159c91..c12cb6bf045d 100644
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -132,11 +132,14 @@ namespace dom {
 #define NS_ORIGINAL_CHECKED_VALUE (1 << 10)
 #define NS_NO_CONTENT_DISPATCH (1 << 11)
 #define NS_ORIGINAL_INDETERMINATE_VALUE (1 << 12)
-#define NS_CONTROL_TYPE(bits)                                       \
-  ((bits) & ~(NS_OUTER_ACTIVATE_EVENT | NS_ORIGINAL_CHECKED_VALUE | \
-              NS_NO_CONTENT_DISPATCH | NS_ORIGINAL_INDETERMINATE_VALUE))
 #define NS_PRE_HANDLE_BLUR_EVENT (1 << 13)
 #define NS_PRE_HANDLE_INPUT_EVENT (1 << 14)
+#define NS_IN_SUBMIT_CLICK (1 << 15)
+#define NS_CONTROL_TYPE(bits)                                             \
+  ((bits) & ~(NS_OUTER_ACTIVATE_EVENT | NS_ORIGINAL_CHECKED_VALUE |       \
+              NS_NO_CONTENT_DISPATCH |  NS_ORIGINAL_INDETERMINATE_VALUE | \
+              NS_PRE_HANDLE_BLUR_EVENT | NS_PRE_HANDLE_INPUT_EVENT |      \
+              NS_IN_SUBMIT_CLICK))
 
 // whether textfields should be selected once focused:
 //  -1: no, 1: yes, 0: uninitialized
@@ -3310,7 +3313,10 @@ nsresult HTMLInputElement::GetEventTargetParent(
 
       case NS_FORM_INPUT_SUBMIT:
       case NS_FORM_INPUT_IMAGE:
-        if (mForm) {
+        if (mForm && !aVisitor.mEvent->mFlags.mMultiplePreActionsPrevented) {
+          // Make sure other submit elements don't try to trigger submission.
+          aVisitor.mEvent->mFlags.mMultiplePreActionsPrevented = true;
+          aVisitor.mItemFlags |= NS_IN_SUBMIT_CLICK;
           // tell the form that we are about to enter a click handler.
           // that means that if there are scripted submissions, the
           // latest one will be deferred until after the exit point of the
@@ -3866,17 +3872,15 @@ nsresult HTMLInputElement::PostHandleEvent(EventChainPostVisitor& aVisitor) {
     }
   }
 
-  if (outerActivateEvent) {
+  if ((aVisitor.mItemFlags & NS_IN_SUBMIT_CLICK) && mForm) {
     switch (oldType) {
       case NS_FORM_INPUT_SUBMIT:
       case NS_FORM_INPUT_IMAGE:
-        if (mForm) {
-          // tell the form that we are about to exit a click handler
-          // so the form knows not to defer subsequent submissions
-          // the pending ones that were created during the handler
-          // will be flushed or forgoten.
-          mForm->OnSubmitClickEnd();
-        }
+        // tell the form that we are about to exit a click handler
+        // so the form knows not to defer subsequent submissions
+        // the pending ones that were created during the handler
+        // will be flushed or forgoten.
+        mForm->OnSubmitClickEnd();
         break;
       default:
         break;
@@ -4241,7 +4245,8 @@ nsresult HTMLInputElement::PostHandleEvent(EventChainPostVisitor& aVisitor) {
       if (outerActivateEvent) {
         if (mForm && (oldType == NS_FORM_INPUT_SUBMIT ||
                       oldType == NS_FORM_INPUT_IMAGE)) {
-          if (mType != NS_FORM_INPUT_SUBMIT && mType != NS_FORM_INPUT_IMAGE) {
+          if (mType != NS_FORM_INPUT_SUBMIT && mType != NS_FORM_INPUT_IMAGE &&
+              aVisitor.mItemFlags & NS_IN_SUBMIT_CLICK) {
             // If the type has changed to a non-submit type, then we want to
             // flush the stored submission if there is one (as if the submit()
             // was allowed to succeed)
@@ -4281,7 +4286,7 @@ nsresult HTMLInputElement::PostHandleEvent(EventChainPostVisitor& aVisitor) {
             break;
         }  // switch
       }    // click or outer activate event
-    } else if (outerActivateEvent &&
+    } else if ((aVisitor.mItemFlags & NS_IN_SUBMIT_CLICK) &&
                (oldType == NS_FORM_INPUT_SUBMIT ||
                 oldType == NS_FORM_INPUT_IMAGE) &&
                mForm) {
diff --git a/layout/forms/nsHTMLButtonControlFrame.cpp b/layout/forms/nsHTMLButtonControlFrame.cpp
index 083169b6850c..f8e7469976f0 100644
--- a/layout/forms/nsHTMLButtonControlFrame.cpp
+++ b/layout/forms/nsHTMLButtonControlFrame.cpp
@@ -95,8 +95,10 @@ void nsHTMLButtonControlFrame::BuildDisplayList(
 
   nsDisplayListCollection set(aBuilder);
 
-  // Do not allow the child subtree to receive events.
-  if (!isForEventDelivery || aBuilder->HitTestIsForVisibility()) {
+  // Do not allow the child subtree to receive events,
+  // except in case of <button>.
+  if (!isForEventDelivery || mContent->IsHTMLElement(nsGkAtoms::button) ||
+      aBuilder->HitTestIsForVisibility()) {
     DisplayListClipState::AutoSaveRestore clipState(aBuilder);
 
     if (ShouldClipPaintingToBorderBox()) {
diff --git a/testing/web-platform/tests/html/semantics/forms/the-button-element/button-events.html b/testing/web-platform/tests/html/semantics/forms/the-button-element/button-events.html
index 9d308bbed3cc..adac5bb121b9 100644
--- a/testing/web-platform/tests/html/semantics/forms/the-button-element/button-events.html
+++ b/testing/web-platform/tests/html/semantics/forms/the-button-element/button-events.html
@@ -18,8 +18,14 @@
 var btn = document.getElementById("btn"),
     menu_btn = document.getElementById("menu_btn"),
     t1 = async_test("The submit event must be fired when click a button in submit status"),
-    t2 = async_test("The reset event must be fired when click a button in reset status"),
-    t3 = async_test("The show event must be fired when click a button in menu status");
+    t2 = async_test("The reset event must be fired when click a button in reset status");
+    t3 = async_test("type=button shouldn't trigger submit or reset events");
+    t4 = async_test("Switching from type=button to type=submit should submit the form");
+    t5 = async_test("Switching from type=button to type=reset should reset the form");
+    t6 = async_test("Innermost button should submit its form");
+    t7 = async_test("Innermost button should reset its form");
+    t8 = async_test("Anchor inside a button should be prevent button activation");
+    t9 = async_test("input type=submit inside a button should be prevent button activation");
 
 document.forms.fm1.onsubmit = t1.step_func(function (evt) {
   evt.preventDefault();
@@ -59,8 +65,113 @@ t2.step(function () {
 });
 
 t3.step(function () {
-  assert_equals(menu_btn.type, "menu", "The button type should be 'menu'.");
-  menu_btn.click();
+  btn.type = "button";
+  assert_equals(btn.type, "button", "The button type should be 'button'.");
+  document.forms.fm1.onsubmit = t3.step_func(function (evt) {
+    assert_unreached("type=button shouldn't trigger submission.");
+  });
+  document.forms.fm1.onreset = t3.step_func(function (evt) {
+    assert_unreached("type=button shouldn't reset the form.");
+  });
+  btn.click();
+  t3.done();
+});
+
+t4.step(function () {
+  btn.type = "button";
+  btn.onclick = function() { btn.type = "submit"; }
+  document.forms.fm1.onsubmit = t4.step_func(function (evt) {
+    evt.preventDefault();
+    assert_equals(btn.type, "submit", "The button type should be 'submit'.");
+    t4.done();
+  });
+  btn.click();
+});
+
+t5.step(function () {
+  btn.type = "button";
+  btn.onclick = function() { btn.type = "reset"; }
+  document.forms.fm1.onreset = t5.step_func(function (evt) {
+    evt.preventDefault();
+    assert_equals(btn.type, "reset", "The button type should be 'reset'.");
+    t5.done();
+  });
+  btn.click();
+});
+
+t6.step(function () {
+  btn.type = "submit";
+  btn.innerHTML = "";
+  var fm2 = document.createElement("form");
+  var btn2 = document.createElement("button");
+  btn2.type = "submit";
+  fm2.appendChild(btn2);
+  btn.appendChild(fm2);
+  assert_true(document.forms.fm1.contains(fm2), "Should have nested forms");
+
+  function submitListener(evt) {
+    evt.preventDefault();
+    assert_equals(evt.target, fm2, "Innermost form should have got the submit event");
+  };
+  window.addEventListener("submit", submitListener, true);
+  btn2.click();
+  window.removeEventListener("submit", submitListener, true);
+  t6.done();
+});
+
+t7.step(function () {
+  btn.type = "reset";
+  btn.innerHTML = "";
+  var fm2 = document.createElement("form");
+  var btn2 = document.createElement("button");
+  btn2.type = "reset";
+  fm2.appendChild(btn2);
+  btn.appendChild(fm2);
+  assert_true(document.forms.fm1.contains(fm2), "Should have nested forms");
+
+  function resetListener(evt) {
+    evt.currentTarget.removeEventListener(evt.type, resetListener, true);
+    evt.preventDefault();
+    assert_equals(evt.target, fm2, "Innermost form should have got the reset event");
+    t7.done();
+  };
+  window.addEventListener("reset", resetListener, true);
+  btn2.click();
+});
+
+t8.step(function () {
+  btn.type = "submit";
+  btn.innerHTML = "";
+  var a = document.createElement("a");
+  a.href = "#";
+  btn.appendChild(a);
+  document.forms.fm1.onsubmit = t8.step_func(function (evt) {
+    assert_unreached("type=button shouldn't trigger submission.");
+  });
+
+  a.click();
+  t8.done();
+});
+
+t9.step(function () {
+  btn.type = "submit";
+  btn.innerHTML = "";
+  var fm2 = document.createElement("form");
+  var btn2 = document.createElement("input");
+  btn2.type = "submit";
+  fm2.appendChild(btn2);
+  btn.appendChild(fm2);
+  assert_true(document.forms.fm1.contains(fm2), "Should have nested forms");
+
+  function submitListener(evt) {
+    evt.preventDefault();
+    assert_equals(evt.target, fm2, "Innermost form should have got the submit event");
+  };
+
+  window.addEventListener("submit", submitListener, true);
+  btn2.click();
+  window.removeEventListener("submit", submitListener, true);
+  t9.done();
 });
 
 </script>
diff --git a/toolkit/content/widgets/datetimebox.xml b/toolkit/content/widgets/datetimebox.xml
index 21675410a577..1ff954e4be52 100644
--- a/toolkit/content/widgets/datetimebox.xml
+++ b/toolkit/content/widgets/datetimebox.xml
@@ -1209,7 +1209,11 @@
         </html:span>
 
         <html:button class="datetime-reset-button" anonid="reset-button"
-                     tabindex="-1" xbl:inherits="disabled" aria-label="&datetime.reset.label;"/>
+                     tabindex="-1" xbl:inherits="disabled" aria-label="&datetime.reset.label;">
+          <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" style="pointer-events: none;">
+            <path d="M 3.9,3 3,3.9 5.1,6 3,8.1 3.9,9 6,6.9 8.1,9 9,8.1 6.9,6 9,3.9 8.1,3 6,5.1 Z M 12,6 A 6,6 0 0 1 6,12 6,6 0 0 1 0,6 6,6 0 0 1 6,0 6,6 0 0 1 12,6 Z"/>
+          </svg>
+        </html:button>
       </html:div>
     </content>
 
diff --git a/widget/BasicEvents.h b/widget/BasicEvents.h
index 93ecb246e974..8b7e1621e68c 100644
--- a/widget/BasicEvents.h
+++ b/widget/BasicEvents.h
@@ -83,6 +83,8 @@ struct BaseEventFlags {
   // the first <label> element is clicked, that one may set this true.
   // Then, the second <label> element won't handle the event.
   bool mMultipleActionsPrevented : 1;
+  // Similar to above but expected to be used during PreHandleEvent phase.
+  bool mMultiplePreActionsPrevented : 1;
   // If mIsBeingDispatched is true, the DOM event created from the event is
   // dispatching into the DOM tree and not completed.
   bool mIsBeingDispatched : 1;
diff --git a/widget/MouseEvents.h b/widget/MouseEvents.h
index 45eb66a445ad..3f4ba68ebb1a 100644
--- a/widget/MouseEvents.h
+++ b/widget/MouseEvents.h
@@ -270,6 +270,10 @@ class WidgetMouseEvent : public WidgetMouseEventBase,
     return result;
   }
 
+  // If during mouseup handling we detect that click event might need to be
+  // dispatched, this is setup to be the target of the click event.
+  nsCOMPtr<dom::EventTarget> mClickTarget;
+
   // mReason indicates the reason why the event is fired:
   // - Representing mouse operation.
   // - Synthesized for emulating mousemove event when the content under the
-- 
2.26.2

